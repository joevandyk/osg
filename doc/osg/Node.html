<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::Node</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.3">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::Node</A>: public <!1><A HREF="Object.html#DOC.2.36.1">Object</A></H2>
<BLOCKQUOTE>Base class for all internal nodes in the scene graph.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=185>
<param name=classes value="CReferenced,MReferenced.html,CObject,MObject.html,CNode,MNode.html,CLightSource,MLightSource.html,CGroup,MGroup.html,CGeode,MGeode.html">
<param name=before value="M,M,M,M|_,MR_,Mr_">
<param name=after value="Md_SP,Md_,M,M,M,M">
<param name=indent value="0,1,2,2,2,2">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<A HREF="#DOC.2.30.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Node</B>()
<DD><I>Construct a node.</I>
<DT>
<A HREF="#DOC.2.30.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   <!1><A HREF="Object.html#DOC.2.36.1">Object</A>* <B>clone</B>() const 
<DD><I>return a shallow copy of a node, with Object* return type</I>
<DT>
<A HREF="#DOC.2.30.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="Node.html#DOC.2.30.1">Node</A>* <B>cloneNode</B>() const 
<DD><I>return a shallow copy of a node, with Node* return type</I>
<DT>
<A HREF="#DOC.2.30.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   bool <B>isSameKindAs</B>(<!1><A HREF="Object.html#DOC.2.36.1">Object</A>* obj)
<DD><I>return true if this and obj are of the same kind of object</I>
<DT>
<A HREF="#DOC.2.30.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   const char* <B>className</B>() const 
<DD><I>return the name of the node's class type</I>
<DT>
<A HREF="#DOC.2.30.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>accept</B>(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)
<DD><I>Visitor Pattern : calls the apply method of a NodeVisitor with this node's type</I>
<DT>
<A HREF="#DOC.2.30.7"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>ascend</B>(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)
<DD><I>Traverse upwards : calls parents' accept method with NodeVisitor</I>
<DT>
<A HREF="#DOC.2.30.8"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>traverse</B>(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; )
<DD><I>Traverse downwards : calls children's accept method with NodeVisitor</I>
<DT>
<A HREF="#DOC.2.30.9"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>setName</B>( const std::string&amp; name )
<DD><I>Set the name of node using C++ style string</I>
<DT>
<A HREF="#DOC.2.30.10"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>setName</B>( const char* name )
<DD><I>Set the name of node using a C style string</I>
<DT>
<A HREF="#DOC.2.30.11"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>const std::string&amp; <B>getName</B>( void )
<DD><I>Get the name of node</I>
<DT>
<A HREF="#DOC.2.30.13"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>const <!1><A HREF="Node.html#DOC.2.30.12">ParentList</A>&amp; <B>getParents</B>() const 
<DD><I>Get the parent list of node.</I>
<DT>
<A HREF="#DOC.2.30.14"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="Node.html#DOC.2.30.39">Group</A>* <B>getParent</B>(int i) const 
<DD><I> Get a single parent of node.</I>
<DT>
<A HREF="#DOC.2.30.15"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>getNumParents</B>() const 
<DD><I> Get the number of parents of node.</I>
<DT>
<A HREF="#DOC.2.30.16"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>setUserData</B>(void* data, <!1><A HREF="MemoryAdapter.html">MemoryAdapter</A>* ma=0L)
<DD><I> Set user data.</I>
<DT>
<A HREF="#DOC.2.30.17"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void* <B>getUserData</B>() const 
<DD><I>Get user data</I>
<DT>
<A HREF="#DOC.2.30.18"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="MemoryAdapter.html">MemoryAdapter</A>* <B>getMemoryAdapter</B>() const 
<DD><I>Get the memory adapter associated with _userData</I>
<DT>
<A HREF="#DOC.2.30.19"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>setNodeMask</B>(<!1><A HREF="Node.html#DOC.2.30.34">NodeMask</A> nm)
<DD><I>Set the node mask.</I>
<DT>
<A HREF="#DOC.2.30.20"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="Node.html#DOC.2.30.34">NodeMask</A> <B>getNodeMask</B>()
<DD><I>Get the node Mask.</I>
<DT>
<A HREF="#DOC.2.30.22"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>const <!1><A HREF="Node.html#DOC.2.30.21">DescriptionList</A>&amp; <B>getDescriptions</B>() const 
<DD><I>Get the description list of the const node</I>
<DT>
<A HREF="#DOC.2.30.23"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="Node.html#DOC.2.30.21">DescriptionList</A>&amp; <B>getDescriptions</B>()
<DD><I>Get the description list of the const node</I>
<DT>
<A HREF="#DOC.2.30.24"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>const std::string&amp; <B>getDescription</B>(int i) const 
<DD><I>Get a single const description of the const node</I>
<DT>
<A HREF="#DOC.2.30.25"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>std::string&amp; <B>getDescription</B>(int i)
<DD><I>Get a single description of the node</I>
<DT>
<A HREF="#DOC.2.30.26"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>getNumDescriptions</B>() const 
<DD><I>Get the number of descriptions of the node</I>
<DT>
<A HREF="#DOC.2.30.27"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>addDescription</B>(const std::string&amp; desc)
<DD><I>Add a description string to the node</I>
<DT>
<A HREF="#DOC.2.30.28"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>const <!1><A HREF="BoundingSphere.html">BoundingSphere</A>&amp; <B>getBound</B>()
<DD><I>get the bounding sphere of node.</I>
<DT>
<A HREF="#DOC.2.30.29"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>dirtyBound</B>()
<DD><I>Mark this node's bounding sphere dirty.</I>
</DL></P>

<P><DL>
<DT><H3>Public</H3><DD><DT>
<A HREF="#DOC.2.30.12"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>typedef  std::vector&lt;<!1><A HREF="Node.html#DOC.2.30.39">Group</A>*&gt;  <B>ParentList</B>
<DD><I>A vector of osg::Group pointers which is used to store the parent(s) of node</I>
<DT>
<A HREF="#DOC.2.30.34"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>typedef  unsigned int <B>NodeMask</B>
<DD><I></I>
<DT>
<A HREF="#DOC.2.30.21"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>typedef  std::vector&lt;std::string&gt;  <B>DescriptionList</B>
<DD><I>A vector of std::string's which are used to describe the object</I>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<A HREF="#DOC.2.30.35"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="BoundingSphere.html">BoundingSphere</A> <B>_bsphere</B>
<DD><I></I>
<DT>
<A HREF="#DOC.2.30.36"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>bool <B>_bsphere_computed</B>
<DD><I></I>
<DT>
<A HREF="#DOC.2.30.37"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>std::string <B>_name</B>
<DD><I></I>
<DT>
<A HREF="#DOC.2.30.38"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="Node.html#DOC.2.30.12">ParentList</A> <B>_parents</B>
<DD><I></I>
<DT>
<A HREF="#DOC.2.30.39"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>friend <B>Group</B>
<DD><I></I>
<DT>
<A HREF="#DOC.2.30.40"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void* <B>_userData</B>
<DD><I></I>
<DT>
<A HREF="#DOC.2.30.41"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="MemoryAdapter.html">MemoryAdapter</A>&gt;  <B>_memoryAdapter</B>
<DD><I></I>
<DT>
<A HREF="#DOC.2.30.42"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="Node.html#DOC.2.30.34">NodeMask</A> <B>_nodeMask</B>
<DD><I></I>
<DT>
<A HREF="#DOC.2.30.43"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="Node.html#DOC.2.30.21">DescriptionList</A> <B>_descriptions</B>
<DD><I></I>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<A HREF="#DOC.2.30.30"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   <B>~Node</B>()
<DD><I>Node destructor.</I>
<DT>
<A HREF="#DOC.2.30.31"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   bool <B>readLocalData</B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DD><I> Template Method Pattern : read local data from osg file.</I>
<DT>
<A HREF="#DOC.2.30.32"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   bool <B>writeLocalData</B>(<!1><A HREF="Output.html">Output</A>&amp; fw)
<DD><I> Template Method Pattern : read local data from osg file.</I>
<DT>
<A HREF="#DOC.2.30.33"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   bool <B>computeBound</B>( void )
<DD><I>Compute the bounding sphere around Node's geometry or children.</I>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Object.html">Object</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>virtual   <!1><A HREF="Object.html#DOC.2.36.1">Object</A>* <B>readClone</B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   bool <B>write</B>(<!1><A HREF="Output.html">Output</A>&amp; fw)
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Referenced.html">Referenced</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="Referenced.html#DOC.2.43.4">Referenced</A>&amp; <B>operator = </B>(<!1><A HREF="Referenced.html#DOC.2.43.4">Referenced</A>&amp;)
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>ref</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>unref</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>int <B>referenceCount</B>()
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>int <B>_refCount</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU">
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>Base class for all internal nodes in the scene graph.
Provides interface for most common node operations (Composite Pattern).</BLOCKQUOTE>
<DL>

<A NAME="Node">
<A NAME="DOC.2.30.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Node()</B></TT>
<DD>Construct a node.
Initialize the parent list to empty, node name to "" and 
bounding sphere dirty flag to true.
<DL><DT><DD></DL><P>
<A NAME="clone">
<A NAME="DOC.2.30.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="Object.html#DOC.2.36.1">Object</A>* clone() const </B></TT>
<DD>return a shallow copy of a node, with Object* return type
<DL><DT><DD></DL><P>
<A NAME="cloneNode">
<A NAME="DOC.2.30.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Node.html#DOC.2.30.1">Node</A>* cloneNode() const </B></TT>
<DD>return a shallow copy of a node, with Node* return type
<DL><DT><DD></DL><P>
<A NAME="isSameKindAs">
<A NAME="DOC.2.30.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool isSameKindAs(<!1><A HREF="Object.html#DOC.2.36.1">Object</A>* obj)</B></TT>
<DD>return true if this and obj are of the same kind of object
<DL><DT><DD></DL><P>
<A NAME="className">
<A NAME="DOC.2.30.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const char* className() const </B></TT>
<DD>return the name of the node's class type
<DL><DT><DD></DL><P>
<A NAME="accept">
<A NAME="DOC.2.30.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void accept(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)</B></TT>
<DD>Visitor Pattern : calls the apply method of a NodeVisitor with this node's type
<DL><DT><DD></DL><P>
<A NAME="ascend">
<A NAME="DOC.2.30.7">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void ascend(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)</B></TT>
<DD>Traverse upwards : calls parents' accept method with NodeVisitor
<DL><DT><DD></DL><P>
<A NAME="traverse">
<A NAME="DOC.2.30.8">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void traverse(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; )</B></TT>
<DD>Traverse downwards : calls children's accept method with NodeVisitor
<DL><DT><DD></DL><P>
<A NAME="setName">
<A NAME="DOC.2.30.9">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setName( const std::string&amp; name )</B></TT>
<DD>Set the name of node using C++ style string
<DL><DT><DD></DL><P>
<A NAME="setName">
<A NAME="DOC.2.30.10">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setName( const char* name )</B></TT>
<DD>Set the name of node using a C style string
<DL><DT><DD></DL><P>
<A NAME="getName">
<A NAME="DOC.2.30.11">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const std::string&amp; getName( void )</B></TT>
<DD>Get the name of node
<DL><DT><DD></DL><P>
<A NAME="ParentList">
<A NAME="DOC.2.30.12">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;<!1><A HREF="Node.html#DOC.2.30.39">Group</A>*&gt;  ParentList</B></TT>
<DD>A vector of osg::Group pointers which is used to store the parent(s) of node
<DL><DT><DD></DL><P>
<A NAME="getParents">
<A NAME="DOC.2.30.13">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="Node.html#DOC.2.30.12">ParentList</A>&amp; getParents() const </B></TT>
<DD>Get the parent list of node. 
<DL><DT><DD></DL><P>
<A NAME="getParent">
<A NAME="DOC.2.30.14">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Node.html#DOC.2.30.39">Group</A>* getParent(int i) const </B></TT>
<DD>
Get a single parent of node.

<DL><DT><DT><B>Parameters:</B><DD><B>i</B> -  index of the parent to get.
<BR><DT><B>Returns:</B><DD>  the parent i.<BR><DD></DL><P>
<A NAME="getNumParents">
<A NAME="DOC.2.30.15">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int getNumParents() const </B></TT>
<DD>
Get the number of parents of node.

<DL><DT><DT><B>Returns:</B><DD>  the number of parents of this node.<BR><DD></DL><P>
<A NAME="setUserData">
<A NAME="DOC.2.30.16">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setUserData(void* data, <!1><A HREF="MemoryAdapter.html">MemoryAdapter</A>* ma=0L)</B></TT>
<DD>
Set user data. See MemoryAdapter documention for details
of how to specify memory managament of _userData.
<DL><DT><DD></DL><P>
<A NAME="getUserData">
<A NAME="DOC.2.30.17">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void* getUserData() const </B></TT>
<DD>Get user data
<DL><DT><DD></DL><P>
<A NAME="getMemoryAdapter">
<A NAME="DOC.2.30.18">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="MemoryAdapter.html">MemoryAdapter</A>* getMemoryAdapter() const </B></TT>
<DD>Get the memory adapter associated with _userData
<DL><DT><DD></DL><P>
<A NAME="NodeMask">
<A NAME="DOC.2.30.34">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  unsigned int NodeMask</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setNodeMask">
<A NAME="DOC.2.30.19">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setNodeMask(<!1><A HREF="Node.html#DOC.2.30.34">NodeMask</A> nm)</B></TT>
<DD>Set the node mask. Note, node mask is will be replaced by TraversalMask.
<DL><DT><DD></DL><P>
<A NAME="getNodeMask">
<A NAME="DOC.2.30.20">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Node.html#DOC.2.30.34">NodeMask</A> getNodeMask()</B></TT>
<DD>Get the node Mask. Note, node mask is will be replaced by TraversalMask.
<DL><DT><DD></DL><P>
<A NAME="DescriptionList">
<A NAME="DOC.2.30.21">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;std::string&gt;  DescriptionList</B></TT>
<DD>A vector of std::string's which are used to describe the object
<DL><DT><DD></DL><P>
<A NAME="getDescriptions">
<A NAME="DOC.2.30.22">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="Node.html#DOC.2.30.21">DescriptionList</A>&amp; getDescriptions() const </B></TT>
<DD>Get the description list of the const node
<DL><DT><DD></DL><P>
<A NAME="getDescriptions">
<A NAME="DOC.2.30.23">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Node.html#DOC.2.30.21">DescriptionList</A>&amp; getDescriptions()</B></TT>
<DD>Get the description list of the const node
<DL><DT><DD></DL><P>
<A NAME="getDescription">
<A NAME="DOC.2.30.24">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const std::string&amp; getDescription(int i) const </B></TT>
<DD>Get a single const description of the const node
<DL><DT><DD></DL><P>
<A NAME="getDescription">
<A NAME="DOC.2.30.25">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string&amp; getDescription(int i)</B></TT>
<DD>Get a single description of the node
<DL><DT><DD></DL><P>
<A NAME="getNumDescriptions">
<A NAME="DOC.2.30.26">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int getNumDescriptions() const </B></TT>
<DD>Get the number of descriptions of the node
<DL><DT><DD></DL><P>
<A NAME="addDescription">
<A NAME="DOC.2.30.27">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addDescription(const std::string&amp; desc)</B></TT>
<DD>Add a description string to the node
<DL><DT><DD></DL><P>
<A NAME="getBound">
<A NAME="DOC.2.30.28">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="BoundingSphere.html">BoundingSphere</A>&amp; getBound()</B></TT>
<DD>get the bounding sphere of node.
Using lazy evaluation computes the bounding sphere if it is 'dirty'.
<DL><DT><DD></DL><P>
<A NAME="dirtyBound">
<A NAME="DOC.2.30.29">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void dirtyBound()</B></TT>
<DD>Mark this node's bounding sphere dirty.
Forcing it to be computed on the next call to getBound().
<DL><DT><DD></DL><P>
<A NAME="~Node">
<A NAME="DOC.2.30.30">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~Node()</B></TT>
<DD>Node destructor. Note, is protected so that Nodes cannot
be deleted other than by being dereferenced and the reference
count being zero (see osg::Referenced), preventing the deletion
of nodes which are still in use. This also means that
Node's cannot be created on stack i.e Node node will not compile,
forcing all nodes to be created on the heap i.e Node* node
= new Node().
<DL><DT><DD></DL><P>
<A NAME="readLocalData">
<A NAME="DOC.2.30.31">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool readLocalData(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DD>
Template Method Pattern : read local data from osg file.
Note should be implemented in derived classes, which
call their parent class's readLocalData.

<DL><DT><DT><B>Returns:</B><DD>  true if the input iterator has been advanced, otherwise false.<BR><DD></DL><P>
<A NAME="writeLocalData">
<A NAME="DOC.2.30.32">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool writeLocalData(<!1><A HREF="Output.html">Output</A>&amp; fw)</B></TT>
<DD>
Template Method Pattern : read local data from osg file.
Note should be implemented in derivied classes, which
call their parent class's writeLocalData.

<DL><DT><DT><B>Returns:</B><DD>  true if data has been written out, otherwise false.<BR><DD></DL><P>
<A NAME="computeBound">
<A NAME="DOC.2.30.33">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool computeBound( void )</B></TT>
<DD>Compute the bounding sphere around Node's geometry or children.
This method is automatically called by getBound() when the bounding
sphere has been marked dirty via dirtyBound().
<DL><DT><DD></DL><P>
<A NAME="_bsphere">
<A NAME="DOC.2.30.35">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="BoundingSphere.html">BoundingSphere</A> _bsphere</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_bsphere_computed">
<A NAME="DOC.2.30.36">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _bsphere_computed</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_name">
<A NAME="DOC.2.30.37">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string _name</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_parents">
<A NAME="DOC.2.30.38">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Node.html#DOC.2.30.12">ParentList</A> _parents</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Group">
<A NAME="DOC.2.30.39">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>friend Group</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_userData">
<A NAME="DOC.2.30.40">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void* _userData</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_memoryAdapter">
<A NAME="DOC.2.30.41">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="MemoryAdapter.html">MemoryAdapter</A>&gt;  _memoryAdapter</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_nodeMask">
<A NAME="DOC.2.30.42">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Node.html#DOC.2.30.34">NodeMask</A> _nodeMask</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_descriptions">
<A NAME="DOC.2.30.43">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Node.html#DOC.2.30.21">DescriptionList</A> _descriptions</B></TT>
<DL><DT><DD></DL><P></DL>
<HR>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="LightSource.html">LightSource</A><BR>
<A HREF="Group.html">Group</A><BR>
<A HREF="Geode.html">Geode</A><BR>
</DL>

<DL><DT><DD></DL><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I><P><HR>
<BR>
This page was generated with the help of <A HREF="http://www.linuxsupportline.com/~doc++">DOC++</A>.
</BODY>
