<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::Group</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.10">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::Group</A></H2></H2><BLOCKQUOTE>General group node which maintains a list of children.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=395>
<param name=classes value="CReferenced,MReferenced.html,CObject,MObject.html,CNode,MNode.html,CGroup,MGroup.html,CTransform,MTransform.html,CSwitch,MSwitch.html,CSequence,MSequence.html,CProjection,MProjection.html,COccluderNode,MOccluderNode.html,CLightSource,MLightSource.html,CLOD,MLOD.html,CClipNode,MClipNode.html,CClearNode,MClearNode.html">
<param name=before value="M,M,M,M,M|_,MR_,MR_,MR_,MR_,MR_,MR_,MR_,Mr_">
<param name=after value="Md_SPSP,Md_SP,Md_,M,M,M,M,M,M,M,M,M,M">
<param name=indent value="0,1,2,3,3,3,3,3,3,3,3,3,3">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.87.1">Group</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.87.2">Group</A></B>(const <!1><A HREF="Group.html#DOC.2.87.2">Group</A>&amp;, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)
<DD><I>Copy constructor using CopyOp to manage deep vs shallow copy</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.87.3">META_Node</A></B>(<!1><A HREF="osg.html">osg</A>, <!1><A HREF="Group.html">Group</A>)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <!1><A HREF="Group.html">Group</A>* <B><A HREF="#DOC.2.87.4">asGroup</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const <!1><A HREF="Group.html">Group</A>* <B><A HREF="#DOC.2.87.5">asGroup</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.87.6">traverse</A></B>(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.87.7">addChild</A></B>( <!1><A HREF="Node.html">Node</A>* child )
<DD><I>Add Node to Group.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.87.8">insertChild</A></B>( unsigned int <!1><A HREF="TemplateIndexArray.html#DOC.2.10.15">index</A>, <!1><A HREF="Node.html">Node</A>* child )
<DD><I>Insert Node to Group at specific location.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.87.9">removeChild</A></B>( <!1><A HREF="Node.html">Node</A>* child )
<DD><I>Remove Node from Group.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.87.10">removeChild</A></B>(unsigned int pos, unsigned int numChildrenToRemove=1)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.87.11">replaceChild</A></B>( <!1><A HREF="Node.html">Node</A>* origChild, <!1><A HREF="Node.html">Node</A>* newChild )
<DD><I>Replace specified Node with another Node.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.87.12">getNumChildren</A></B>() const 
<DD><I>return the number of chilren nodes</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.87.13">setChild</A></B>( unsigned int i, <!1><A HREF="Node.html">Node</A>* node )
<DD><I>set child node at position i.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <!1><A HREF="Node.html">Node</A>* <B><A HREF="#DOC.2.87.14">getChild</A></B>( unsigned int i )
<DD><I>return child node at position i</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const <!1><A HREF="Node.html">Node</A>* <B><A HREF="#DOC.2.87.15">getChild</A></B>( unsigned int i ) const 
<DD><I>return child node at position i</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.87.16">containsNode</A></B>( const <!1><A HREF="Node.html">Node</A>* node ) const 
<DD><I>return true if node is contained within Group</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.87.17">getChildIndex</A></B>( const <!1><A HREF="Node.html">Node</A>* node ) const 
<DD><I>Get the index number of child, return a value between 0 and _childrensize()-1 if found, if not found then return _childrensize()</I>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="osg.html#DOC.2.86">NodeList</A> <B><A HREF="#DOC.2.87.20">_children</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.87.18">~Group</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.87.19">computeBound</A></B>() const 
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Node.html">Node</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>virtual   <!1><A HREF="Object.html">Object</A>* <B>cloneType</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   <!1><A HREF="Object.html">Object</A>* <B>clone</B>(const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   bool <B>isSameKindAs</B>(const <!1><A HREF="Object.html">Object</A>* obj) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   const char* <B>libraryName</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   const char* <B>className</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   <!1><A HREF="Transform.html">Transform</A>* <B>asTransform</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   const <!1><A HREF="Transform.html">Transform</A>* <B>asTransform</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   void <B>accept</B>(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   void <B>ascend</B>(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setName</B>( const std::string&amp; <!1><A HREF="Test.html#DOC.186.1.3">name</A> )
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setName</B>( const char* <!1><A HREF="Test.html#DOC.186.1.3">name</A> )
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const std::string&amp; <B>getName</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="Node.html#DOC.2.118.18">ParentList</A>&amp; <B>getParents</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Node.html#DOC.2.118.18">ParentList</A> <B>getParents</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Group.html">Group</A>* <B>getParent</B>(unsigned int i)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="Group.html">Group</A>* <B>getParent</B>(unsigned int i) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   unsigned int <B>getNumParents</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>setUpdateCallback</B>(<!1><A HREF="NodeCallback.html">NodeCallback</A>* nc)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="NodeCallback.html">NodeCallback</A>* <B>getUpdateCallback</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="NodeCallback.html">NodeCallback</A>* <B>getUpdateCallback</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   unsigned int <B>getNumChildrenRequiringUpdateTraversal</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>setCullCallback</B>(<!1><A HREF="NodeCallback.html">NodeCallback</A>* nc)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="NodeCallback.html">NodeCallback</A>* <B>getCullCallback</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="NodeCallback.html">NodeCallback</A>* <B>getCullCallback</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>setCullingActive</B>(bool active)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   bool <B>getCullingActive</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   unsigned int <B>getNumChildrenWithCullingDisabled</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   bool <B>isCullingActive</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   unsigned int <B>getNumChildrenWithOccluderNodes</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>bool <B>containsOccluderNodes</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setNodeMask</B>(<!1><A HREF="Node.html#DOC.2.118.37">NodeMask</A> nm)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Node.html#DOC.2.118.37">NodeMask</A> <B>getNodeMask</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="Node.html#DOC.2.118.40">DescriptionList</A>&amp; <B>getDescriptions</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Node.html#DOC.2.118.40">DescriptionList</A>&amp; <B>getDescriptions</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const std::string&amp; <B>getDescription</B>(unsigned int i) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   std::string&amp; <B>getDescription</B>(unsigned int i)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   unsigned int <B>getNumDescriptions</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>addDescription</B>(const std::string&amp; desc)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setStateSet</B>(<!1><A HREF="StateSet.html">osg::StateSet</A>* dstate)
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="StateSet.html">osg::StateSet</A>* <B>getOrCreateStateSet</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="StateSet.html">osg::StateSet</A>* <B>getStateSet</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="StateSet.html">osg::StateSet</A>* <B>getStateSet</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="BoundingSphere.html">BoundingSphere</A>&amp; <B>getBound</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>dirtyBound</B>()
</DL></P>

<P><DL>
<DT><H3>Public Members</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>typedef  std::vector&lt;<!1><A HREF="Group.html">Group</A>*&gt; <B>ParentList</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>typedef  unsigned int <B>NodeMask</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>typedef  std::vector&lt;std::string&gt; <B>DescriptionList</B>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>mutable <!1><A HREF="BoundingSphere.html">BoundingSphere</A> <B>_bsphere</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>mutable bool <B>_bsphere_computed</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>std::string <B>_name</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="Node.html#DOC.2.118.18">ParentList</A> <B>_parents</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="NodeCallback.html">NodeCallback</A>&gt;  <B>_updateCallback</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>unsigned int <B>_numChildrenRequiringUpdateTraversal</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="NodeCallback.html">NodeCallback</A>&gt;  <B>_cullCallback</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>bool <B>_cullingActive</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>unsigned int <B>_numChildrenWithCullingDisabled</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>unsigned int <B>_numChildrenWithOccluderNodes</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="Node.html#DOC.2.118.37">NodeMask</A> <B>_nodeMask</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="Node.html#DOC.2.118.40">DescriptionList</A> <B>_descriptions</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="StateSet.html">StateSet</A>&gt;  <B>_stateset</B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>void <B>addParent</B>(<!1><A HREF="Group.html">osg::Group</A>* node)
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>removeParent</B>(<!1><A HREF="Group.html">osg::Group</A>* node)
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>setNumChildrenRequiringUpdateTraversal</B>(unsigned int num)
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>setNumChildrenWithCullingDisabled</B>(unsigned int num)
<DT>
<IMG ALT="o" SRC=icon2.gif>void <B>setNumChildrenWithOccluderNodes</B>(unsigned int num)
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Object.html">Object</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setDataVariance</B>(<!1><A HREF="Object.html#DOC.2.135.8">DataVariance</A> dv)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Object.html#DOC.2.135.8">DataVariance</A> <B>getDataVariance</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setUserData</B>(<!1><A HREF="Referenced.html">Referenced</A>* obj)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Referenced.html">Referenced</A>* <B>getUserData</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="Referenced.html">Referenced</A>* <B>getUserData</B>() const 
</DL></P>

<P><DL>
<DT><H3>Public Members</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>enum  <B>DataVariance</B>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="Object.html#DOC.2.135.8">DataVariance</A> <B>_dataVariance</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="Referenced.html">Referenced</A>&gt;  <B>_userData</B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Referenced.html">Referenced</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Referenced.html">Referenced</A>&amp; <B>operator = </B>(<!1><A HREF="Referenced.html">Referenced</A>&amp;)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   void <B>setDeleteHandler</B>(<!1><A HREF="DeleteHandler.html">DeleteHandler</A>* handler)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   <!1><A HREF="DeleteHandler.html">DeleteHandler</A>* <B>getDeleteHandler</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>ref</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref_nodelete</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   int <B>referenceCount</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref</B>() const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>mutable int <B>_refCount</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>General group node which maintains a list of children.
Children are reference counted. This allows children to be shared
with memory management handled automatically via osg::Referenced.</BLOCKQUOTE>
<DL>

<A NAME="Group"></A>
<A NAME="DOC.2.87.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Group()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Group"></A>
<A NAME="DOC.2.87.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Group(const <!1><A HREF="Group.html#DOC.2.87.2">Group</A>&amp;, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)</B></TT>
<DD>Copy constructor using CopyOp to manage deep vs shallow copy
<DL><DT><DD></DL><P>
<A NAME="META_Node"></A>
<A NAME="DOC.2.87.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> META_Node(<!1><A HREF="osg.html">osg</A>, <!1><A HREF="Group.html">Group</A>)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="asGroup"></A>
<A NAME="DOC.2.87.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="Group.html">Group</A>* asGroup()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="asGroup"></A>
<A NAME="DOC.2.87.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const <!1><A HREF="Group.html">Group</A>* asGroup() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="traverse"></A>
<A NAME="DOC.2.87.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void traverse(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="addChild"></A>
<A NAME="DOC.2.87.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool addChild( <!1><A HREF="Node.html">Node</A>* child )</B></TT>
<DD>Add Node to Group.
If node is not NULL and is not contained in Group then increment its  
reference count, add it to the child list and dirty the bounding 
sphere to force it to recompute on next getBound() and return true for success.
Otherwise return false. Scene nodes can't be added as child nodes.
<DL><DT><DD></DL><P>
<A NAME="insertChild"></A>
<A NAME="DOC.2.87.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool insertChild( unsigned int <!1><A HREF="TemplateIndexArray.html#DOC.2.10.15">index</A>, <!1><A HREF="Node.html">Node</A>* child )</B></TT>
<DD>Insert Node to Group at specific location.
The new child node is inserted into the child list
before the node at the specified index.  No nodes
are removed from the group with this operation. 
<DL><DT><DD></DL><P>
<A NAME="removeChild"></A>
<A NAME="DOC.2.87.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool removeChild( <!1><A HREF="Node.html">Node</A>* child )</B></TT>
<DD>Remove Node from Group.
If Node is contained in Group then remove it from the child
list, decrement its reference count, and dirty the 
bounding sphere to force it to recompute on next getBound() and
return true for success.  If Node is not found then return false
and do not change the reference count of the Node.
<DL><DT><DD></DL><P>
<A NAME="removeChild"></A>
<A NAME="DOC.2.87.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool removeChild(unsigned int pos, unsigned int numChildrenToRemove=1)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="replaceChild"></A>
<A NAME="DOC.2.87.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool replaceChild( <!1><A HREF="Node.html">Node</A>* origChild, <!1><A HREF="Node.html">Node</A>* newChild )</B></TT>
<DD>Replace specified Node with another Node.
Equivalent to setChild(getChildIndex(orignChild),node), 
see docs for setChild for futher details on implementation.
<DL><DT><DD></DL><P>
<A NAME="getNumChildren"></A>
<A NAME="DOC.2.87.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getNumChildren() const </B></TT>
<DD>return the number of chilren nodes
<DL><DT><DD></DL><P>
<A NAME="setChild"></A>
<A NAME="DOC.2.87.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool setChild( unsigned int i, <!1><A HREF="Node.html">Node</A>* node )</B></TT>
<DD>set child node at position i.
return true if set correctly, false on failure (if node==NULL || i is out of range).
When set can be successful applied, the algorithm is : decrement the reference count origNode and increments the
reference count of newNode, and dirty the bounding sphere
to force it to recompute on next getBound() and returns true.
If origNode is not found then return false and do not 
add newNode.  If newNode is NULL then return false and do
not remove origNode. Also returns false if newChild is a Scene node.
<DL><DT><DD></DL><P>
<A NAME="getChild"></A>
<A NAME="DOC.2.87.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   <!1><A HREF="Node.html">Node</A>* getChild( unsigned int i )</B></TT>
<DD>return child node at position i
<DL><DT><DD></DL><P>
<A NAME="getChild"></A>
<A NAME="DOC.2.87.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const <!1><A HREF="Node.html">Node</A>* getChild( unsigned int i ) const </B></TT>
<DD>return child node at position i
<DL><DT><DD></DL><P>
<A NAME="containsNode"></A>
<A NAME="DOC.2.87.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool containsNode( const <!1><A HREF="Node.html">Node</A>* node ) const </B></TT>
<DD>return true if node is contained within Group
<DL><DT><DD></DL><P>
<A NAME="getChildIndex"></A>
<A NAME="DOC.2.87.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getChildIndex( const <!1><A HREF="Node.html">Node</A>* node ) const </B></TT>
<DD>Get the index number of child, return a value between
0 and _childrensize()-1 if found, if not found then
return _childrensize()
<DL><DT><DD></DL><P>
<A NAME="~Group"></A>
<A NAME="DOC.2.87.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~Group()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeBound"></A>
<A NAME="DOC.2.87.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool computeBound() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="_children"></A>
<A NAME="DOC.2.87.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="osg.html#DOC.2.86">NodeList</A> _children</B></TT>
<DL><DT><DD></DL><P></DL>
<HR>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="Transform.html">Transform</A><BR>
<A HREF="Switch.html">Switch</A><BR>
<A HREF="Sequence.html">Sequence</A><BR>
<A HREF="Projection.html">Projection</A><BR>
<A HREF="OccluderNode.html">OccluderNode</A><BR>
<A HREF="LightSource.html">LightSource</A><BR>
<A HREF="LOD.html">LOD</A><BR>
<A HREF="ClipNode.html">ClipNode</A><BR>
<A HREF="ClearNode.html">ClearNode</A><BR>
</DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
