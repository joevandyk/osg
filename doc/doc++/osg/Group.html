<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::Group</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.8">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::Group</A></H2></H2><BLOCKQUOTE>General group node which maintains a list of children.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=305>
<param name=classes value="MNode,M,CGroup,MGroup.html,CTransform,MTransform.html,CSwitch,MSwitch.html,CProjection,MProjection.html,COccluderNode,MOccluderNode.html,CLightSource,MLightSource.html,CLOD,MLOD.html,CClipNode,MClipNode.html,CClearNode,MClearNode.html">
<param name=before value="M,M,M|_,MR_,MR_,MR_,MR_,MR_,MR_,Mr_">
<param name=after value="Md_,M,M,M,M,M,M,M,M,M">
<param name=indent value="0,1,1,1,1,1,1,1,1,1">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.74.2">Group</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.74.3">Group</A></B>(const <!1><A HREF="Group.html#DOC.2.74.3">Group</A>&amp;, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)
<DD><I>Copy constructor using CopyOp to manage deep vs shallow copy</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.74.4">META_Node</A></B>(<!1><A HREF="osg.html">osg</A>, <!1><A HREF="Group.html">Group</A>)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <!1><A HREF="Group.html">Group</A>* <B><A HREF="#DOC.2.74.5">asGroup</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const <!1><A HREF="Group.html">Group</A>* <B><A HREF="#DOC.2.74.6">asGroup</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.74.7">traverse</A></B>(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.74.8">addChild</A></B>( Node* child )
<DD><I>Add Node to Group.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.74.9">removeChild</A></B>( Node* child )
<DD><I>Remove Node from Group.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.74.10">replaceChild</A></B>( Node* origChild, Node* newChild )
<DD><I>Replace specified Node with another Node.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.74.11">getNumChildren</A></B>() const 
<DD><I>return the number of chilren nodes</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   Node* <B><A HREF="#DOC.2.74.12">getChild</A></B>( unsigned int i )
<DD><I>return child node at position i</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const Node* <B><A HREF="#DOC.2.74.13">getChild</A></B>( unsigned int i ) const 
<DD><I>return child node at position i</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.74.14">containsNode</A></B>( const Node* node ) const 
<DD><I>return true if node is contained within Group</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   ChildList::iterator <B><A HREF="#DOC.2.74.15">findNode</A></B>( const Node* node )
<DD><I>return the iterator position for specified Node.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   ChildList::const_iterator <B><A HREF="#DOC.2.74.16">findNode</A></B>( const Node* node ) const 
<DD><I>return the const_iterator position for specified Node.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.74.17">findChildNo</A></B>( const Node* node ) const 
<DD><I>Find the index number of child, return a value between 0 and _childrensize()-1 if found, if not found then return _childrensize()</I>
</DL></P>

<P><DL>
<DT><H3>Public Members</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt;<!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;Node&gt; &gt; <B><A HREF="#DOC.2.74.1">ChildList</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Group.html#DOC.2.74.1">ChildList</A> <B><A HREF="#DOC.2.74.20">_children</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.74.18">~Group</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.74.19">computeBound</A></B>() const 
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>General group node which maintains a list of children.
Children are reference counted. This allows children to be shared
with memory management handled automatically via osg::Referenced.</BLOCKQUOTE>
<DL>

<A NAME="ChildList"></A>
<A NAME="DOC.2.74.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;<!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;Node&gt; &gt; ChildList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Group"></A>
<A NAME="DOC.2.74.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Group()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Group"></A>
<A NAME="DOC.2.74.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Group(const <!1><A HREF="Group.html#DOC.2.74.3">Group</A>&amp;, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)</B></TT>
<DD>Copy constructor using CopyOp to manage deep vs shallow copy
<DL><DT><DD></DL><P>
<A NAME="META_Node"></A>
<A NAME="DOC.2.74.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> META_Node(<!1><A HREF="osg.html">osg</A>, <!1><A HREF="Group.html">Group</A>)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="asGroup"></A>
<A NAME="DOC.2.74.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="Group.html">Group</A>* asGroup()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="asGroup"></A>
<A NAME="DOC.2.74.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const <!1><A HREF="Group.html">Group</A>* asGroup() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="traverse"></A>
<A NAME="DOC.2.74.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void traverse(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="addChild"></A>
<A NAME="DOC.2.74.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool addChild( Node* child )</B></TT>
<DD>Add Node to Group.
If node is not NULL and is not contained in Group then increment its  
reference count, add it to the child list and dirty the bounding 
sphere to force it to recompute on next getBound() and return true for success.
Otherwise return false. Scene nodes can't be added as child nodes.
<DL><DT><DD></DL><P>
<A NAME="removeChild"></A>
<A NAME="DOC.2.74.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool removeChild( Node* child )</B></TT>
<DD>Remove Node from Group.
If Node is contained in Group then remove it from the child
list, decrement its reference count, and dirty the 
bounding sphere to force it to recompute on next getBound() and
return true for success.  If Node is not found then return false
and do not change the reference count of the Node.
<DL><DT><DD></DL><P>
<A NAME="replaceChild"></A>
<A NAME="DOC.2.74.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool replaceChild( Node* origChild, Node* newChild )</B></TT>
<DD>Replace specified Node with another Node.
Decrement the reference count origNode and increments the
reference count of newNode, and dirty the bounding sphere
to force it to recompute on next getBound() and returns true.
If origNode is not found then return false and do not 
add newNode.  If newNode is NULL then return false and do
not remove origNode. Also returns false if newChild is a Scene node.
<DL><DT><DD></DL><P>
<A NAME="getNumChildren"></A>
<A NAME="DOC.2.74.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getNumChildren() const </B></TT>
<DD>return the number of chilren nodes
<DL><DT><DD></DL><P>
<A NAME="getChild"></A>
<A NAME="DOC.2.74.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   Node* getChild( unsigned int i )</B></TT>
<DD>return child node at position i
<DL><DT><DD></DL><P>
<A NAME="getChild"></A>
<A NAME="DOC.2.74.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const Node* getChild( unsigned int i ) const </B></TT>
<DD>return child node at position i
<DL><DT><DD></DL><P>
<A NAME="containsNode"></A>
<A NAME="DOC.2.74.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool containsNode( const Node* node ) const </B></TT>
<DD>return true if node is contained within Group
<DL><DT><DD></DL><P>
<A NAME="findNode"></A>
<A NAME="DOC.2.74.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   ChildList::iterator findNode( const Node* node )</B></TT>
<DD>return the iterator position for specified Node.
return _children.end() if node is not contained in Group.
<DL><DT><DD></DL><P>
<A NAME="findNode"></A>
<A NAME="DOC.2.74.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   ChildList::const_iterator findNode( const Node* node ) const </B></TT>
<DD>return the const_iterator position for specified Node.
return _children.end() if node is not contained in Group.
<DL><DT><DD></DL><P>
<A NAME="findChildNo"></A>
<A NAME="DOC.2.74.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int findChildNo( const Node* node ) const </B></TT>
<DD>Find the index number of child, return a value between
0 and _childrensize()-1 if found, if not found then
return _childrensize()
<DL><DT><DD></DL><P>
<A NAME="~Group"></A>
<A NAME="DOC.2.74.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~Group()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeBound"></A>
<A NAME="DOC.2.74.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool computeBound() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="_children"></A>
<A NAME="DOC.2.74.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Group.html#DOC.2.74.1">ChildList</A> _children</B></TT>
<DL><DT><DD></DL><P></DL>
<HR>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="Transform.html">Transform</A><BR>
<A HREF="Switch.html">Switch</A><BR>
<A HREF="Projection.html">Projection</A><BR>
<A HREF="OccluderNode.html">OccluderNode</A><BR>
<A HREF="LightSource.html">LightSource</A><BR>
<A HREF="LOD.html">LOD</A><BR>
<A HREF="ClipNode.html">ClipNode</A><BR>
<A HREF="ClearNode.html">ClearNode</A><BR>
</DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
