<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::State</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.8">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::State</A></H2></H2><BLOCKQUOTE>State class for managing a state stack.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CReferenced,MReferenced.html,CState,MState.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.121.1">State</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.121.2">~State</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.3">pushStateSet</A></B>(const <!1><A HREF="StateSet.html">StateSet</A>* dstate)
<DD><I>push stateset onto state stack</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.4">popStateSet</A></B>()
<DD><I>pop drawstate off state stack</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.5">captureCurrentState</A></B>(<!1><A HREF="StateSet.html">StateSet</A>&amp; stateset) const 
<DD><I>copy the modes and attributes which captures the current state</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.6">reset</A></B>()
<DD><I>reset the state object to an empty stack</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.7">applyProjectionMatrix</A></B>(const <!1><A HREF="Matrix.html">osg::Matrix</A>* matrix)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; <B><A HREF="#DOC.2.121.8">getProjectionMatrix</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.9">applyModelViewMatrix</A></B>(const <!1><A HREF="Matrix.html">osg::Matrix</A>* matrix)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; <B><A HREF="#DOC.2.121.10">getModelViewMatrix</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Polytope.html">Polytope</A> <B><A HREF="#DOC.2.121.11">getViewFrustum</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.12">apply</A></B>(const <!1><A HREF="StateSet.html">StateSet</A>* dstate)
<DD><I>Apply stateset</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.13">apply</A></B>()
<DD><I>Apply the state</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const bool <B><A HREF="#DOC.2.121.14">applyMode</A></B>(const StateAttribute::GLMode mode, const bool enabled)
<DD><I>Apply an OpenGL mode if required.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const bool <B><A HREF="#DOC.2.121.15">applyTextureMode</A></B>(unsigned int unit, const StateAttribute::GLMode mode, const bool enabled)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const bool <B><A HREF="#DOC.2.121.16">applyAttribute</A></B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)
<DD><I>Apply an attribute if required.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const bool <B><A HREF="#DOC.2.121.17">applyTextureAttribute</A></B>(unsigned int unit, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.18">haveAppliedMode</A></B>(const StateAttribute::GLMode mode, const StateAttribute::GLModeValue value)
<DD><I>Mode has been set externally, update state to reflect this setting</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.19">haveAppliedMode</A></B>(const StateAttribute::GLMode mode)
<DD><I>Mode has been set externally, therefore dirty the associated mode in osg::State so it is applied on next call to osg::State::apply()</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.20">haveAppliedAttribute</A></B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)
<DD><I>Attribute has been applied externally, update state to reflect this setting</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.21">haveAppliedAttribute</A></B>(const StateAttribute::Type type)
<DD><I>Attribute has been applied externally,  and therefore this attribute type has been dirtied  and will need to be re-appplied on next osg::Stateapply().</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const bool <B><A HREF="#DOC.2.121.22">getLastAppliedMode</A></B>(const StateAttribute::GLMode mode) const 
<DD><I>Get whether the current specified mode is enabled (true) or disabled (false)</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* <B><A HREF="#DOC.2.121.23">getLastAppliedAttribute</A></B>(const StateAttribute::Type type) const 
<DD><I>Get the current specified attribute, return NULL is one has not yet been applied</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.24">haveAppliedTextureMode</A></B>(unsigned int unit, const StateAttribute::GLMode mode, const StateAttribute::GLModeValue value)
<DD><I>texture Mode has been set externally, update state to reflect this setting</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.25">haveAppliedTextureMode</A></B>(unsigned int unit, const StateAttribute::GLMode mode)
<DD><I>texture Mode has been set externally, therefore dirty the associated mode in osg::State so it is applied on next call to osg::State::apply()</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.26">haveAppliedTextureAttribute</A></B>(unsigned int unit, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)
<DD><I>texture Attribute has been applied externally, update state to reflect this setting</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.27">haveAppliedTextureAttribute</A></B>(unsigned int unit, const StateAttribute::Type type)
<DD><I>texture Attribute has been applied externally,  and therefore this attribute type has been dirtied  and will need to be re-appplied on next osg::Stateapply().</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const bool <B><A HREF="#DOC.2.121.28">getLastAppliedTextureMode</A></B>(unsigned int unit, const StateAttribute::GLMode mode) const 
<DD><I>Get whether the current specified texture mode is enabled (true) or disabled (false)</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* <B><A HREF="#DOC.2.121.29">getLastAppliedTextureAttribute</A></B>(unsigned int unit, const StateAttribute::Type type) const 
<DD><I>Get the current specified texture attribute, return NULL is one has not yet been applied</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.30">setVertexPointer</A></B>( GLint <!1><A HREF="fast_back_stack.html#DOC.2.45.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_VERTEX_ARRAY);glVertexPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.31">disableVertexPointer</A></B>()
<DD><I>wrapper glDisableClientState(GL_VERTEX_ARRAY).</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.32">setNormalPointer</A></B>( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_NORMAL_ARRAY);glNormalPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.33">disableNormalPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_NORMAL_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.34">setColorPointer</A></B>( GLint <!1><A HREF="fast_back_stack.html#DOC.2.45.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_COLOR_ARRAY);glColorPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.35">disableColorPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_COLOR_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.36">setSecondaryColorPointer</A></B>( GLint <!1><A HREF="fast_back_stack.html#DOC.2.45.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_SECONDARY_COLOR_ARRAY);glSecondayColorPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.37">disableSecondaryColorPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_SECONDARY_COLOR_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.38">setIndexPointer</A></B>( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_INDEX_ARRAY);glIndexPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.39">disableIndexPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_INDEX_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.121.40">setFogCoordPointer</A></B>( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_FOG_COORDINATE_ARRAY);glFogCoordPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.41">disableFogCoordPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_FOG_COORDINATE_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.42">setTexCoordPointer</A></B>( unsigned int unit, GLint <!1><A HREF="fast_back_stack.html#DOC.2.45.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_TEXTURE_COORD_ARRAY);glTexCoordPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.43">disableTexCoordPointer</A></B>( unsigned int unit )
<DD><I>wrapper around glDisableClientState(GL_TEXTURE_COORD_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.44">disableTexCoordPointersAboveAndIncluding</A></B>( unsigned int unit )
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.121.45">setClientActiveTextureUnit</A></B>( unsigned int unit )
<DD><I>set the current tex coord array texture unit, return true if selected, false if selection failed such as when multitexturing is not supported.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.121.46">setActiveTextureUnit</A></B>( unsigned int unit )
<DD><I>set the current texture unit, return true if selected, false if selection failed such as when multitexturing is not supported.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.47">setContextID</A></B>(unsigned int contextID)
<DD><I>Set the current OpenGL context uniqueID.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const unsigned int <B><A HREF="#DOC.2.121.48">getContextID</A></B>() const 
<DD><I>Get the current OpenGL context unique ID</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.49">setFrameStamp</A></B>(<!1><A HREF="FrameStamp.html">FrameStamp</A>* fs)
<DD><I>Set the frame stamp for the current frame</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const <!1><A HREF="FrameStamp.html">FrameStamp</A>* <B><A HREF="#DOC.2.121.50">getFrameStamp</A></B>() const 
<DD><I>Set the frame stamp for the current frame</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.51">setDisplaySettings</A></B>(<!1><A HREF="DisplaySettings.html">DisplaySettings</A>* vs)
<DD><I>Set the DisplaySettings.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const <!1><A HREF="DisplaySettings.html">DisplaySettings</A>* <B><A HREF="#DOC.2.121.52">getDisplaySettings</A></B>() const 
<DD><I>Get the DisplaySettings </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.87">pushModeList</A></B>(ModeMap&amp; modeMap, const StateSet::ModeList&amp; modeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.88">pushAttributeList</A></B>(AttributeMap&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.89">popModeList</A></B>(ModeMap&amp; modeMap, const StateSet::ModeList&amp; modeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.90">popAttributeList</A></B>(AttributeMap&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.91">applyModeList</A></B>(ModeMap&amp; modeMap, const StateSet::ModeList&amp; modeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.92">applyAttributeList</A></B>(AttributeMap&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.93">applyModeMap</A></B>(ModeMap&amp; modeMap)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.121.94">applyAttributeMap</A></B>(AttributeMap&amp; attributeMap)
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Referenced.html">Referenced</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Referenced.html">Referenced</A>&amp; <B>operator = </B>(<!1><A HREF="Referenced.html">Referenced</A>&amp;)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>ref</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref_nodelete</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const int <B>referenceCount</B>() const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>mutable int <B>_refCount</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>State class for managing a state stack.
Lazy state updating is used to minimize state changes.</BLOCKQUOTE>
<DL>

<A NAME="State"></A>
<A NAME="DOC.2.121.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> State()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="~State"></A>
<A NAME="DOC.2.121.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~State()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="pushStateSet"></A>
<A NAME="DOC.2.121.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void pushStateSet(const <!1><A HREF="StateSet.html">StateSet</A>* dstate)</B></TT>
<DD>push stateset onto state stack
<DL><DT><DD></DL><P>
<A NAME="popStateSet"></A>
<A NAME="DOC.2.121.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void popStateSet()</B></TT>
<DD>pop drawstate off state stack
<DL><DT><DD></DL><P>
<A NAME="captureCurrentState"></A>
<A NAME="DOC.2.121.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void captureCurrentState(<!1><A HREF="StateSet.html">StateSet</A>&amp; stateset) const </B></TT>
<DD>copy the modes and attributes which captures the current state
<DL><DT><DD></DL><P>
<A NAME="reset"></A>
<A NAME="DOC.2.121.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void reset()</B></TT>
<DD>reset the state object to an empty stack
<DL><DT><DD></DL><P>
<A NAME="applyProjectionMatrix"></A>
<A NAME="DOC.2.121.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyProjectionMatrix(const <!1><A HREF="Matrix.html">osg::Matrix</A>* matrix)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getProjectionMatrix"></A>
<A NAME="DOC.2.121.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; getProjectionMatrix() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyModelViewMatrix"></A>
<A NAME="DOC.2.121.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyModelViewMatrix(const <!1><A HREF="Matrix.html">osg::Matrix</A>* matrix)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getModelViewMatrix"></A>
<A NAME="DOC.2.121.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; getModelViewMatrix() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getViewFrustum"></A>
<A NAME="DOC.2.121.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Polytope.html">Polytope</A> getViewFrustum() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="apply"></A>
<A NAME="DOC.2.121.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void apply(const <!1><A HREF="StateSet.html">StateSet</A>* dstate)</B></TT>
<DD>Apply stateset
<DL><DT><DD></DL><P>
<A NAME="apply"></A>
<A NAME="DOC.2.121.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void apply()</B></TT>
<DD>Apply the state
<DL><DT><DD></DL><P>
<A NAME="applyMode"></A>
<A NAME="DOC.2.121.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const bool applyMode(const StateAttribute::GLMode mode, const bool enabled)</B></TT>
<DD>Apply an OpenGL mode if required. 
<DL><DT><DD></DL><P>
<A NAME="applyTextureMode"></A>
<A NAME="DOC.2.121.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const bool applyTextureMode(unsigned int unit, const StateAttribute::GLMode mode, const bool enabled)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyAttribute"></A>
<A NAME="DOC.2.121.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const bool applyAttribute(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)</B></TT>
<DD>Apply an attribute if required. 
<DL><DT><DD></DL><P>
<A NAME="applyTextureAttribute"></A>
<A NAME="DOC.2.121.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const bool applyTextureAttribute(unsigned int unit, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="haveAppliedMode"></A>
<A NAME="DOC.2.121.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedMode(const StateAttribute::GLMode mode, const StateAttribute::GLModeValue value)</B></TT>
<DD>Mode has been set externally, update state to reflect this setting
<DL><DT><DD></DL><P>
<A NAME="haveAppliedMode"></A>
<A NAME="DOC.2.121.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedMode(const StateAttribute::GLMode mode)</B></TT>
<DD>Mode has been set externally, therefore dirty the associated mode in osg::State
so it is applied on next call to osg::State::apply()
<DL><DT><DD></DL><P>
<A NAME="haveAppliedAttribute"></A>
<A NAME="DOC.2.121.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedAttribute(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)</B></TT>
<DD>Attribute has been applied externally, update state to reflect this setting
<DL><DT><DD></DL><P>
<A NAME="haveAppliedAttribute"></A>
<A NAME="DOC.2.121.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedAttribute(const StateAttribute::Type type)</B></TT>
<DD>Attribute has been applied externally, 
and therefore this attribute type has been dirtied 
and will need to be re-appplied on next osg::Stateapply().
note, if you have an osg::StateAttribute which you have applied externally
then use the have_applied(attribute) method as this will the osg::State to
track the current state more accuratly and enable lazy state updating such
that only changed state will be applied.
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedMode"></A>
<A NAME="DOC.2.121.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const bool getLastAppliedMode(const StateAttribute::GLMode mode) const </B></TT>
<DD>Get whether the current specified mode is enabled (true) or disabled (false)
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedAttribute"></A>
<A NAME="DOC.2.121.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* getLastAppliedAttribute(const StateAttribute::Type type) const </B></TT>
<DD>Get the current specified attribute, return NULL is one has not yet been applied
<DL><DT><DD></DL><P>
<A NAME="haveAppliedTextureMode"></A>
<A NAME="DOC.2.121.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedTextureMode(unsigned int unit, const StateAttribute::GLMode mode, const StateAttribute::GLModeValue value)</B></TT>
<DD>texture Mode has been set externally, update state to reflect this setting
<DL><DT><DD></DL><P>
<A NAME="haveAppliedTextureMode"></A>
<A NAME="DOC.2.121.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedTextureMode(unsigned int unit, const StateAttribute::GLMode mode)</B></TT>
<DD>texture Mode has been set externally, therefore dirty the associated mode in osg::State
so it is applied on next call to osg::State::apply()
<DL><DT><DD></DL><P>
<A NAME="haveAppliedTextureAttribute"></A>
<A NAME="DOC.2.121.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedTextureAttribute(unsigned int unit, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)</B></TT>
<DD>texture Attribute has been applied externally, update state to reflect this setting
<DL><DT><DD></DL><P>
<A NAME="haveAppliedTextureAttribute"></A>
<A NAME="DOC.2.121.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedTextureAttribute(unsigned int unit, const StateAttribute::Type type)</B></TT>
<DD>texture Attribute has been applied externally, 
and therefore this attribute type has been dirtied 
and will need to be re-appplied on next osg::Stateapply().
note, if you have an osg::StateAttribute which you have applied externally
then use the have_applied(attribute) method as this will the osg::State to
track the current state more accuratly and enable lazy state updating such
that only changed state will be applied.
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedTextureMode"></A>
<A NAME="DOC.2.121.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const bool getLastAppliedTextureMode(unsigned int unit, const StateAttribute::GLMode mode) const </B></TT>
<DD>Get whether the current specified texture mode is enabled (true) or disabled (false)
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedTextureAttribute"></A>
<A NAME="DOC.2.121.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* getLastAppliedTextureAttribute(unsigned int unit, const StateAttribute::Type type) const </B></TT>
<DD>Get the current specified texture attribute, return NULL is one has not yet been applied
<DL><DT><DD></DL><P>
<A NAME="setVertexPointer"></A>
<A NAME="DOC.2.121.30"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setVertexPointer( GLint <!1><A HREF="fast_back_stack.html#DOC.2.45.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_VERTEX_ARRAY);glVertexPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableVertexPointer"></A>
<A NAME="DOC.2.121.31"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableVertexPointer()</B></TT>
<DD>wrapper glDisableClientState(GL_VERTEX_ARRAY).
note, only updates values that change.
<DL><DT><DD></DL><P>
<A NAME="setNormalPointer"></A>
<A NAME="DOC.2.121.32"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setNormalPointer( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_NORMAL_ARRAY);glNormalPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableNormalPointer"></A>
<A NAME="DOC.2.121.33"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableNormalPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_NORMAL_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="setColorPointer"></A>
<A NAME="DOC.2.121.34"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setColorPointer( GLint <!1><A HREF="fast_back_stack.html#DOC.2.45.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_COLOR_ARRAY);glColorPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableColorPointer"></A>
<A NAME="DOC.2.121.35"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableColorPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_COLOR_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="setSecondaryColorPointer"></A>
<A NAME="DOC.2.121.36"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setSecondaryColorPointer( GLint <!1><A HREF="fast_back_stack.html#DOC.2.45.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_SECONDARY_COLOR_ARRAY);glSecondayColorPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableSecondaryColorPointer"></A>
<A NAME="DOC.2.121.37"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableSecondaryColorPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_SECONDARY_COLOR_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="setIndexPointer"></A>
<A NAME="DOC.2.121.38"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setIndexPointer( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_INDEX_ARRAY);glIndexPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableIndexPointer"></A>
<A NAME="DOC.2.121.39"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableIndexPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_INDEX_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="setFogCoordPointer"></A>
<A NAME="DOC.2.121.40"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setFogCoordPointer( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_FOG_COORDINATE_ARRAY);glFogCoordPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableFogCoordPointer"></A>
<A NAME="DOC.2.121.41"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableFogCoordPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_FOG_COORDINATE_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="setTexCoordPointer"></A>
<A NAME="DOC.2.121.42"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setTexCoordPointer( unsigned int unit, GLint <!1><A HREF="fast_back_stack.html#DOC.2.45.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.150.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_TEXTURE_COORD_ARRAY);glTexCoordPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableTexCoordPointer"></A>
<A NAME="DOC.2.121.43"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableTexCoordPointer( unsigned int unit )</B></TT>
<DD>wrapper around glDisableClientState(GL_TEXTURE_COORD_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableTexCoordPointersAboveAndIncluding"></A>
<A NAME="DOC.2.121.44"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableTexCoordPointersAboveAndIncluding( unsigned int unit )</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setClientActiveTextureUnit"></A>
<A NAME="DOC.2.121.45"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool setClientActiveTextureUnit( unsigned int unit )</B></TT>
<DD>set the current tex coord array texture unit, return true if selected, false if selection failed such as when multitexturing is not supported.
note, only updates values that change.
<DL><DT><DD></DL><P>
<A NAME="setActiveTextureUnit"></A>
<A NAME="DOC.2.121.46"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool setActiveTextureUnit( unsigned int unit )</B></TT>
<DD>set the current texture unit, return true if selected, false if selection failed such as when multitexturing is not supported.
note, only updates values that change.
<DL><DT><DD></DL><P>
<A NAME="setContextID"></A>
<A NAME="DOC.2.121.47"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setContextID(unsigned int contextID)</B></TT>
<DD>Set the current OpenGL context uniqueID.
Note, it is the application developers responsibility to
set up unique ID for each OpenGL context.  This value is
then used by osg::StateAttribure's and osg::Drawable's to
help manage OpenGL display list and texture binds appropriate
for each context.
<DL><DT><DD></DL><P>
<A NAME="getContextID"></A>
<A NAME="DOC.2.121.48"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const unsigned int getContextID() const </B></TT>
<DD>Get the current OpenGL context unique ID
<DL><DT><DD></DL><P>
<A NAME="setFrameStamp"></A>
<A NAME="DOC.2.121.49"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setFrameStamp(<!1><A HREF="FrameStamp.html">FrameStamp</A>* fs)</B></TT>
<DD>Set the frame stamp for the current frame
<DL><DT><DD></DL><P>
<A NAME="getFrameStamp"></A>
<A NAME="DOC.2.121.50"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const <!1><A HREF="FrameStamp.html">FrameStamp</A>* getFrameStamp() const </B></TT>
<DD>Set the frame stamp for the current frame
<DL><DT><DD></DL><P>
<A NAME="setDisplaySettings"></A>
<A NAME="DOC.2.121.51"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setDisplaySettings(<!1><A HREF="DisplaySettings.html">DisplaySettings</A>* vs)</B></TT>
<DD>Set the DisplaySettings. Note, nothing is applied, the visual settings are just used
used in the State object to pass the current visual settings to Drawables
during rendering. 
<DL><DT><DD></DL><P>
<A NAME="getDisplaySettings"></A>
<A NAME="DOC.2.121.52"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const <!1><A HREF="DisplaySettings.html">DisplaySettings</A>* getDisplaySettings() const </B></TT>
<DD>Get the DisplaySettings 
<DL><DT><DD></DL><P><DL>

<A NAME="ModeStack"></A>
<A NAME="DOC.2.121.59.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> ModeStack()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="changed"></A>
<A NAME="DOC.2.121.59.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool changed</B></TT>
<DL><DT><DD></DL><P>
<A NAME="last_applied_value"></A>
<A NAME="DOC.2.121.59.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool last_applied_value</B></TT>
<DL><DT><DD></DL><P>
<A NAME="global_default_value"></A>
<A NAME="DOC.2.121.59.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool global_default_value</B></TT>
<DL><DT><DD></DL><P>
<A NAME="valueVec"></A>
<A NAME="DOC.2.121.59.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ValueVec valueVec</B></TT>
<DL><DT><DD></DL><P></DL>
<DL>

<A NAME="AttributeStack"></A>
<A NAME="DOC.2.121.60.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> AttributeStack()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="changed"></A>
<A NAME="DOC.2.121.60.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool changed</B></TT>
<DD>apply an attribute if required, passing in attribute and appropriate attribute stack 
<DL><DT><DD></DL><P>
<A NAME="last_applied_attribute"></A>
<A NAME="DOC.2.121.60.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* last_applied_attribute</B></TT>
<DL><DT><DD></DL><P>
<A NAME="global_default_attribute"></A>
<A NAME="DOC.2.121.60.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="StateAttribute.html">StateAttribute</A>&gt;  global_default_attribute</B></TT>
<DL><DT><DD></DL><P>
<A NAME="attributeVec"></A>
<A NAME="DOC.2.121.60.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>AttributeVec attributeVec</B></TT>
<DL><DT><DD></DL><P></DL>
<DL>

<A NAME="EnabledArrayPair"></A>
<A NAME="DOC.2.121.69.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> EnabledArrayPair()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="EnabledArrayPair"></A>
<A NAME="DOC.2.121.69.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> EnabledArrayPair(const <!1><A HREF="State.html#DOC.2.121.69.2">EnabledArrayPair</A>&amp; eap)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="operator = "></A>
<A NAME="DOC.2.121.69.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.121.69">EnabledArrayPair</A>&amp; operator = (const <!1><A HREF="State.html#DOC.2.121.69">EnabledArrayPair</A>&amp; eap)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_enabled"></A>
<A NAME="DOC.2.121.69.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _enabled</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_pointer"></A>
<A NAME="DOC.2.121.69.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const GLvoid* _pointer</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="pushModeList"></A>
<A NAME="DOC.2.121.87"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void pushModeList(ModeMap&amp; modeMap, const StateSet::ModeList&amp; modeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="pushAttributeList"></A>
<A NAME="DOC.2.121.88"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void pushAttributeList(AttributeMap&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="popModeList"></A>
<A NAME="DOC.2.121.89"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void popModeList(ModeMap&amp; modeMap, const StateSet::ModeList&amp; modeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="popAttributeList"></A>
<A NAME="DOC.2.121.90"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void popAttributeList(AttributeMap&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyModeList"></A>
<A NAME="DOC.2.121.91"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyModeList(ModeMap&amp; modeMap, const StateSet::ModeList&amp; modeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyAttributeList"></A>
<A NAME="DOC.2.121.92"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyAttributeList(AttributeMap&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyModeMap"></A>
<A NAME="DOC.2.121.93"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyModeMap(ModeMap&amp; modeMap)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyAttributeMap"></A>
<A NAME="DOC.2.121.94"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyAttributeMap(AttributeMap&amp; attributeMap)</B></TT>
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
