<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::State</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.10">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::State</A></H2></H2><BLOCKQUOTE>State class for managing a state stack.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CReferenced,MReferenced.html,CState,MState.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.164.1">State</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.2">pushStateSet</A></B>(const <!1><A HREF="StateSet.html">StateSet</A>* dstate)
<DD><I>push stateset onto state stack</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.3">popStateSet</A></B>()
<DD><I>pop drawstate off state stack</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.4">captureCurrentState</A></B>(<!1><A HREF="StateSet.html">StateSet</A>&amp; stateset) const 
<DD><I>copy the modes and attributes which captures the current state</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.5">reset</A></B>()
<DD><I>reset the state object to an empty stack</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.6">applyProjectionMatrix</A></B>(const <!1><A HREF="RefMatrix.html">osg::RefMatrix</A>* matrix)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; <B><A HREF="#DOC.2.164.7">getProjectionMatrix</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.8">applyModelViewMatrix</A></B>(const <!1><A HREF="RefMatrix.html">osg::RefMatrix</A>* matrix)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; <B><A HREF="#DOC.2.164.9">getModelViewMatrix</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Polytope.html">Polytope</A> <B><A HREF="#DOC.2.164.10">getViewFrustum</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.11">apply</A></B>(const <!1><A HREF="StateSet.html">StateSet</A>* dstate)
<DD><I>Apply stateset</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.12">apply</A></B>()
<DD><I>Apply the state</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.164.13">applyMode</A></B>(StateAttribute::GLMode mode, bool enabled)
<DD><I>Apply an OpenGL mode if required.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.164.14">applyTextureMode</A></B>(unsigned int unit, StateAttribute::GLMode mode, bool enabled)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.164.15">applyAttribute</A></B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)
<DD><I>Apply an attribute if required.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.164.16">applyTextureAttribute</A></B>(unsigned int unit, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.17">haveAppliedMode</A></B>(StateAttribute::GLMode mode, StateAttribute::GLModeValue value)
<DD><I>Mode has been set externally, update state to reflect this setting</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.18">haveAppliedMode</A></B>(StateAttribute::GLMode mode)
<DD><I>Mode has been set externally, therefore dirty the associated mode in osg::State so it is applied on next call to osg::State::apply()</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.19">haveAppliedAttribute</A></B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)
<DD><I>Attribute has been applied externally, update state to reflect this setting</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.20">haveAppliedAttribute</A></B>(StateAttribute::Type type)
<DD><I>Attribute has been applied externally,  and therefore this attribute type has been dirtied  and will need to be re-appplied on next osg::Stateapply().</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.21">getLastAppliedMode</A></B>(StateAttribute::GLMode mode) const 
<DD><I>Get whether the current specified mode is enabled (true) or disabled (false)</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* <B><A HREF="#DOC.2.164.22">getLastAppliedAttribute</A></B>(StateAttribute::Type type) const 
<DD><I>Get the current specified attribute, return NULL is one has not yet been applied</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.23">haveAppliedTextureMode</A></B>(unsigned int unit, StateAttribute::GLMode mode, StateAttribute::GLModeValue value)
<DD><I>texture Mode has been set externally, update state to reflect this setting</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.24">haveAppliedTextureMode</A></B>(unsigned int unit, StateAttribute::GLMode mode)
<DD><I>texture Mode has been set externally, therefore dirty the associated mode in osg::State so it is applied on next call to osg::State::apply()</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.25">haveAppliedTextureAttribute</A></B>(unsigned int unit, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)
<DD><I>texture Attribute has been applied externally, update state to reflect this setting</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.26">haveAppliedTextureAttribute</A></B>(unsigned int unit, StateAttribute::Type type)
<DD><I>texture Attribute has been applied externally,  and therefore this attribute type has been dirtied  and will need to be re-appplied on next osg::Stateapply().</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.27">getLastAppliedTextureMode</A></B>(unsigned int unit, StateAttribute::GLMode mode) const 
<DD><I>Get whether the current specified texture mode is enabled (true) or disabled (false)</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* <B><A HREF="#DOC.2.164.28">getLastAppliedTextureAttribute</A></B>(unsigned int unit, StateAttribute::Type type) const 
<DD><I>Get the current specified texture attribute, return NULL is one has not yet been applied</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.29">dirtyAllModes</A></B>()
<DD><I>Dirty the modes previously applied in osg::State</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.30">dirtyAllAttributes</A></B>()
<DD><I>Dirty the modes attributes previously applied in osg::State</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.31">disableAllVertexArrays</A></B>()
<DD><I>disable the vertex, normal, color, tex coords, secenday color, fog coord and index arrays</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.32">dirtyAllVertexArrays</A></B>()
<DD><I>dirty the vertex, normal, color, tex coords, secenday color, fog coord and index arrays</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.33">setInterleavedArrays</A></B>( GLenum format, GLsizei stride, void* pointer)
<DD><I>Wrapper around glInterleavedArrays().</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.34">setVertexPointer</A></B>( GLint <!1><A HREF="fast_back_stack.html#DOC.2.209.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_VERTEX_ARRAY);glVertexPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.35">disableVertexPointer</A></B>()
<DD><I>wrapper glDisableClientState(GL_VERTEX_ARRAY).</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.36">dirtyVertexPointer</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.37">setNormalPointer</A></B>( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_NORMAL_ARRAY);glNormalPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.38">disableNormalPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_NORMAL_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.39">dirtyNormalPointer</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.40">setColorPointer</A></B>( GLint <!1><A HREF="fast_back_stack.html#DOC.2.209.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_COLOR_ARRAY);glColorPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.41">disableColorPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_COLOR_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.42">dirtyColorPointer</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.164.43">isSecondaryColorSupported</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.44">setSecondaryColorPointer</A></B>( GLint <!1><A HREF="fast_back_stack.html#DOC.2.209.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_SECONDARY_COLOR_ARRAY);glSecondayColorPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.45">disableSecondaryColorPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_SECONDARY_COLOR_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.46">dirtySecondaryColorPointer</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.47">setIndexPointer</A></B>( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_INDEX_ARRAY);glIndexPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.48">disableIndexPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_INDEX_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.49">dirtyIndexPointer</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.164.50">isFogCoordSupported</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.51">setFogCoordPointer</A></B>( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_FOG_COORDINATE_ARRAY);glFogCoordPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.52">disableFogCoordPointer</A></B>()
<DD><I>wrapper around glDisableClientState(GL_FOG_COORDINATE_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.53">dirtyFogCoordPointer</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.54">setTexCoordPointer</A></B>( unsigned int unit, GLint <!1><A HREF="fast_back_stack.html#DOC.2.209.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )
<DD><I>wrapper around glEnableClientState(GL_TEXTURE_COORD_ARRAY);glTexCoordPointer(); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.55">disableTexCoordPointer</A></B>( unsigned int unit )
<DD><I>wrapper around glDisableClientState(GL_TEXTURE_COORD_ARRAY); note, only updates values that change</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.56">dirtyTexCoordPointer</A></B>( unsigned int unit )
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.57">disableTexCoordPointersAboveAndIncluding</A></B>( unsigned int unit )
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.58">dirtyTexCoordPointersAboveAndIncluding</A></B>( unsigned int unit )
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.59">setClientActiveTextureUnit</A></B>( unsigned int unit )
<DD><I>set the current tex coord array texture unit, return true if selected, false if selection failed such as when multitexturing is not supported.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.60">setActiveTextureUnit</A></B>( unsigned int unit )
<DD><I>set the current texture unit, return true if selected, false if selection failed such as when multitexturing is not supported.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.61">setContextID</A></B>(unsigned int contextID)
<DD><I>Set the current OpenGL context uniqueID.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.164.62">getContextID</A></B>() const 
<DD><I>Get the current OpenGL context unique ID</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.63">setFrameStamp</A></B>(<!1><A HREF="FrameStamp.html">FrameStamp</A>* fs)
<DD><I>Set the frame stamp for the current frame</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const <!1><A HREF="FrameStamp.html">FrameStamp</A>* <B><A HREF="#DOC.2.164.64">getFrameStamp</A></B>() const 
<DD><I>Set the frame stamp for the current frame</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.65">setDisplaySettings</A></B>(<!1><A HREF="DisplaySettings.html">DisplaySettings</A>* vs)
<DD><I>Set the DisplaySettings.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const <!1><A HREF="DisplaySettings.html">DisplaySettings</A>* <B><A HREF="#DOC.2.164.66">getDisplaySettings</A></B>() const 
<DD><I>Get the DisplaySettings </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.70">setReportGLErrors</A></B>(bool flag)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.71">getReportGLErrors</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.72">checkGLErrors</A></B>(const char* str) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.73">checkGLErrors</A></B>(StateAttribute::GLMode mode) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.74">checkGLErrors</A></B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.124">pushModeList</A></B>(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, const StateSet::ModeList&amp; modeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.125">pushAttributeList</A></B>(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.126">popModeList</A></B>(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, const StateSet::ModeList&amp; modeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.127">popAttributeList</A></B>(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.128">applyModeList</A></B>(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, const StateSet::ModeList&amp; modeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.129">applyAttributeList</A></B>(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.130">applyModeMap</A></B>(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.164.131">applyAttributeMap</A></B>(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap)
</DL></P>

<P><DL>
<DT><H3>Public Members</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::pair&lt;const <!1><A HREF="StateAttribute.html">StateAttribute</A>*,StateAttribute::OverrideValue&gt; <B><A HREF="#DOC.2.164.67">AttributePair</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt;<!1><A HREF="State.html#DOC.2.164.67">AttributePair</A>&gt; <B><A HREF="#DOC.2.164.68">AttributeVec</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt;StateAttribute::GLModeValue&gt; <B><A HREF="#DOC.2.164.69">ValueVec</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.2.164.76">_contextID</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="FrameStamp.html">FrameStamp</A>&gt;  <B><A HREF="#DOC.2.164.77">_frameStamp</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="RefMatrix.html">RefMatrix</A>&gt;  <B><A HREF="#DOC.2.164.78">_identity</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="RefMatrix.html">RefMatrix</A>&gt;  <B><A HREF="#DOC.2.164.79">_projection</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="RefMatrix.html">RefMatrix</A>&gt;  <B><A HREF="#DOC.2.164.80">_modelView</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="DisplaySettings.html">DisplaySettings</A>&gt;  <B><A HREF="#DOC.2.164.81">_displaySettings</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.82">_reportGLErrors</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.88">ModeMap</A> <B><A HREF="#DOC.2.164.94">_modeMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A> <B><A HREF="#DOC.2.164.95">_attributeMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.89">TextureModeMapList</A> <B><A HREF="#DOC.2.164.96">_textureModeMapList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.91">TextureAttributeMapList</A> <B><A HREF="#DOC.2.164.97">_textureAttributeMapList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.92">StateSetStack</A> <B><A HREF="#DOC.2.164.98">_drawStateStack</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> <B><A HREF="#DOC.2.164.101">_vertexArray</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> <B><A HREF="#DOC.2.164.102">_normalArray</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> <B><A HREF="#DOC.2.164.103">_colorArray</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> <B><A HREF="#DOC.2.164.104">_secondaryColorArray</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> <B><A HREF="#DOC.2.164.105">_indexArray</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> <B><A HREF="#DOC.2.164.106">_fogArray</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="State.html#DOC.2.164.100">EnabledTexCoordArrayList</A> <B><A HREF="#DOC.2.164.107">_texCoordArrayList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.2.164.108">_currentActiveTextureUnit</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.2.164.109">_currentClientActiveTextureUnit</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>mutable bool <B><A HREF="#DOC.2.164.118">_isSecondColorSupportResolved</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>mutable bool <B><A HREF="#DOC.2.164.119">_isSecondColorSupported</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>mutable bool <B><A HREF="#DOC.2.164.121">_isFogCoordSupportResolved</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>mutable bool <B><A HREF="#DOC.2.164.122">_isFogCoordSupported</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.164.75">~State</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.164.85">applyMode</A></B>(StateAttribute::GLMode mode, bool enabled, <!1><A HREF="State.html#DOC.2.164.83">ModeStack</A>&amp; ms)
<DD><I>apply an OpenGL mode if required, passing in mode, enable flag and appropriate mode stack </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.164.86">applyAttribute</A></B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute, <!1><A HREF="State.html#DOC.2.164.84">AttributeStack</A>&amp; as)
<DD><I>apply an attribute if required, passing in attribute and appropriate attribute stack </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.164.87">applyGlobalDefaultAttribute</A></B>(<!1><A HREF="State.html#DOC.2.164.84">AttributeStack</A>&amp; as)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; <B><A HREF="#DOC.2.164.110">getOrCreateTextureModeMap</A></B>(unsigned int unit)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; <B><A HREF="#DOC.2.164.111">getOrCreateTextureAttributeMap</A></B>(unsigned int unit)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.112">haveAppliedMode</A></B>(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, StateAttribute::GLMode mode, StateAttribute::GLModeValue value)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.113">haveAppliedMode</A></B>(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, StateAttribute::GLMode mode)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.114">haveAppliedAttribute</A></B>(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.164.115">haveAppliedAttribute</A></B>(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, StateAttribute::Type type)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.116">getLastAppliedMode</A></B>(const <!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, StateAttribute::GLMode mode) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* <B><A HREF="#DOC.2.164.117">getLastAppliedAttribute</A></B>(const <!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, StateAttribute::Type type) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.120">computeSecondaryColorSupported</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.164.123">computeFogCoordSupported</A></B>() const 
</DL></P>

<P><DL>
<DT><H3>Protected Members</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>struct  <B><A HREF="#DOC.2.164.83">ModeStack</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>struct  <B><A HREF="#DOC.2.164.84">AttributeStack</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::map&lt;StateAttribute::GLMode,<!1><A HREF="State.html#DOC.2.164.83">ModeStack</A>&gt; <B><A HREF="#DOC.2.164.88">ModeMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt;<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&gt; <B><A HREF="#DOC.2.164.89">TextureModeMapList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::map&lt;StateAttribute::Type,<!1><A HREF="State.html#DOC.2.164.84">AttributeStack</A>&gt; <B><A HREF="#DOC.2.164.90">AttributeMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt;<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&gt; <B><A HREF="#DOC.2.164.91">TextureAttributeMapList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt;<!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="StateSet.html">StateSet</A>&gt; &gt; <B><A HREF="#DOC.2.164.92">StateSetStack</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt;<!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="Matrix.html">Matrix</A>&gt; &gt; <B><A HREF="#DOC.2.164.93">MatrixStack</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>struct  <B><A HREF="#DOC.2.164.99">EnabledArrayPair</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt;<!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A>&gt; <B><A HREF="#DOC.2.164.100">EnabledTexCoordArrayList</A></B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Referenced.html">Referenced</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Referenced.html">Referenced</A>&amp; <B>operator = </B>(<!1><A HREF="Referenced.html">Referenced</A>&amp;)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   void <B>setDeleteHandler</B>(<!1><A HREF="DeleteHandler.html">DeleteHandler</A>* handler)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   <!1><A HREF="DeleteHandler.html">DeleteHandler</A>* <B>getDeleteHandler</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>ref</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref_nodelete</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   int <B>referenceCount</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref</B>() const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>mutable int <B>_refCount</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>State class for managing a state stack.
Lazy state updating is used to minimize state changes.</BLOCKQUOTE>
<DL>

<A NAME="State"></A>
<A NAME="DOC.2.164.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> State()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="pushStateSet"></A>
<A NAME="DOC.2.164.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void pushStateSet(const <!1><A HREF="StateSet.html">StateSet</A>* dstate)</B></TT>
<DD>push stateset onto state stack
<DL><DT><DD></DL><P>
<A NAME="popStateSet"></A>
<A NAME="DOC.2.164.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void popStateSet()</B></TT>
<DD>pop drawstate off state stack
<DL><DT><DD></DL><P>
<A NAME="captureCurrentState"></A>
<A NAME="DOC.2.164.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void captureCurrentState(<!1><A HREF="StateSet.html">StateSet</A>&amp; stateset) const </B></TT>
<DD>copy the modes and attributes which captures the current state
<DL><DT><DD></DL><P>
<A NAME="reset"></A>
<A NAME="DOC.2.164.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void reset()</B></TT>
<DD>reset the state object to an empty stack
<DL><DT><DD></DL><P>
<A NAME="applyProjectionMatrix"></A>
<A NAME="DOC.2.164.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyProjectionMatrix(const <!1><A HREF="RefMatrix.html">osg::RefMatrix</A>* matrix)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getProjectionMatrix"></A>
<A NAME="DOC.2.164.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; getProjectionMatrix() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyModelViewMatrix"></A>
<A NAME="DOC.2.164.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyModelViewMatrix(const <!1><A HREF="RefMatrix.html">osg::RefMatrix</A>* matrix)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getModelViewMatrix"></A>
<A NAME="DOC.2.164.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; getModelViewMatrix() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getViewFrustum"></A>
<A NAME="DOC.2.164.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Polytope.html">Polytope</A> getViewFrustum() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="apply"></A>
<A NAME="DOC.2.164.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void apply(const <!1><A HREF="StateSet.html">StateSet</A>* dstate)</B></TT>
<DD>Apply stateset
<DL><DT><DD></DL><P>
<A NAME="apply"></A>
<A NAME="DOC.2.164.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void apply()</B></TT>
<DD>Apply the state
<DL><DT><DD></DL><P>
<A NAME="applyMode"></A>
<A NAME="DOC.2.164.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool applyMode(StateAttribute::GLMode mode, bool enabled)</B></TT>
<DD>Apply an OpenGL mode if required. 
<DL><DT><DD></DL><P>
<A NAME="applyTextureMode"></A>
<A NAME="DOC.2.164.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool applyTextureMode(unsigned int unit, StateAttribute::GLMode mode, bool enabled)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyAttribute"></A>
<A NAME="DOC.2.164.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool applyAttribute(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)</B></TT>
<DD>Apply an attribute if required. 
<DL><DT><DD></DL><P>
<A NAME="applyTextureAttribute"></A>
<A NAME="DOC.2.164.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool applyTextureAttribute(unsigned int unit, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="haveAppliedMode"></A>
<A NAME="DOC.2.164.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedMode(StateAttribute::GLMode mode, StateAttribute::GLModeValue value)</B></TT>
<DD>Mode has been set externally, update state to reflect this setting
<DL><DT><DD></DL><P>
<A NAME="haveAppliedMode"></A>
<A NAME="DOC.2.164.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedMode(StateAttribute::GLMode mode)</B></TT>
<DD>Mode has been set externally, therefore dirty the associated mode in osg::State
so it is applied on next call to osg::State::apply()
<DL><DT><DD></DL><P>
<A NAME="haveAppliedAttribute"></A>
<A NAME="DOC.2.164.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedAttribute(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)</B></TT>
<DD>Attribute has been applied externally, update state to reflect this setting
<DL><DT><DD></DL><P>
<A NAME="haveAppliedAttribute"></A>
<A NAME="DOC.2.164.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedAttribute(StateAttribute::Type type)</B></TT>
<DD>Attribute has been applied externally, 
and therefore this attribute type has been dirtied 
and will need to be re-appplied on next osg::Stateapply().
note, if you have an osg::StateAttribute which you have applied externally
then use the have_applied(attribute) method as this will the osg::State to
track the current state more accuratly and enable lazy state updating such
that only changed state will be applied.
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedMode"></A>
<A NAME="DOC.2.164.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool getLastAppliedMode(StateAttribute::GLMode mode) const </B></TT>
<DD>Get whether the current specified mode is enabled (true) or disabled (false)
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedAttribute"></A>
<A NAME="DOC.2.164.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* getLastAppliedAttribute(StateAttribute::Type type) const </B></TT>
<DD>Get the current specified attribute, return NULL is one has not yet been applied
<DL><DT><DD></DL><P>
<A NAME="haveAppliedTextureMode"></A>
<A NAME="DOC.2.164.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedTextureMode(unsigned int unit, StateAttribute::GLMode mode, StateAttribute::GLModeValue value)</B></TT>
<DD>texture Mode has been set externally, update state to reflect this setting
<DL><DT><DD></DL><P>
<A NAME="haveAppliedTextureMode"></A>
<A NAME="DOC.2.164.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedTextureMode(unsigned int unit, StateAttribute::GLMode mode)</B></TT>
<DD>texture Mode has been set externally, therefore dirty the associated mode in osg::State
so it is applied on next call to osg::State::apply()
<DL><DT><DD></DL><P>
<A NAME="haveAppliedTextureAttribute"></A>
<A NAME="DOC.2.164.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedTextureAttribute(unsigned int unit, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)</B></TT>
<DD>texture Attribute has been applied externally, update state to reflect this setting
<DL><DT><DD></DL><P>
<A NAME="haveAppliedTextureAttribute"></A>
<A NAME="DOC.2.164.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedTextureAttribute(unsigned int unit, StateAttribute::Type type)</B></TT>
<DD>texture Attribute has been applied externally, 
and therefore this attribute type has been dirtied 
and will need to be re-appplied on next osg::Stateapply().
note, if you have an osg::StateAttribute which you have applied externally
then use the have_applied(attribute) method as this will the osg::State to
track the current state more accuratly and enable lazy state updating such
that only changed state will be applied.
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedTextureMode"></A>
<A NAME="DOC.2.164.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool getLastAppliedTextureMode(unsigned int unit, StateAttribute::GLMode mode) const </B></TT>
<DD>Get whether the current specified texture mode is enabled (true) or disabled (false)
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedTextureAttribute"></A>
<A NAME="DOC.2.164.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* getLastAppliedTextureAttribute(unsigned int unit, StateAttribute::Type type) const </B></TT>
<DD>Get the current specified texture attribute, return NULL is one has not yet been applied
<DL><DT><DD></DL><P>
<A NAME="dirtyAllModes"></A>
<A NAME="DOC.2.164.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void dirtyAllModes()</B></TT>
<DD>Dirty the modes previously applied in osg::State
<DL><DT><DD></DL><P>
<A NAME="dirtyAllAttributes"></A>
<A NAME="DOC.2.164.30"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void dirtyAllAttributes()</B></TT>
<DD>Dirty the modes attributes previously applied in osg::State
<DL><DT><DD></DL><P>
<A NAME="disableAllVertexArrays"></A>
<A NAME="DOC.2.164.31"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void disableAllVertexArrays()</B></TT>
<DD>disable the vertex, normal, color, tex coords, secenday color, fog coord and index arrays
<DL><DT><DD></DL><P>
<A NAME="dirtyAllVertexArrays"></A>
<A NAME="DOC.2.164.32"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void dirtyAllVertexArrays()</B></TT>
<DD>dirty the vertex, normal, color, tex coords, secenday color, fog coord and index arrays
<DL><DT><DD></DL><P>
<A NAME="setInterleavedArrays"></A>
<A NAME="DOC.2.164.33"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setInterleavedArrays( GLenum format, GLsizei stride, void* pointer)</B></TT>
<DD>Wrapper around glInterleavedArrays().
also resets the internal array points and modes within osg::State to keep the other
vertex array operations consistent. 
<DL><DT><DD></DL><P>
<A NAME="setVertexPointer"></A>
<A NAME="DOC.2.164.34"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setVertexPointer( GLint <!1><A HREF="fast_back_stack.html#DOC.2.209.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_VERTEX_ARRAY);glVertexPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableVertexPointer"></A>
<A NAME="DOC.2.164.35"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableVertexPointer()</B></TT>
<DD>wrapper glDisableClientState(GL_VERTEX_ARRAY).
note, only updates values that change.
<DL><DT><DD></DL><P>
<A NAME="dirtyVertexPointer"></A>
<A NAME="DOC.2.164.36"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void dirtyVertexPointer()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setNormalPointer"></A>
<A NAME="DOC.2.164.37"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setNormalPointer( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_NORMAL_ARRAY);glNormalPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableNormalPointer"></A>
<A NAME="DOC.2.164.38"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableNormalPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_NORMAL_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="dirtyNormalPointer"></A>
<A NAME="DOC.2.164.39"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void dirtyNormalPointer()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setColorPointer"></A>
<A NAME="DOC.2.164.40"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setColorPointer( GLint <!1><A HREF="fast_back_stack.html#DOC.2.209.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_COLOR_ARRAY);glColorPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableColorPointer"></A>
<A NAME="DOC.2.164.41"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableColorPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_COLOR_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="dirtyColorPointer"></A>
<A NAME="DOC.2.164.42"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void dirtyColorPointer()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="isSecondaryColorSupported"></A>
<A NAME="DOC.2.164.43"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool isSecondaryColorSupported() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="setSecondaryColorPointer"></A>
<A NAME="DOC.2.164.44"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setSecondaryColorPointer( GLint <!1><A HREF="fast_back_stack.html#DOC.2.209.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_SECONDARY_COLOR_ARRAY);glSecondayColorPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableSecondaryColorPointer"></A>
<A NAME="DOC.2.164.45"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableSecondaryColorPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_SECONDARY_COLOR_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="dirtySecondaryColorPointer"></A>
<A NAME="DOC.2.164.46"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void dirtySecondaryColorPointer()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setIndexPointer"></A>
<A NAME="DOC.2.164.47"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setIndexPointer( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_INDEX_ARRAY);glIndexPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableIndexPointer"></A>
<A NAME="DOC.2.164.48"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableIndexPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_INDEX_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="dirtyIndexPointer"></A>
<A NAME="DOC.2.164.49"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void dirtyIndexPointer()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="isFogCoordSupported"></A>
<A NAME="DOC.2.164.50"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool isFogCoordSupported() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="setFogCoordPointer"></A>
<A NAME="DOC.2.164.51"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setFogCoordPointer( GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_FOG_COORDINATE_ARRAY);glFogCoordPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableFogCoordPointer"></A>
<A NAME="DOC.2.164.52"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableFogCoordPointer()</B></TT>
<DD>wrapper around glDisableClientState(GL_FOG_COORDINATE_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="dirtyFogCoordPointer"></A>
<A NAME="DOC.2.164.53"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void dirtyFogCoordPointer()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setTexCoordPointer"></A>
<A NAME="DOC.2.164.54"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setTexCoordPointer( unsigned int unit, GLint <!1><A HREF="fast_back_stack.html#DOC.2.209.7">size</A>, GLenum type, GLsizei stride, const GLvoid* <!1><A HREF="Vec4.html#DOC.2.203.8">ptr</A> )</B></TT>
<DD>wrapper around glEnableClientState(GL_TEXTURE_COORD_ARRAY);glTexCoordPointer();
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="disableTexCoordPointer"></A>
<A NAME="DOC.2.164.55"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableTexCoordPointer( unsigned int unit )</B></TT>
<DD>wrapper around glDisableClientState(GL_TEXTURE_COORD_ARRAY);
note, only updates values that change
<DL><DT><DD></DL><P>
<A NAME="dirtyTexCoordPointer"></A>
<A NAME="DOC.2.164.56"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void dirtyTexCoordPointer( unsigned int unit )</B></TT>
<DL><DT><DD></DL><P>
<A NAME="disableTexCoordPointersAboveAndIncluding"></A>
<A NAME="DOC.2.164.57"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void disableTexCoordPointersAboveAndIncluding( unsigned int unit )</B></TT>
<DL><DT><DD></DL><P>
<A NAME="dirtyTexCoordPointersAboveAndIncluding"></A>
<A NAME="DOC.2.164.58"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void dirtyTexCoordPointersAboveAndIncluding( unsigned int unit )</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setClientActiveTextureUnit"></A>
<A NAME="DOC.2.164.59"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool setClientActiveTextureUnit( unsigned int unit )</B></TT>
<DD>set the current tex coord array texture unit, return true if selected, false if selection failed such as when multitexturing is not supported.
note, only updates values that change.
<DL><DT><DD></DL><P>
<A NAME="setActiveTextureUnit"></A>
<A NAME="DOC.2.164.60"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool setActiveTextureUnit( unsigned int unit )</B></TT>
<DD>set the current texture unit, return true if selected, false if selection failed such as when multitexturing is not supported.
note, only updates values that change.
<DL><DT><DD></DL><P>
<A NAME="setContextID"></A>
<A NAME="DOC.2.164.61"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setContextID(unsigned int contextID)</B></TT>
<DD>Set the current OpenGL context uniqueID.
Note, it is the application developers responsibility to
set up unique ID for each OpenGL context.  This value is
then used by osg::StateAttribure's and osg::Drawable's to
help manage OpenGL display list and texture binds appropriate
for each context, the contextID simply acts as an index local
arrays that they maintain for the purpose.
Typical settings for contextID are 0,1,2,3... up to the maximum
number of graphics contexts you have setup.
By default contextID is 0.
<DL><DT><DD></DL><P>
<A NAME="getContextID"></A>
<A NAME="DOC.2.164.62"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getContextID() const </B></TT>
<DD>Get the current OpenGL context unique ID
<DL><DT><DD></DL><P>
<A NAME="setFrameStamp"></A>
<A NAME="DOC.2.164.63"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setFrameStamp(<!1><A HREF="FrameStamp.html">FrameStamp</A>* fs)</B></TT>
<DD>Set the frame stamp for the current frame
<DL><DT><DD></DL><P>
<A NAME="getFrameStamp"></A>
<A NAME="DOC.2.164.64"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const <!1><A HREF="FrameStamp.html">FrameStamp</A>* getFrameStamp() const </B></TT>
<DD>Set the frame stamp for the current frame
<DL><DT><DD></DL><P>
<A NAME="setDisplaySettings"></A>
<A NAME="DOC.2.164.65"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setDisplaySettings(<!1><A HREF="DisplaySettings.html">DisplaySettings</A>* vs)</B></TT>
<DD>Set the DisplaySettings. Note, nothing is applied, the visual settings are just used
used in the State object to pass the current visual settings to Drawables
during rendering. 
<DL><DT><DD></DL><P>
<A NAME="getDisplaySettings"></A>
<A NAME="DOC.2.164.66"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const <!1><A HREF="DisplaySettings.html">DisplaySettings</A>* getDisplaySettings() const </B></TT>
<DD>Get the DisplaySettings 
<DL><DT><DD></DL><P>
<A NAME="AttributePair"></A>
<A NAME="DOC.2.164.67"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::pair&lt;const <!1><A HREF="StateAttribute.html">StateAttribute</A>*,StateAttribute::OverrideValue&gt; AttributePair</B></TT>
<DL><DT><DD></DL><P>
<A NAME="AttributeVec"></A>
<A NAME="DOC.2.164.68"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;<!1><A HREF="State.html#DOC.2.164.67">AttributePair</A>&gt; AttributeVec</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ValueVec"></A>
<A NAME="DOC.2.164.69"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;StateAttribute::GLModeValue&gt; ValueVec</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setReportGLErrors"></A>
<A NAME="DOC.2.164.70"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setReportGLErrors(bool flag)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getReportGLErrors"></A>
<A NAME="DOC.2.164.71"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool getReportGLErrors() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="checkGLErrors"></A>
<A NAME="DOC.2.164.72"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool checkGLErrors(const char* str) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="checkGLErrors"></A>
<A NAME="DOC.2.164.73"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool checkGLErrors(StateAttribute::GLMode mode) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="checkGLErrors"></A>
<A NAME="DOC.2.164.74"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool checkGLErrors(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="~State"></A>
<A NAME="DOC.2.164.75"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~State()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_contextID"></A>
<A NAME="DOC.2.164.76"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int _contextID</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_frameStamp"></A>
<A NAME="DOC.2.164.77"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="FrameStamp.html">FrameStamp</A>&gt;  _frameStamp</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_identity"></A>
<A NAME="DOC.2.164.78"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="RefMatrix.html">RefMatrix</A>&gt;  _identity</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_projection"></A>
<A NAME="DOC.2.164.79"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="RefMatrix.html">RefMatrix</A>&gt;  _projection</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_modelView"></A>
<A NAME="DOC.2.164.80"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="RefMatrix.html">RefMatrix</A>&gt;  _modelView</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_displaySettings"></A>
<A NAME="DOC.2.164.81"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="DisplaySettings.html">DisplaySettings</A>&gt;  _displaySettings</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_reportGLErrors"></A>
<A NAME="DOC.2.164.82"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _reportGLErrors</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ModeStack"></A>
<A NAME="DOC.2.164.83"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>struct  ModeStack</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="ModeStack"></A>
<A NAME="DOC.2.164.83.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> ModeStack()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="changed"></A>
<A NAME="DOC.2.164.83.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool changed</B></TT>
<DL><DT><DD></DL><P>
<A NAME="last_applied_value"></A>
<A NAME="DOC.2.164.83.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool last_applied_value</B></TT>
<DL><DT><DD></DL><P>
<A NAME="global_default_value"></A>
<A NAME="DOC.2.164.83.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool global_default_value</B></TT>
<DL><DT><DD></DL><P>
<A NAME="valueVec"></A>
<A NAME="DOC.2.164.83.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.69">ValueVec</A> valueVec</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="AttributeStack"></A>
<A NAME="DOC.2.164.84"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>struct  AttributeStack</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="AttributeStack"></A>
<A NAME="DOC.2.164.84.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> AttributeStack()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="changed"></A>
<A NAME="DOC.2.164.84.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool changed</B></TT>
<DD>apply an attribute if required, passing in attribute and appropriate attribute stack 
<DL><DT><DD></DL><P>
<A NAME="last_applied_attribute"></A>
<A NAME="DOC.2.164.84.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* last_applied_attribute</B></TT>
<DL><DT><DD></DL><P>
<A NAME="global_default_attribute"></A>
<A NAME="DOC.2.164.84.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="StateAttribute.html">StateAttribute</A>&gt;  global_default_attribute</B></TT>
<DL><DT><DD></DL><P>
<A NAME="attributeVec"></A>
<A NAME="DOC.2.164.84.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.68">AttributeVec</A> attributeVec</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="applyMode"></A>
<A NAME="DOC.2.164.85"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool applyMode(StateAttribute::GLMode mode, bool enabled, <!1><A HREF="State.html#DOC.2.164.83">ModeStack</A>&amp; ms)</B></TT>
<DD>apply an OpenGL mode if required, passing in mode, enable flag and appropriate mode stack 
<DL><DT><DD></DL><P>
<A NAME="applyAttribute"></A>
<A NAME="DOC.2.164.86"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool applyAttribute(const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute, <!1><A HREF="State.html#DOC.2.164.84">AttributeStack</A>&amp; as)</B></TT>
<DD>apply an attribute if required, passing in attribute and appropriate attribute stack 
<DL><DT><DD></DL><P>
<A NAME="applyGlobalDefaultAttribute"></A>
<A NAME="DOC.2.164.87"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool applyGlobalDefaultAttribute(<!1><A HREF="State.html#DOC.2.164.84">AttributeStack</A>&amp; as)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ModeMap"></A>
<A NAME="DOC.2.164.88"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::map&lt;StateAttribute::GLMode,<!1><A HREF="State.html#DOC.2.164.83">ModeStack</A>&gt; ModeMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="TextureModeMapList"></A>
<A NAME="DOC.2.164.89"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&gt; TextureModeMapList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="AttributeMap"></A>
<A NAME="DOC.2.164.90"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::map&lt;StateAttribute::Type,<!1><A HREF="State.html#DOC.2.164.84">AttributeStack</A>&gt; AttributeMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="TextureAttributeMapList"></A>
<A NAME="DOC.2.164.91"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&gt; TextureAttributeMapList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="StateSetStack"></A>
<A NAME="DOC.2.164.92"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;<!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="StateSet.html">StateSet</A>&gt; &gt; StateSetStack</B></TT>
<DL><DT><DD></DL><P>
<A NAME="MatrixStack"></A>
<A NAME="DOC.2.164.93"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;<!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;const <!1><A HREF="Matrix.html">Matrix</A>&gt; &gt; MatrixStack</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_modeMap"></A>
<A NAME="DOC.2.164.94"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.88">ModeMap</A> _modeMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_attributeMap"></A>
<A NAME="DOC.2.164.95"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A> _attributeMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_textureModeMapList"></A>
<A NAME="DOC.2.164.96"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.89">TextureModeMapList</A> _textureModeMapList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_textureAttributeMapList"></A>
<A NAME="DOC.2.164.97"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.91">TextureAttributeMapList</A> _textureAttributeMapList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_drawStateStack"></A>
<A NAME="DOC.2.164.98"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.92">StateSetStack</A> _drawStateStack</B></TT>
<DL><DT><DD></DL><P>
<A NAME="EnabledArrayPair"></A>
<A NAME="DOC.2.164.99"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>struct  EnabledArrayPair</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="EnabledArrayPair"></A>
<A NAME="DOC.2.164.99.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> EnabledArrayPair()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="EnabledArrayPair"></A>
<A NAME="DOC.2.164.99.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> EnabledArrayPair(const <!1><A HREF="State.html#DOC.2.164.99.2">EnabledArrayPair</A>&amp; eap)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="operator = "></A>
<A NAME="DOC.2.164.99.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A>&amp; operator = (const <!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A>&amp; eap)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_dirty"></A>
<A NAME="DOC.2.164.99.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _dirty</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_enabled"></A>
<A NAME="DOC.2.164.99.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _enabled</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_pointer"></A>
<A NAME="DOC.2.164.99.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const GLvoid* _pointer</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="EnabledTexCoordArrayList"></A>
<A NAME="DOC.2.164.100"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt;<!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A>&gt; EnabledTexCoordArrayList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_vertexArray"></A>
<A NAME="DOC.2.164.101"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> _vertexArray</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_normalArray"></A>
<A NAME="DOC.2.164.102"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> _normalArray</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_colorArray"></A>
<A NAME="DOC.2.164.103"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> _colorArray</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_secondaryColorArray"></A>
<A NAME="DOC.2.164.104"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> _secondaryColorArray</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_indexArray"></A>
<A NAME="DOC.2.164.105"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> _indexArray</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_fogArray"></A>
<A NAME="DOC.2.164.106"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.99">EnabledArrayPair</A> _fogArray</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_texCoordArrayList"></A>
<A NAME="DOC.2.164.107"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="State.html#DOC.2.164.100">EnabledTexCoordArrayList</A> _texCoordArrayList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_currentActiveTextureUnit"></A>
<A NAME="DOC.2.164.108"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int _currentActiveTextureUnit</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_currentClientActiveTextureUnit"></A>
<A NAME="DOC.2.164.109"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int _currentClientActiveTextureUnit</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getOrCreateTextureModeMap"></A>
<A NAME="DOC.2.164.110"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   <!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; getOrCreateTextureModeMap(unsigned int unit)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getOrCreateTextureAttributeMap"></A>
<A NAME="DOC.2.164.111"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   <!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; getOrCreateTextureAttributeMap(unsigned int unit)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="haveAppliedMode"></A>
<A NAME="DOC.2.164.112"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedMode(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, StateAttribute::GLMode mode, StateAttribute::GLModeValue value)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="haveAppliedMode"></A>
<A NAME="DOC.2.164.113"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedMode(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, StateAttribute::GLMode mode)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="haveAppliedAttribute"></A>
<A NAME="DOC.2.164.114"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedAttribute(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, const <!1><A HREF="StateAttribute.html">StateAttribute</A>* attribute)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="haveAppliedAttribute"></A>
<A NAME="DOC.2.164.115"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void haveAppliedAttribute(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, StateAttribute::Type type)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedMode"></A>
<A NAME="DOC.2.164.116"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool getLastAppliedMode(const <!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, StateAttribute::GLMode mode) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getLastAppliedAttribute"></A>
<A NAME="DOC.2.164.117"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="StateAttribute.html">StateAttribute</A>* getLastAppliedAttribute(const <!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, StateAttribute::Type type) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="_isSecondColorSupportResolved"></A>
<A NAME="DOC.2.164.118"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>mutable bool _isSecondColorSupportResolved</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_isSecondColorSupported"></A>
<A NAME="DOC.2.164.119"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>mutable bool _isSecondColorSupported</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeSecondaryColorSupported"></A>
<A NAME="DOC.2.164.120"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool computeSecondaryColorSupported() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="_isFogCoordSupportResolved"></A>
<A NAME="DOC.2.164.121"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>mutable bool _isFogCoordSupportResolved</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_isFogCoordSupported"></A>
<A NAME="DOC.2.164.122"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>mutable bool _isFogCoordSupported</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeFogCoordSupported"></A>
<A NAME="DOC.2.164.123"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool computeFogCoordSupported() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="pushModeList"></A>
<A NAME="DOC.2.164.124"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void pushModeList(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, const StateSet::ModeList&amp; modeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="pushAttributeList"></A>
<A NAME="DOC.2.164.125"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void pushAttributeList(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="popModeList"></A>
<A NAME="DOC.2.164.126"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void popModeList(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, const StateSet::ModeList&amp; modeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="popAttributeList"></A>
<A NAME="DOC.2.164.127"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void popAttributeList(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyModeList"></A>
<A NAME="DOC.2.164.128"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyModeList(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap, const StateSet::ModeList&amp; modeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyAttributeList"></A>
<A NAME="DOC.2.164.129"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyAttributeList(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap, const StateSet::AttributeList&amp; attributeList)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyModeMap"></A>
<A NAME="DOC.2.164.130"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyModeMap(<!1><A HREF="State.html#DOC.2.164.88">ModeMap</A>&amp; modeMap)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyAttributeMap"></A>
<A NAME="DOC.2.164.131"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void applyAttributeMap(<!1><A HREF="State.html#DOC.2.164.90">AttributeMap</A>&amp; attributeMap)</B></TT>
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
