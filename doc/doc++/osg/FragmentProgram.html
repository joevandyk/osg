<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::FragmentProgram</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.6">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::FragmentProgram</A></H2></H2><BLOCKQUOTE>FragmentProgram - encapsulates the OpenGL ARB fragment program state</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=125>
<param name=classes value="CReferenced,MReferenced.html,CObject,MObject.html,CStateAttribute,MStateAttribute.html,CFragmentProgram,MFragmentProgram.html">
<param name=before value="M,M,M,M">
<param name=after value="Md_SPSP,Md_SP,Md_,M">
<param name=indent value="0,1,2,3">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Classes</H3><DD><DT>
class  SG_EXPORT <B><A HREF="Extensions.3.html">Extensions</A></B>: public <!1><A HREF="Referenced.html">osg::Referenced</A>
<DD><I>Extensions class which encapsulates the querring of extensions and associated function pointers, and provide convinience wrappers to  check for the extensions or use the associated functions</I>
</DL></P>

<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.104.1">FragmentProgram</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.104.2">FragmentProgram</A></B>(const <!1><A HREF="FragmentProgram.html#DOC.2.104.2">FragmentProgram</A>&amp; vp, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)
<DD><I>Copy constructor using CopyOp to manage deep vs shallow copy</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.104.3">META_StateAttribute</A></B>(<!1><A HREF="osg.html">osg</A>, <!1><A HREF="FragmentProgram.html">FragmentProgram</A>, <!1><A HREF="StateAttribute.html#DOC.2.229.6.45">FRAGMENTPROGRAM</A>)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   int <B><A HREF="#DOC.2.104.4">compare</A></B>(const <!1><A HREF="StateAttribute.html">osg::StateAttribute</A>&amp; sa) const 
<DD><I>return -1 if *this < *rhs, 0 if *this==*rhs, 1 if *this>*rhs</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.104.5">getModeUsage</A></B>(<!1><A HREF="StateAttribute.html#DOC.2.229.20">ModeUsage</A>&amp; usage) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   GLuint&amp; <B><A HREF="#DOC.2.104.6">getFragmentProgramID</A></B>(unsigned int contextID) const 
<DD><I>Get the handle to the fragment program id for the current context</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.104.7">setFragmentProgram</A></B>( const std::string&amp; program )
<DD><I>Set the fragment program using C++ style string</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.104.8">setFragmentProgram</A></B>( const char* program )
<DD><I>Set the fragment program using a C style string</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const std::string&amp; <B><A HREF="#DOC.2.104.9">getFragmentProgram</A></B>() const 
<DD><I>Get the fragment program</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.104.10">setProgramLocalParameter</A></B>(const GLuint <!1><A HREF="TemplateIndexArray.html#DOC.2.18.17">index</A>, const <!1><A HREF="osg.html#DOC.2.270">Vec4</A>&amp; p)
<DD><I>Set Program Parameters </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <!1><A HREF="FragmentProgram.html#DOC.2.104.11">LocalParamList</A>&amp; <B><A HREF="#DOC.2.104.12">getLocalParamList</A></B>()
<DD><I>Get list of Program Parameters </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const <!1><A HREF="FragmentProgram.html#DOC.2.104.11">LocalParamList</A>&amp; <B><A HREF="#DOC.2.104.13">getLocalParamList</A></B>() const 
<DD><I>Get const list of Program Parameters </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.104.14">setMatrix</A></B>(const GLenum mode, const <!1><A HREF="osg.html#DOC.2.134">Matrix</A>&amp; matrix)
<DD><I>Matrix </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.104.15">dirtyFragmentProgramObject</A></B>()
<DD><I>Force a recompile on next apply() of associated OpenGL vertex program objects</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   void <B><A HREF="#DOC.2.104.16">deleteFragmentProgramObject</A></B>(unsigned int contextID, GLuint handle)
<DD><I>use deleteFragmentProgramObject instead of glDeletePrograms to allow OpenGL Fragment Program objects to cached until they can be deleted by the OpenGL context in which they were created, specified by contextID</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   void <B><A HREF="#DOC.2.104.17">flushDeletedFragmentProgramObjects</A></B>(unsigned int contextID, double currentTime, double&amp; availableTime)
<DD><I>flush all the cached fragment programs which need to be deleted in the OpenGL context related to contextID</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.104.18">apply</A></B>(<!1><A HREF="State.html">State</A>&amp; state) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.104.19">compileGLObjects</A></B>(<!1><A HREF="State.html">State</A>&amp; state) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.104.20">releaseGLObjects</A></B>(<!1><A HREF="State.html">State</A>* state=0) const 
<DD><I>release an OpenGL objects in specified graphics context if State object is passed, otherwise release OpenGL objexts for all graphics context if State object pointer NULL</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   <!1><A HREF="Extensions.3.html">Extensions</A>* <B><A HREF="#DOC.2.104.22">getExtensions</A></B>(unsigned int contextID, bool createIfNotInitalized)
<DD><I>Function to call to get the extension of a specified context.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   void <B><A HREF="#DOC.2.104.23">setExtensions</A></B>(unsigned int contextID, <!1><A HREF="Extensions.3.html">Extensions</A>* extensions)
<DD><I>setExtensions allows users to override the extensions across graphics contexts.</I>
</DL></P>

<P><DL>
<DT><H3>Public</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::map&lt;GLuint,<!1><A HREF="osg.html#DOC.2.270">Vec4</A>&gt;  <B><A HREF="#DOC.2.104.11">LocalParamList</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>mutable <!1><A HREF="FragmentProgram.html#DOC.2.104.25">FragmentProgramIDList</A> <B><A HREF="#DOC.2.104.26">_fragmentProgramIDList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>std::string <B><A HREF="#DOC.2.104.27">_fragmentProgram</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="FragmentProgram.html#DOC.2.104.11">LocalParamList</A> <B><A HREF="#DOC.2.104.28">_programLocalParameters</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="FragmentProgram.html#DOC.2.104.29">MatrixList</A> <B><A HREF="#DOC.2.104.30">_matrixList</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.104.24">~FragmentProgram</A></B>()
</DL></P>

<P><DL>
<DT><H3>Protected</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  <!1><A HREF="buffered_value.html">buffered_value</A>&lt;GLuint&gt;  <B><A HREF="#DOC.2.104.25">FragmentProgramIDList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::map&lt;GLenum,<!1><A HREF="osg.html#DOC.2.134">Matrix</A>&gt;  <B><A HREF="#DOC.2.104.29">MatrixList</A></B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="StateAttribute.html">StateAttribute</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Classes</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>enum  <B>Values</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>enum  <B>Types</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>struct  <B>ModeUsage</B>
</DL></P>

<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>virtual   <!1><A HREF="Object.html">Object</A>* <B>cloneType</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   <!1><A HREF="Object.html">Object</A>* <B>clone</B>(const <!1><A HREF="CopyOp.html">CopyOp</A>&amp;) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   bool <B>isSameKindAs</B>(const <!1><A HREF="Object.html">Object</A>* obj) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   const char* <B>libraryName</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   const char* <B>className</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   <!1><A HREF="StateAttribute.html#DOC.2.229.5">Type</A> <B>getType</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   bool <B>isTextureAttribute</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>bool <B>operator <  </B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>&amp; rhs) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>bool <B>operator == </B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>&amp; rhs) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>bool <B>operator != </B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>&amp; rhs) const 
</DL></P>

<P><DL>
<DT><H3>Public</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>typedef  GLenum <B>GLMode</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>typedef  unsigned int <B>GLModeValue</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>typedef  unsigned int <B>OverrideValue</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>typedef  unsigned int <B>Type</B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Object.html">Object</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Classes</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>enum  <B>DataVariance</B>
</DL></P>

<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setDataVariance</B>(<!1><A HREF="Object.html#DOC.2.167.8">DataVariance</A> dv)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Object.html#DOC.2.167.8">DataVariance</A> <B>getDataVariance</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setUserData</B>(<!1><A HREF="Referenced.html">Referenced</A>* obj)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Referenced.html">Referenced</A>* <B>getUserData</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="Referenced.html">Referenced</A>* <B>getUserData</B>() const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="Object.html#DOC.2.167.8">DataVariance</A> <B>_dataVariance</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="Referenced.html">Referenced</A>&gt;  <B>_userData</B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Referenced.html">Referenced</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Referenced.html">Referenced</A>&amp; <B>operator = </B>(const <!1><A HREF="Referenced.html">Referenced</A>&amp;)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   void <B>setDeleteHandler</B>(<!1><A HREF="DeleteHandler.html">DeleteHandler</A>* handler)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   <!1><A HREF="DeleteHandler.html">DeleteHandler</A>* <B>getDeleteHandler</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>ref</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref_nodelete</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   int <B>referenceCount</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref</B>() const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>mutable OpenThreads::Mutex <B>_refMutex</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>mutable int <B>_refCount</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>FragmentProgram - encapsulates the OpenGL ARB fragment program state</BLOCKQUOTE>
<DL>

<A NAME="FragmentProgram"></A>
<A NAME="DOC.2.104.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> FragmentProgram()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="FragmentProgram"></A>
<A NAME="DOC.2.104.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> FragmentProgram(const <!1><A HREF="FragmentProgram.html#DOC.2.104.2">FragmentProgram</A>&amp; vp, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)</B></TT>
<DD>Copy constructor using CopyOp to manage deep vs shallow copy
<DL><DT><DD></DL><P>
<A NAME="META_StateAttribute"></A>
<A NAME="DOC.2.104.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> META_StateAttribute(<!1><A HREF="osg.html">osg</A>, <!1><A HREF="FragmentProgram.html">FragmentProgram</A>, <!1><A HREF="StateAttribute.html#DOC.2.229.6.45">FRAGMENTPROGRAM</A>)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="compare"></A>
<A NAME="DOC.2.104.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   int compare(const <!1><A HREF="StateAttribute.html">osg::StateAttribute</A>&amp; sa) const </B></TT>
<DD>return -1 if *this < *rhs, 0 if *this==*rhs, 1 if *this>*rhs
<DL><DT><DD></DL><P>
<A NAME="getModeUsage"></A>
<A NAME="DOC.2.104.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool getModeUsage(<!1><A HREF="StateAttribute.html#DOC.2.229.20">ModeUsage</A>&amp; usage) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getFragmentProgramID"></A>
<A NAME="DOC.2.104.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   GLuint&amp; getFragmentProgramID(unsigned int contextID) const </B></TT>
<DD>Get the handle to the fragment program id for the current context
<DL><DT><DD></DL><P>
<A NAME="setFragmentProgram"></A>
<A NAME="DOC.2.104.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setFragmentProgram( const std::string&amp; program )</B></TT>
<DD>Set the fragment program using C++ style string
<DL><DT><DD></DL><P>
<A NAME="setFragmentProgram"></A>
<A NAME="DOC.2.104.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setFragmentProgram( const char* program )</B></TT>
<DD>Set the fragment program using a C style string
<DL><DT><DD></DL><P>
<A NAME="getFragmentProgram"></A>
<A NAME="DOC.2.104.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const std::string&amp; getFragmentProgram() const </B></TT>
<DD>Get the fragment program
<DL><DT><DD></DL><P>
<A NAME="setProgramLocalParameter"></A>
<A NAME="DOC.2.104.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setProgramLocalParameter(const GLuint <!1><A HREF="TemplateIndexArray.html#DOC.2.18.17">index</A>, const <!1><A HREF="osg.html#DOC.2.270">Vec4</A>&amp; p)</B></TT>
<DD>Set Program Parameters 
<DL><DT><DD></DL><P>
<A NAME="LocalParamList"></A>
<A NAME="DOC.2.104.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::map&lt;GLuint,<!1><A HREF="osg.html#DOC.2.270">Vec4</A>&gt;  LocalParamList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getLocalParamList"></A>
<A NAME="DOC.2.104.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   <!1><A HREF="FragmentProgram.html#DOC.2.104.11">LocalParamList</A>&amp; getLocalParamList()</B></TT>
<DD>Get list of Program Parameters 
<DL><DT><DD></DL><P>
<A NAME="getLocalParamList"></A>
<A NAME="DOC.2.104.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const <!1><A HREF="FragmentProgram.html#DOC.2.104.11">LocalParamList</A>&amp; getLocalParamList() const </B></TT>
<DD>Get const list of Program Parameters 
<DL><DT><DD></DL><P>
<A NAME="setMatrix"></A>
<A NAME="DOC.2.104.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setMatrix(const GLenum mode, const <!1><A HREF="osg.html#DOC.2.134">Matrix</A>&amp; matrix)</B></TT>
<DD>Matrix 
<DL><DT><DD></DL><P>
<A NAME="dirtyFragmentProgramObject"></A>
<A NAME="DOC.2.104.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void dirtyFragmentProgramObject()</B></TT>
<DD>Force a recompile on next apply() of associated OpenGL vertex program objects
<DL><DT><DD></DL><P>
<A NAME="deleteFragmentProgramObject"></A>
<A NAME="DOC.2.104.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   void deleteFragmentProgramObject(unsigned int contextID, GLuint handle)</B></TT>
<DD>use deleteFragmentProgramObject instead of glDeletePrograms to allow
OpenGL Fragment Program objects to cached until they can be deleted
by the OpenGL context in which they were created, specified
by contextID
<DL><DT><DD></DL><P>
<A NAME="flushDeletedFragmentProgramObjects"></A>
<A NAME="DOC.2.104.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   void flushDeletedFragmentProgramObjects(unsigned int contextID, double currentTime, double&amp; availableTime)</B></TT>
<DD>flush all the cached fragment programs which need to be deleted
in the OpenGL context related to contextID
<DL><DT><DD></DL><P>
<A NAME="apply"></A>
<A NAME="DOC.2.104.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void apply(<!1><A HREF="State.html">State</A>&amp; state) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="compileGLObjects"></A>
<A NAME="DOC.2.104.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void compileGLObjects(<!1><A HREF="State.html">State</A>&amp; state) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="releaseGLObjects"></A>
<A NAME="DOC.2.104.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void releaseGLObjects(<!1><A HREF="State.html">State</A>* state=0) const </B></TT>
<DD>release an OpenGL objects in specified graphics context if State
object is passed, otherwise release OpenGL objexts for all graphics context if
State object pointer NULL
<DL><DT><DD></DL><P>
<A NAME="getExtensions"></A>
<A NAME="DOC.2.104.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   <!1><A HREF="Extensions.3.html">Extensions</A>* getExtensions(unsigned int contextID, bool createIfNotInitalized)</B></TT>
<DD>Function to call to get the extension of a specified context.
If the Exentsion object for that context has not yet been created then 
and the 'createIfNotInitalized' flag been set to false then returns NULL.
If 'createIfNotInitalized' is true then the Extensions object is 
automatically created.  However, in this case the extension object 
only be created with the graphics context associated with ContextID..
<DL><DT><DD></DL><P>
<A NAME="setExtensions"></A>
<A NAME="DOC.2.104.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   void setExtensions(unsigned int contextID, <!1><A HREF="Extensions.3.html">Extensions</A>* extensions)</B></TT>
<DD>setExtensions allows users to override the extensions across graphics contexts.
typically used when you have different extensions supported across graphics pipes
but need to ensure that they all use the same low common denominator extensions.
<DL><DT><DD></DL><P>
<A NAME="~FragmentProgram"></A>
<A NAME="DOC.2.104.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~FragmentProgram()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="FragmentProgramIDList"></A>
<A NAME="DOC.2.104.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  <!1><A HREF="buffered_value.html">buffered_value</A>&lt;GLuint&gt;  FragmentProgramIDList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_fragmentProgramIDList"></A>
<A NAME="DOC.2.104.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>mutable <!1><A HREF="FragmentProgram.html#DOC.2.104.25">FragmentProgramIDList</A> _fragmentProgramIDList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_fragmentProgram"></A>
<A NAME="DOC.2.104.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string _fragmentProgram</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_programLocalParameters"></A>
<A NAME="DOC.2.104.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="FragmentProgram.html#DOC.2.104.11">LocalParamList</A> _programLocalParameters</B></TT>
<DL><DT><DD></DL><P>
<A NAME="MatrixList"></A>
<A NAME="DOC.2.104.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::map&lt;GLenum,<!1><A HREF="osg.html#DOC.2.134">Matrix</A>&gt;  MatrixList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_matrixList"></A>
<A NAME="DOC.2.104.30"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="FragmentProgram.html#DOC.2.104.29">MatrixList</A> _matrixList</B></TT>
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://www.linuxsupportline.com/~doc++">DOC++</A>.
</BODY>
</HTML>
