<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::Plane</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.8">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::Plane</A></H2></H2><BLOCKQUOTE>A plane class.</BLOCKQUOTE>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <B><A HREF="#DOC.2.92.1">Plane</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <B><A HREF="#DOC.2.92.2">Plane</A></B>(const <!1><A HREF="Plane.html#DOC.2.92.2">Plane</A>&amp; pl)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <B><A HREF="#DOC.2.92.3">Plane</A></B>(const float <!1><A HREF="UByte4.html#DOC.2.143.15">a</A>, const float <!1><A HREF="UByte4.html#DOC.2.143.14">b</A>, const float c, const float d)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <B><A HREF="#DOC.2.92.4">Plane</A></B>(const <!1><A HREF="Vec4.html">Vec4</A>&amp; vec)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <B><A HREF="#DOC.2.92.5">Plane</A></B>(const <!1><A HREF="Vec3.html">Vec3</A>&amp; norm, const float d)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <B><A HREF="#DOC.2.92.6">Plane</A></B>(const <!1><A HREF="Vec3.html">Vec3</A>&amp; v1, const <!1><A HREF="Vec3.html">Vec3</A>&amp; v2, const <!1><A HREF="Vec3.html">Vec3</A>&amp; v3)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <!1><A HREF="Plane.html">Plane</A>&amp; <B><A HREF="#DOC.2.92.7">operator = </A></B>(const <!1><A HREF="Plane.html">Plane</A>&amp; pl)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.8">set</A></B>(const <!1><A HREF="Plane.html">Plane</A>&amp; pl)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.9">set</A></B>(const float <!1><A HREF="UByte4.html#DOC.2.143.15">a</A>, const float <!1><A HREF="UByte4.html#DOC.2.143.14">b</A>, const float c, const float d)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.10">set</A></B>(const <!1><A HREF="Vec4.html">Vec4</A>&amp; vec)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.11">set</A></B>(const <!1><A HREF="Vec3.html">Vec3</A>&amp; norm, const float d)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.12">set</A></B>(const <!1><A HREF="Vec3.html">Vec3</A>&amp; v1, const <!1><A HREF="Vec3.html">Vec3</A>&amp; v2, const <!1><A HREF="Vec3.html">Vec3</A>&amp; v3)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.13">flip</A></B>()
<DD><I>flip/reverse the orientation of the plane</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.14">makeUnitLength</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.15">calculateUpperLowerBBCorners</A></B>()
<DD><I>calculate the upper and lower bounding box corners to be used in the intersect(BoundingBox&) method for speeding calculations</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const bool <B><A HREF="#DOC.2.92.16">valid</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <!1><A HREF="Vec4.html">Vec4</A>&amp; <B><A HREF="#DOC.2.92.17">asVec4</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const <!1><A HREF="Vec4.html">Vec4</A>&amp; <B><A HREF="#DOC.2.92.18">asVec4</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   float&amp; <B><A HREF="#DOC.2.92.19">operator [] </A></B>(const int i)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   float <B><A HREF="#DOC.2.92.20">operator [] </A></B>(const int i) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <!1><A HREF="Vec3.html">osg::Vec3</A> <B><A HREF="#DOC.2.92.21">getNormal</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const float <B><A HREF="#DOC.2.92.22">distance</A></B>(const <!1><A HREF="Vec3.html">osg::Vec3</A>&amp; v) const 
<DD><I>calculate the distance between a point and the plane</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const int <B><A HREF="#DOC.2.92.23">intersect</A></B>(const std::vector&lt;<!1><A HREF="Vec3.html">Vec3</A>&gt;&amp; vertices) const 
<DD><I>intersection test between plane and vertex list return 1 if the bs is completely above plane, return 0 if the bs intersects the plane, return -1 if the bs is completely below the plane</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const int <B><A HREF="#DOC.2.92.24">intersect</A></B>(const <!1><A HREF="BoundingSphere.html">BoundingSphere</A>&amp; bs) const 
<DD><I>intersection test between plane and bounding sphere.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const int <B><A HREF="#DOC.2.92.25">intersect</A></B>(const <!1><A HREF="BoundingBox.html">BoundingBox</A>&amp; bb) const 
<DD><I>intersection test between plane and bounding sphere.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.26">transform</A></B>(const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; matrix)
<DD><I>Transform the plane by matrix.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.92.27">transformProvidingInverse</A></B>(const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; matrix)
<DD><I>Transform the plane by provide a pre inverted matrix.</I>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Vec4.html">Vec4</A> <B><A HREF="#DOC.2.92.28">_fv</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.2.92.29">_upperBBCorner</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.2.92.30">_lowerBBCorner</A></B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>A plane class. It can be used to represent an infinite plane.</BLOCKQUOTE>
<DL>

<A NAME="Plane"></A>
<A NAME="DOC.2.92.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   Plane()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Plane"></A>
<A NAME="DOC.2.92.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   Plane(const <!1><A HREF="Plane.html#DOC.2.92.2">Plane</A>&amp; pl)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Plane"></A>
<A NAME="DOC.2.92.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   Plane(const float <!1><A HREF="UByte4.html#DOC.2.143.15">a</A>, const float <!1><A HREF="UByte4.html#DOC.2.143.14">b</A>, const float c, const float d)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Plane"></A>
<A NAME="DOC.2.92.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   Plane(const <!1><A HREF="Vec4.html">Vec4</A>&amp; vec)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Plane"></A>
<A NAME="DOC.2.92.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   Plane(const <!1><A HREF="Vec3.html">Vec3</A>&amp; norm, const float d)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Plane"></A>
<A NAME="DOC.2.92.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   Plane(const <!1><A HREF="Vec3.html">Vec3</A>&amp; v1, const <!1><A HREF="Vec3.html">Vec3</A>&amp; v2, const <!1><A HREF="Vec3.html">Vec3</A>&amp; v3)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="operator = "></A>
<A NAME="DOC.2.92.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   <!1><A HREF="Plane.html">Plane</A>&amp; operator = (const <!1><A HREF="Plane.html">Plane</A>&amp; pl)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="set"></A>
<A NAME="DOC.2.92.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void set(const <!1><A HREF="Plane.html">Plane</A>&amp; pl)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="set"></A>
<A NAME="DOC.2.92.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void set(const float <!1><A HREF="UByte4.html#DOC.2.143.15">a</A>, const float <!1><A HREF="UByte4.html#DOC.2.143.14">b</A>, const float c, const float d)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="set"></A>
<A NAME="DOC.2.92.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void set(const <!1><A HREF="Vec4.html">Vec4</A>&amp; vec)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="set"></A>
<A NAME="DOC.2.92.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void set(const <!1><A HREF="Vec3.html">Vec3</A>&amp; norm, const float d)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="set"></A>
<A NAME="DOC.2.92.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void set(const <!1><A HREF="Vec3.html">Vec3</A>&amp; v1, const <!1><A HREF="Vec3.html">Vec3</A>&amp; v2, const <!1><A HREF="Vec3.html">Vec3</A>&amp; v3)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="flip"></A>
<A NAME="DOC.2.92.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void flip()</B></TT>
<DD>flip/reverse the orientation of the plane
<DL><DT><DD></DL><P>
<A NAME="makeUnitLength"></A>
<A NAME="DOC.2.92.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void makeUnitLength()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="calculateUpperLowerBBCorners"></A>
<A NAME="DOC.2.92.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void calculateUpperLowerBBCorners()</B></TT>
<DD>calculate the upper and lower bounding box corners to be used
in the intersect(BoundingBox&) method for speeding calculations
<DL><DT><DD></DL><P>
<A NAME="valid"></A>
<A NAME="DOC.2.92.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const bool valid() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="asVec4"></A>
<A NAME="DOC.2.92.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   <!1><A HREF="Vec4.html">Vec4</A>&amp; asVec4()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="asVec4"></A>
<A NAME="DOC.2.92.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const <!1><A HREF="Vec4.html">Vec4</A>&amp; asVec4() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="operator [] "></A>
<A NAME="DOC.2.92.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   float&amp; operator [] (const int i)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="operator [] "></A>
<A NAME="DOC.2.92.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   float operator [] (const int i) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getNormal"></A>
<A NAME="DOC.2.92.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   <!1><A HREF="Vec3.html">osg::Vec3</A> getNormal()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="distance"></A>
<A NAME="DOC.2.92.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const float distance(const <!1><A HREF="Vec3.html">osg::Vec3</A>&amp; v) const </B></TT>
<DD>calculate the distance between a point and the plane
<DL><DT><DD></DL><P>
<A NAME="intersect"></A>
<A NAME="DOC.2.92.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const int intersect(const std::vector&lt;<!1><A HREF="Vec3.html">Vec3</A>&gt;&amp; vertices) const </B></TT>
<DD>intersection test between plane and vertex list
return 1 if the bs is completely above plane,
return 0 if the bs intersects the plane,
return -1 if the bs is completely below the plane
<DL><DT><DD></DL><P>
<A NAME="intersect"></A>
<A NAME="DOC.2.92.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const int intersect(const <!1><A HREF="BoundingSphere.html">BoundingSphere</A>&amp; bs) const </B></TT>
<DD>intersection test between plane and bounding sphere.
return 1 if the bs is completely above plane,
return 0 if the bs intersects the plane,
return -1 if the bs is completely below the plane.
<DL><DT><DD></DL><P>
<A NAME="intersect"></A>
<A NAME="DOC.2.92.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const int intersect(const <!1><A HREF="BoundingBox.html">BoundingBox</A>&amp; bb) const </B></TT>
<DD>intersection test between plane and bounding sphere.
return 1 if the bs is completely above plane,
return 0 if the bs intersects the plane,
return -1 if the bs is completely below the plane.
<DL><DT><DD></DL><P>
<A NAME="transform"></A>
<A NAME="DOC.2.92.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void transform(const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; matrix)</B></TT>
<DD>Transform the plane by matrix.  Note, this operations carries out
the calculation of the inverse of the matrix since to transforms
planes must be multiplied my the inverse transposed. This
make this operation expensive.  If the inverse has been already
calculated elsewhere then use transformProvidingInverse() instead.
See http://www.worldserver.com/turk/computergraphics/NormalTransformations.pdf
<DL><DT><DD></DL><P>
<A NAME="transformProvidingInverse"></A>
<A NAME="DOC.2.92.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void transformProvidingInverse(const <!1><A HREF="Matrix.html">osg::Matrix</A>&amp; matrix)</B></TT>
<DD>Transform the plane by provide a pre inverted matrix.
see transform for details. 
<DL><DT><DD></DL><P>
<A NAME="_fv"></A>
<A NAME="DOC.2.92.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Vec4.html">Vec4</A> _fv</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_upperBBCorner"></A>
<A NAME="DOC.2.92.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int _upperBBCorner</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_lowerBBCorner"></A>
<A NAME="DOC.2.92.30"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int _lowerBBCorner</B></TT>
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DT><B>Friends:</B><DD>  inline std::ostream& operator << (std::ostream& output, const <!1><A HREF="Plane.html">Plane</A>& pl)<BR><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
