<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::Texture</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.6">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::Texture</A></H2></H2><BLOCKQUOTE>Texture base class which encapsulates OpenGl texture functionality which common betweent the various types of OpenGL textures</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=275>
<param name=classes value="CReferenced,MReferenced.html,CObject,MObject.html,CStateAttribute,MStateAttribute.html,CTexture,MTexture.html,CTextureRectangle,MTextureRectangle.html,CTextureCubeMap,MTextureCubeMap.html,CTexture3D,MTexture3D.html,CTexture2D,MTexture2D.html,CTexture1D,MTexture1D.html">
<param name=before value="M,M,M,M,M|_,MR_,MR_,MR_,Mr_">
<param name=after value="Md_SPSP,Md_SP,Md_,M,M,M,M,M,M">
<param name=indent value="0,1,2,3,3,3,3,3,3">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Classes</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>enum  <B><A HREF="#DOC.2.240.10">WrapParameter</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>enum  <B><A HREF="#DOC.2.240.11">WrapMode</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>enum  <B><A HREF="#DOC.2.240.18">FilterParameter</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>enum  <B><A HREF="#DOC.2.240.19">FilterMode</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>enum  <B><A HREF="#DOC.2.240.30">InternalFormatMode</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>enum  <B><A HREF="#DOC.2.240.42">ShadowCompareFunc</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>enum  <B><A HREF="#DOC.2.240.45">ShadowTextureMode</A></B>
<DT>
class  SG_EXPORT <B><A HREF="Extensions.5.html">Extensions</A></B>: public <!1><A HREF="Referenced.html">osg::Referenced</A>
<DD><I>Extensions class which encapsulates the querring of extensions and associated function pointers, and provide convinience wrappers to  check for the extensions or use the associated functions</I>
<DT>
class  <B><A HREF="TextureObject.html">TextureObject</A></B>: public <!1><A HREF="Referenced.html">osg::Referenced</A>
<DT>
class  SG_EXPORT <B><A HREF="TextureObjectManager.html">TextureObjectManager</A></B>: public <!1><A HREF="Referenced.html">osg::Referenced</A>
</DL></P>

<P><DL>
<DT><H3>Public Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>mutable <!1><A HREF="Texture.html#DOC.2.240.92">TextureObjectBuffer</A> <B><A HREF="#DOC.2.240.93">_textureObjectBuffer</A></B>
</DL></P>

<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.240.1">Texture</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.240.2">Texture</A></B>(const <!1><A HREF="Texture.html#DOC.2.240.2">Texture</A>&amp; text, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)
<DD><I>Copy constructor using CopyOp to manage deep vs shallow copy</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <!1><A HREF="Object.html">osg::Object</A>* <B><A HREF="#DOC.2.240.3">cloneType</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <!1><A HREF="Object.html">osg::Object</A>* <B><A HREF="#DOC.2.240.4">clone</A></B>(const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.240.5">isSameKindAs</A></B>(const <!1><A HREF="Object.html">osg::Object</A>* obj) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const char* <B><A HREF="#DOC.2.240.6">libraryName</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const char* <B><A HREF="#DOC.2.240.7">className</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <!1><A HREF="StateAttribute.html#DOC.2.229.5">Type</A> <B><A HREF="#DOC.2.240.8">getType</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.240.9">isTextureAttribute</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.12">setWrap</A></B>(<!1><A HREF="Texture.html#DOC.2.240.10">WrapParameter</A> which, <!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> wrap)
<DD><I>Set the texture wrap mode</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> <B><A HREF="#DOC.2.240.13">getWrap</A></B>(<!1><A HREF="Texture.html#DOC.2.240.10">WrapParameter</A> which) const 
<DD><I>Get the texture wrap mode</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.14">setBorderColor</A></B>(const <!1><A HREF="osg.html#DOC.2.270">Vec4</A>&amp; color)
<DD><I>Set the border color for this texture.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="osg.html#DOC.2.270">Vec4</A>&amp; <B><A HREF="#DOC.2.240.15">getBorderColor</A></B>() const 
<DD><I>Get the border color for this texture</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.16">setBorderWidth</A></B>(GLint <!1><A HREF="Viewport.html#DOC.2.278.10">width</A>)
<DD><I>Set the border width</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>GLint <B><A HREF="#DOC.2.240.17">getBorderWidth</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.20">setFilter</A></B>(<!1><A HREF="Texture.html#DOC.2.240.18">FilterParameter</A> which, <!1><A HREF="Texture.html#DOC.2.240.19">FilterMode</A> filter)
<DD><I>Set the texture filter mode</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.19">FilterMode</A> <B><A HREF="#DOC.2.240.21">getFilter</A></B>(<!1><A HREF="Texture.html#DOC.2.240.18">FilterParameter</A> which) const 
<DD><I>Get the texture filter mode</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.22">setMaxAnisotropy</A></B>(float anis)
<DD><I>Set the maximum anisotropy value, default value is 10 for no anisotropic filtering.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   float <B><A HREF="#DOC.2.240.23">getMaxAnisotropy</A></B>() const 
<DD><I>Get the maximum anisotropy value</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.240.24">setUseHardwareMipMapGeneration</A></B>(bool useHardwareMipMapGeneration)
<DD><I>Set the hint of whether to use hardware mip map generation where available</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.240.25">getUseHardwareMipMapGeneration</A></B>() const 
<DD><I>Get the hint of whether to use hardware mip map generation where available</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.240.26">setUnRefImageDataAfterApply</A></B>(bool flag)
<DD><I>Set the automatic unreference of image data after the texture has been set up in apply, on (true) or off (false).</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.240.27">getUnRefImageDataAfterApply</A></B>() const 
<DD><I>Get the automatic unreference of image data after the texture has been set up in apply</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.240.28">setClientStorageHint</A></B>(bool flag)
<DD><I>Set whether to use client storage of the texture where supported by OpenGL drivers.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.240.29">getClientStorageHint</A></B>() const 
<DD><I>Get whether to use client storage of the texture where supported by OpenGL drivers</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.240.31">setInternalFormatMode</A></B>(<!1><A HREF="Texture.html#DOC.2.240.30">InternalFormatMode</A> mode)
<DD><I>Set the internal format mode.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <!1><A HREF="Texture.html#DOC.2.240.30">InternalFormatMode</A> <B><A HREF="#DOC.2.240.32">getInternalFormatMode</A></B>() const 
<DD><I>Get the internal format mode</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.240.33">setInternalFormat</A></B>(GLint internalFormat)
<DD><I>Set the internal format to use when creating OpenGL textures.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   GLint <B><A HREF="#DOC.2.240.34">getInternalFormat</A></B>() const 
<DD><I>Get the internal format to use when creating OpenGL textures</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.240.35">isCompressedInternalFormat</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   <!1><A HREF="TextureObject.html">TextureObject</A>* <B><A HREF="#DOC.2.240.36">getTextureObject</A></B>(unsigned int contextID) const 
<DD><I>Get the handle to the texture object for the current context</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.37">dirtyTextureObject</A></B>()
<DD><I>Force a recompile on next apply() of associated OpenGL texture objects</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.240.38">areAllTextureObjectsLoaded</A></B>() const 
<DD><I>return true if the texture objects for all the required graphics contexts are loaded</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int&amp; <B><A HREF="#DOC.2.240.39">getTextureParameterDirty</A></B>(unsigned int contextID) const 
<DD><I>get the dirty flag for the current contextID</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.40">dirtyTextureParameters</A></B>()
<DD><I>Force a resetting on next apply() of associated OpenGL texture parameters</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.41">setShadowComparison</A></B>(bool flag)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.43">setShadowCompareFunc</A></B>(<!1><A HREF="Texture.html#DOC.2.240.42">ShadowCompareFunc</A> func)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.42">ShadowCompareFunc</A> <B><A HREF="#DOC.2.240.44">getShadowCompareFunc</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.46">setShadowTextureMode</A></B>(<!1><A HREF="Texture.html#DOC.2.240.45">ShadowTextureMode</A> mode)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.45">ShadowTextureMode</A> <B><A HREF="#DOC.2.240.47">getShadowTextureMode</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.48">setShadowAmbient</A></B>(float shadow_ambient)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>float <B><A HREF="#DOC.2.240.49">getShadowAmbient</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.240.50">setImage</A></B>(unsigned int face, <!1><A HREF="Image.html">Image</A>* image)
<DD><I>Set the texture image for specified face.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <!1><A HREF="Image.html">Image</A>* <B><A HREF="#DOC.2.240.51">getImage</A></B>(unsigned int face)
<DD><I>Get the texture image for specified face.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const <!1><A HREF="Image.html">Image</A>* <B><A HREF="#DOC.2.240.52">getImage</A></B>(unsigned int face) const 
<DD><I>Get the const texture image for specified face.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   unsigned int <B><A HREF="#DOC.2.240.53">getNumImages</A></B>() const 
<DD><I>Get the number of images that can be assigned to the Texture.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.240.54">apply</A></B>(<!1><A HREF="State.html">State</A>&amp; state) const 
<DD><I>Texture is pure virtual base class, apply must be overriden.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.240.55">compileGLObjects</A></B>(<!1><A HREF="State.html">State</A>&amp; state) const 
<DD><I>Calls apply(state) to compile the texture.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.240.56">releaseGLObjects</A></B>(<!1><A HREF="State.html">State</A>* state=0) const 
<DD><I>release an OpenGL objects in specified graphics context if State object is passed, otherwise release OpenGL objexts for all graphics context if State object pointer NULL</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   <!1><A HREF="Extensions.5.html">Extensions</A>* <B><A HREF="#DOC.2.240.58">getExtensions</A></B>(unsigned int contextID, bool createIfNotInitalized)
<DD><I>Function to call to get the extension of a specified context.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   void <B><A HREF="#DOC.2.240.59">setExtensions</A></B>(unsigned int contextID, <!1><A HREF="Extensions.5.html">Extensions</A>* extensions)
<DD><I>setExtensions allows users to override the extensions across graphics contexts.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.60">applyTexImage2D_load</A></B>(<!1><A HREF="State.html">State</A>&amp; state, GLenum target, const <!1><A HREF="Image.html">Image</A>* image, GLsizei <!1><A HREF="Viewport.html#DOC.2.278.10">width</A>, GLsizei <!1><A HREF="Viewport.html#DOC.2.278.11">height</A>, GLsizei numMipmapLevels) const 
<DD><I>Helper method which does the creation of the texture itself, but does not set or use texture binding.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.61">applyTexImage2D_subload</A></B>(<!1><A HREF="State.html">State</A>&amp; state, GLenum target, const <!1><A HREF="Image.html">Image</A>* image, GLsizei <!1><A HREF="Viewport.html#DOC.2.278.10">width</A>, GLsizei <!1><A HREF="Viewport.html#DOC.2.278.11">height</A>, GLint inInternalFormat, GLsizei numMipmapLevels) const 
<DD><I>Helper method which subloads images to the texture itself, but does not set or use texture binding.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.91">takeTextureObjects</A></B>(<!1><A HREF="Texture.html#DOC.2.240.90">TextureObjectListMap</A>&amp; toblm)
<DD><I>take the active texture objects from the Texture and place them in the specified TextureObjectListMap</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   void <B><A HREF="#DOC.2.240.95">setTextureObjectManager</A></B>(<!1><A HREF="TextureObjectManager.html">TextureObjectManager</A>* tom)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   <!1><A HREF="TextureObjectManager.html">TextureObjectManager</A>* <B><A HREF="#DOC.2.240.96">getTextureObjectManager</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   void <B><A HREF="#DOC.2.240.97">flushTextureObjects</A></B>(unsigned int contextID, double currentTime, double&amp; availableTime)
</DL></P>

<P><DL>
<DT><H3>Public</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::list&lt; <!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="TextureObject.html">TextureObject</A>&gt; &gt;  <B><A HREF="#DOC.2.240.89">TextureObjectList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::map&lt;unsigned int, <!1><A HREF="Texture.html#DOC.2.240.89">TextureObjectList</A> &gt;  <B><A HREF="#DOC.2.240.90">TextureObjectListMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  <!1><A HREF="buffered_object.html">buffered_object</A>&lt; <!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="TextureObject.html">TextureObject</A>&gt; &gt;  <B><A HREF="#DOC.2.240.92">TextureObjectBuffer</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>mutable <!1><A HREF="Texture.html#DOC.2.240.69">TexParameterDirtyList</A> <B><A HREF="#DOC.2.240.70">_texParametersDirtyList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> <B><A HREF="#DOC.2.240.71">_wrap_s</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> <B><A HREF="#DOC.2.240.72">_wrap_t</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> <B><A HREF="#DOC.2.240.73">_wrap_r</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.19">FilterMode</A> <B><A HREF="#DOC.2.240.74">_min_filter</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.19">FilterMode</A> <B><A HREF="#DOC.2.240.75">_mag_filter</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>float <B><A HREF="#DOC.2.240.76">_maxAnisotropy</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.240.77">_useHardwareMipMapGeneration</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.240.78">_unrefImageDataAfterApply</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.240.79">_clientStorageHint</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="osg.html#DOC.2.270">Vec4</A> <B><A HREF="#DOC.2.240.80">_borderColor</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>GLint <B><A HREF="#DOC.2.240.81">_borderWidth</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.30">InternalFormatMode</A> <B><A HREF="#DOC.2.240.82">_internalFormatMode</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>mutable GLint <B><A HREF="#DOC.2.240.83">_internalFormat</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.240.84">_use_shadow_comparison</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.42">ShadowCompareFunc</A> <B><A HREF="#DOC.2.240.85">_shadow_compare_func</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Texture.html#DOC.2.240.45">ShadowTextureMode</A> <B><A HREF="#DOC.2.240.86">_shadow_texture_mode</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>float <B><A HREF="#DOC.2.240.87">_shadow_ambient</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.240.62">~Texture</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.240.63">computeInternalFormat</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.64">computeInternalFormatWithImage</A></B>(const <!1><A HREF="Image.html">osg::Image</A>&amp; image) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.65">computeRequiredTextureDimensions</A></B>(<!1><A HREF="State.html">State</A>&amp; state, const <!1><A HREF="Image.html">osg::Image</A>&amp; image, GLsizei&amp; <!1><A HREF="Viewport.html#DOC.2.278.10">width</A>, GLsizei&amp; <!1><A HREF="Viewport.html#DOC.2.278.11">height</A>, GLsizei&amp; numMipmapLevels) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.240.66">isCompressedInternalFormat</A></B>(GLint internalFormat) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.240.67">applyTexParameters</A></B>(GLenum target, <!1><A HREF="State.html">State</A>&amp; state) const 
<DD><I>Helper method which does setting of texture paramters.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.2.240.68">compareTexture</A></B>(const <!1><A HREF="Texture.html">Texture</A>&amp; rhs) const 
<DD><I>return -1 if *this < *rhs, 0 if *this==*rhs, 1 if *this>*rhs</I>
</DL></P>

<P><DL>
<DT><H3>Protected</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  <!1><A HREF="buffered_value.html">buffered_value</A>&lt;unsigned int&gt;  <B><A HREF="#DOC.2.240.69">TexParameterDirtyList</A></B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="StateAttribute.html">StateAttribute</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Classes</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>enum  <B>Values</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>enum  <B>Types</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>struct  <B>ModeUsage</B>
</DL></P>

<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>virtual   int <B>compare</B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>&amp; sa) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>bool <B>operator <  </B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>&amp; rhs) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>bool <B>operator == </B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>&amp; rhs) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>bool <B>operator != </B>(const <!1><A HREF="StateAttribute.html">StateAttribute</A>&amp; rhs) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   bool <B>getModeUsage</B>(<!1><A HREF="StateAttribute.html#DOC.2.229.20">ModeUsage</A>&amp;) const 
</DL></P>

<P><DL>
<DT><H3>Public</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>typedef  GLenum <B>GLMode</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>typedef  unsigned int <B>GLModeValue</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>typedef  unsigned int <B>OverrideValue</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>typedef  unsigned int <B>Type</B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Object.html">Object</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Classes</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>enum  <B>DataVariance</B>
</DL></P>

<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setDataVariance</B>(<!1><A HREF="Object.html#DOC.2.167.8">DataVariance</A> dv)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Object.html#DOC.2.167.8">DataVariance</A> <B>getDataVariance</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setUserData</B>(<!1><A HREF="Referenced.html">Referenced</A>* obj)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Referenced.html">Referenced</A>* <B>getUserData</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="Referenced.html">Referenced</A>* <B>getUserData</B>() const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="Object.html#DOC.2.167.8">DataVariance</A> <B>_dataVariance</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="Referenced.html">Referenced</A>&gt;  <B>_userData</B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Referenced.html">Referenced</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Referenced.html">Referenced</A>&amp; <B>operator = </B>(const <!1><A HREF="Referenced.html">Referenced</A>&amp;)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   void <B>setDeleteHandler</B>(<!1><A HREF="DeleteHandler.html">DeleteHandler</A>* handler)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   <!1><A HREF="DeleteHandler.html">DeleteHandler</A>* <B>getDeleteHandler</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>ref</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref_nodelete</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   int <B>referenceCount</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref</B>() const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>mutable OpenThreads::Mutex <B>_refMutex</B>
<DT>
<IMG ALT="o" SRC=icon2.gif>mutable int <B>_refCount</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>Texture base class which encapsulates OpenGl texture functionality which common betweent the various types of OpenGL textures</BLOCKQUOTE>
<DL>

<A NAME="Texture"></A>
<A NAME="DOC.2.240.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Texture()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Texture"></A>
<A NAME="DOC.2.240.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Texture(const <!1><A HREF="Texture.html#DOC.2.240.2">Texture</A>&amp; text, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)</B></TT>
<DD>Copy constructor using CopyOp to manage deep vs shallow copy
<DL><DT><DD></DL><P>
<A NAME="cloneType"></A>
<A NAME="DOC.2.240.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="Object.html">osg::Object</A>* cloneType() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="clone"></A>
<A NAME="DOC.2.240.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="Object.html">osg::Object</A>* clone(const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="isSameKindAs"></A>
<A NAME="DOC.2.240.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool isSameKindAs(const <!1><A HREF="Object.html">osg::Object</A>* obj) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="libraryName"></A>
<A NAME="DOC.2.240.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const char* libraryName() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="className"></A>
<A NAME="DOC.2.240.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const char* className() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getType"></A>
<A NAME="DOC.2.240.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="StateAttribute.html#DOC.2.229.5">Type</A> getType() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="isTextureAttribute"></A>
<A NAME="DOC.2.240.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool isTextureAttribute() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="WrapParameter"></A>
<A NAME="DOC.2.240.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  WrapParameter</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="WRAP_S"></A>
<A NAME="DOC.2.240.10.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> WRAP_S</B></TT>
<DL><DT><DD></DL><P>
<A NAME="WRAP_T"></A>
<A NAME="DOC.2.240.10.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> WRAP_T</B></TT>
<DL><DT><DD></DL><P>
<A NAME="WRAP_R"></A>
<A NAME="DOC.2.240.10.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> WRAP_R</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="WrapMode"></A>
<A NAME="DOC.2.240.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  WrapMode</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="CLAMP"></A>
<A NAME="DOC.2.240.11.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> CLAMP</B></TT>
<DL><DT><DD></DL><P>
<A NAME="CLAMP_TO_EDGE"></A>
<A NAME="DOC.2.240.11.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> CLAMP_TO_EDGE</B></TT>
<DL><DT><DD></DL><P>
<A NAME="CLAMP_TO_BORDER"></A>
<A NAME="DOC.2.240.11.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> CLAMP_TO_BORDER</B></TT>
<DL><DT><DD></DL><P>
<A NAME="REPEAT"></A>
<A NAME="DOC.2.240.11.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> REPEAT</B></TT>
<DL><DT><DD></DL><P>
<A NAME="MIRROR"></A>
<A NAME="DOC.2.240.11.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> MIRROR</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="setWrap"></A>
<A NAME="DOC.2.240.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setWrap(<!1><A HREF="Texture.html#DOC.2.240.10">WrapParameter</A> which, <!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> wrap)</B></TT>
<DD>Set the texture wrap mode
<DL><DT><DD></DL><P>
<A NAME="getWrap"></A>
<A NAME="DOC.2.240.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> getWrap(<!1><A HREF="Texture.html#DOC.2.240.10">WrapParameter</A> which) const </B></TT>
<DD>Get the texture wrap mode
<DL><DT><DD></DL><P>
<A NAME="setBorderColor"></A>
<A NAME="DOC.2.240.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setBorderColor(const <!1><A HREF="osg.html#DOC.2.270">Vec4</A>&amp; color)</B></TT>
<DD>Set the border color for this texture. Makes difference only if
wrap mode is CLAMP_TO_BORDER 
<DL><DT><DD></DL><P>
<A NAME="getBorderColor"></A>
<A NAME="DOC.2.240.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="osg.html#DOC.2.270">Vec4</A>&amp; getBorderColor() const </B></TT>
<DD>Get the border color for this texture
<DL><DT><DD></DL><P>
<A NAME="setBorderWidth"></A>
<A NAME="DOC.2.240.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setBorderWidth(GLint <!1><A HREF="Viewport.html#DOC.2.278.10">width</A>)</B></TT>
<DD>Set the border width
<DL><DT><DD></DL><P>
<A NAME="getBorderWidth"></A>
<A NAME="DOC.2.240.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>GLint getBorderWidth() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="FilterParameter"></A>
<A NAME="DOC.2.240.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  FilterParameter</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="MIN_FILTER"></A>
<A NAME="DOC.2.240.18.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> MIN_FILTER</B></TT>
<DL><DT><DD></DL><P>
<A NAME="MAG_FILTER"></A>
<A NAME="DOC.2.240.18.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> MAG_FILTER</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="FilterMode"></A>
<A NAME="DOC.2.240.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  FilterMode</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="LINEAR"></A>
<A NAME="DOC.2.240.19.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> LINEAR</B></TT>
<DL><DT><DD></DL><P>
<A NAME="LINEAR_MIPMAP_LINEAR"></A>
<A NAME="DOC.2.240.19.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> LINEAR_MIPMAP_LINEAR</B></TT>
<DL><DT><DD></DL><P>
<A NAME="LINEAR_MIPMAP_NEAREST"></A>
<A NAME="DOC.2.240.19.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> LINEAR_MIPMAP_NEAREST</B></TT>
<DL><DT><DD></DL><P>
<A NAME="NEAREST"></A>
<A NAME="DOC.2.240.19.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> NEAREST</B></TT>
<DL><DT><DD></DL><P>
<A NAME="NEAREST_MIPMAP_LINEAR"></A>
<A NAME="DOC.2.240.19.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> NEAREST_MIPMAP_LINEAR</B></TT>
<DL><DT><DD></DL><P>
<A NAME="NEAREST_MIPMAP_NEAREST"></A>
<A NAME="DOC.2.240.19.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> NEAREST_MIPMAP_NEAREST</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="setFilter"></A>
<A NAME="DOC.2.240.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setFilter(<!1><A HREF="Texture.html#DOC.2.240.18">FilterParameter</A> which, <!1><A HREF="Texture.html#DOC.2.240.19">FilterMode</A> filter)</B></TT>
<DD>Set the texture filter mode
<DL><DT><DD></DL><P>
<A NAME="getFilter"></A>
<A NAME="DOC.2.240.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.19">FilterMode</A> getFilter(<!1><A HREF="Texture.html#DOC.2.240.18">FilterParameter</A> which) const </B></TT>
<DD>Get the texture filter mode
<DL><DT><DD></DL><P>
<A NAME="setMaxAnisotropy"></A>
<A NAME="DOC.2.240.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setMaxAnisotropy(float anis)</B></TT>
<DD>Set the maximum anisotropy value, default value is 10 for
no anisotropic filtering.  If hardware does not support anisotropic
filtering then normal filtering is used, equivilant to a max anisotropy value of 1.0.
valid range is 1.0f upwards.  The maximum value depends on the graphics
system being used.
<DL><DT><DD></DL><P>
<A NAME="getMaxAnisotropy"></A>
<A NAME="DOC.2.240.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   float getMaxAnisotropy() const </B></TT>
<DD>Get the maximum anisotropy value
<DL><DT><DD></DL><P>
<A NAME="setUseHardwareMipMapGeneration"></A>
<A NAME="DOC.2.240.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setUseHardwareMipMapGeneration(bool useHardwareMipMapGeneration)</B></TT>
<DD>Set the hint of whether to use hardware mip map generation where available
<DL><DT><DD></DL><P>
<A NAME="getUseHardwareMipMapGeneration"></A>
<A NAME="DOC.2.240.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool getUseHardwareMipMapGeneration() const </B></TT>
<DD>Get the hint of whether to use hardware mip map generation where available
<DL><DT><DD></DL><P>
<A NAME="setUnRefImageDataAfterApply"></A>
<A NAME="DOC.2.240.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setUnRefImageDataAfterApply(bool flag)</B></TT>
<DD>Set the automatic unreference of image data after the texture has been set up in apply, on (true) or off (false).
If the image data is only referened by this Texture then the image data will be autoamtically deleted.
<DL><DT><DD></DL><P>
<A NAME="getUnRefImageDataAfterApply"></A>
<A NAME="DOC.2.240.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool getUnRefImageDataAfterApply() const </B></TT>
<DD>Get the automatic unreference of image data after the texture has been set up in apply
<DL><DT><DD></DL><P>
<A NAME="setClientStorageHint"></A>
<A NAME="DOC.2.240.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setClientStorageHint(bool flag)</B></TT>
<DD>Set whether to use client storage of the texture where supported by OpenGL drivers.
Note, if UseClientStorageHint is set, and the OpenGL drivers support it, the osg::Image(s) associated with
this texture cannot be deleted, so the UnRefImageDataAfterApply flag is then ignored.
<DL><DT><DD></DL><P>
<A NAME="getClientStorageHint"></A>
<A NAME="DOC.2.240.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool getClientStorageHint() const </B></TT>
<DD>Get whether to use client storage of the texture where supported by OpenGL drivers
<DL><DT><DD></DL><P>
<A NAME="InternalFormatMode"></A>
<A NAME="DOC.2.240.30"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  InternalFormatMode</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="USE_IMAGE_DATA_FORMAT"></A>
<A NAME="DOC.2.240.30.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> USE_IMAGE_DATA_FORMAT</B></TT>
<DL><DT><DD></DL><P>
<A NAME="USE_USER_DEFINED_FORMAT"></A>
<A NAME="DOC.2.240.30.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> USE_USER_DEFINED_FORMAT</B></TT>
<DL><DT><DD></DL><P>
<A NAME="USE_ARB_COMPRESSION"></A>
<A NAME="DOC.2.240.30.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> USE_ARB_COMPRESSION</B></TT>
<DL><DT><DD></DL><P>
<A NAME="USE_S3TC_DXT1_COMPRESSION"></A>
<A NAME="DOC.2.240.30.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> USE_S3TC_DXT1_COMPRESSION</B></TT>
<DL><DT><DD></DL><P>
<A NAME="USE_S3TC_DXT3_COMPRESSION"></A>
<A NAME="DOC.2.240.30.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> USE_S3TC_DXT3_COMPRESSION</B></TT>
<DL><DT><DD></DL><P>
<A NAME="USE_S3TC_DXT5_COMPRESSION"></A>
<A NAME="DOC.2.240.30.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> USE_S3TC_DXT5_COMPRESSION</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="setInternalFormatMode"></A>
<A NAME="DOC.2.240.31"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setInternalFormatMode(<!1><A HREF="Texture.html#DOC.2.240.30">InternalFormatMode</A> mode)</B></TT>
<DD>Set the internal format mode.
Note, If the mode is set USE_IMAGE_DATA_FORMAT, USE_ARB_COMPRESSION,
USE_S3TC_COMPRESSION the internalFormat is automatically selected,
and will overwrite the previous _internalFormat.
<DL><DT><DD></DL><P>
<A NAME="getInternalFormatMode"></A>
<A NAME="DOC.2.240.32"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   <!1><A HREF="Texture.html#DOC.2.240.30">InternalFormatMode</A> getInternalFormatMode() const </B></TT>
<DD>Get the internal format mode
<DL><DT><DD></DL><P>
<A NAME="setInternalFormat"></A>
<A NAME="DOC.2.240.33"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setInternalFormat(GLint internalFormat)</B></TT>
<DD>Set the internal format to use when creating OpenGL textures.
Also sets the internalFormatMode to USE_USER_DEFINED_FORMAT.
<DL><DT><DD></DL><P>
<A NAME="getInternalFormat"></A>
<A NAME="DOC.2.240.34"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   GLint getInternalFormat() const </B></TT>
<DD>Get the internal format to use when creating OpenGL textures
<DL><DT><DD></DL><P>
<A NAME="isCompressedInternalFormat"></A>
<A NAME="DOC.2.240.35"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool isCompressedInternalFormat() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getTextureObject"></A>
<A NAME="DOC.2.240.36"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   <!1><A HREF="TextureObject.html">TextureObject</A>* getTextureObject(unsigned int contextID) const </B></TT>
<DD>Get the handle to the texture object for the current context
<DL><DT><DD></DL><P>
<A NAME="dirtyTextureObject"></A>
<A NAME="DOC.2.240.37"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void dirtyTextureObject()</B></TT>
<DD>Force a recompile on next apply() of associated OpenGL texture objects
<DL><DT><DD></DL><P>
<A NAME="areAllTextureObjectsLoaded"></A>
<A NAME="DOC.2.240.38"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool areAllTextureObjectsLoaded() const </B></TT>
<DD>return true if the texture objects for all the required graphics contexts are loaded
<DL><DT><DD></DL><P>
<A NAME="getTextureParameterDirty"></A>
<A NAME="DOC.2.240.39"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int&amp; getTextureParameterDirty(unsigned int contextID) const </B></TT>
<DD>get the dirty flag for the current contextID
<DL><DT><DD></DL><P>
<A NAME="dirtyTextureParameters"></A>
<A NAME="DOC.2.240.40"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void dirtyTextureParameters()</B></TT>
<DD>Force a resetting on next apply() of associated OpenGL texture parameters
<DL><DT><DD></DL><P>
<A NAME="setShadowComparison"></A>
<A NAME="DOC.2.240.41"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setShadowComparison(bool flag)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ShadowCompareFunc"></A>
<A NAME="DOC.2.240.42"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  ShadowCompareFunc</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="LEQUAL"></A>
<A NAME="DOC.2.240.42.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> LEQUAL</B></TT>
<DL><DT><DD></DL><P>
<A NAME="GEQUAL"></A>
<A NAME="DOC.2.240.42.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GEQUAL</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="setShadowCompareFunc"></A>
<A NAME="DOC.2.240.43"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setShadowCompareFunc(<!1><A HREF="Texture.html#DOC.2.240.42">ShadowCompareFunc</A> func)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getShadowCompareFunc"></A>
<A NAME="DOC.2.240.44"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.42">ShadowCompareFunc</A> getShadowCompareFunc()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ShadowTextureMode"></A>
<A NAME="DOC.2.240.45"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  ShadowTextureMode</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="LUMINANCE"></A>
<A NAME="DOC.2.240.45.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> LUMINANCE</B></TT>
<DL><DT><DD></DL><P>
<A NAME="INTENSITY"></A>
<A NAME="DOC.2.240.45.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> INTENSITY</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ALPHA"></A>
<A NAME="DOC.2.240.45.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> ALPHA</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="setShadowTextureMode"></A>
<A NAME="DOC.2.240.46"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setShadowTextureMode(<!1><A HREF="Texture.html#DOC.2.240.45">ShadowTextureMode</A> mode)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getShadowTextureMode"></A>
<A NAME="DOC.2.240.47"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.45">ShadowTextureMode</A> getShadowTextureMode()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setShadowAmbient"></A>
<A NAME="DOC.2.240.48"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setShadowAmbient(float shadow_ambient)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getShadowAmbient"></A>
<A NAME="DOC.2.240.49"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>float getShadowAmbient()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setImage"></A>
<A NAME="DOC.2.240.50"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void setImage(unsigned int face, <!1><A HREF="Image.html">Image</A>* image)</B></TT>
<DD>Set the texture image for specified face. 
<DL><DT><DD></DL><P>
<A NAME="getImage"></A>
<A NAME="DOC.2.240.51"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="Image.html">Image</A>* getImage(unsigned int face)</B></TT>
<DD>Get the texture image for specified face. 
<DL><DT><DD></DL><P>
<A NAME="getImage"></A>
<A NAME="DOC.2.240.52"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const <!1><A HREF="Image.html">Image</A>* getImage(unsigned int face) const </B></TT>
<DD>Get the const texture image for specified face. 
<DL><DT><DD></DL><P>
<A NAME="getNumImages"></A>
<A NAME="DOC.2.240.53"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   unsigned int getNumImages() const </B></TT>
<DD>Get the number of images that can be assigned to the Texture. 
<DL><DT><DD></DL><P>
<A NAME="apply"></A>
<A NAME="DOC.2.240.54"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void apply(<!1><A HREF="State.html">State</A>&amp; state) const </B></TT>
<DD>Texture is pure virtual base class, apply must be overriden. 
<DL><DT><DD></DL><P>
<A NAME="compileGLObjects"></A>
<A NAME="DOC.2.240.55"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void compileGLObjects(<!1><A HREF="State.html">State</A>&amp; state) const </B></TT>
<DD>Calls apply(state) to compile the texture. 
<DL><DT><DD></DL><P>
<A NAME="releaseGLObjects"></A>
<A NAME="DOC.2.240.56"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void releaseGLObjects(<!1><A HREF="State.html">State</A>* state=0) const </B></TT>
<DD>release an OpenGL objects in specified graphics context if State
object is passed, otherwise release OpenGL objexts for all graphics context if
State object pointer NULL
<DL><DT><DD></DL><P>
<A NAME="getExtensions"></A>
<A NAME="DOC.2.240.58"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   <!1><A HREF="Extensions.5.html">Extensions</A>* getExtensions(unsigned int contextID, bool createIfNotInitalized)</B></TT>
<DD>Function to call to get the extension of a specified context.
If the Exentsion object for that context has not yet been created then 
and the 'createIfNotInitalized' flag been set to false then returns NULL.
If 'createIfNotInitalized' is true then the Extensions object is 
automatically created.  However, in this case the extension object 
only be created with the graphics context associated with ContextID..
<DL><DT><DD></DL><P>
<A NAME="setExtensions"></A>
<A NAME="DOC.2.240.59"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   void setExtensions(unsigned int contextID, <!1><A HREF="Extensions.5.html">Extensions</A>* extensions)</B></TT>
<DD>setExtensions allows users to override the extensions across graphics contexts.
typically used when you have different extensions supported across graphics pipes
but need to ensure that they all use the same low common denominator extensions.
<DL><DT><DD></DL><P>
<A NAME="applyTexImage2D_load"></A>
<A NAME="DOC.2.240.60"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void applyTexImage2D_load(<!1><A HREF="State.html">State</A>&amp; state, GLenum target, const <!1><A HREF="Image.html">Image</A>* image, GLsizei <!1><A HREF="Viewport.html#DOC.2.278.10">width</A>, GLsizei <!1><A HREF="Viewport.html#DOC.2.278.11">height</A>, GLsizei numMipmapLevels) const </B></TT>
<DD>Helper method which does the creation of the texture itself, but does not set or use texture binding. 
Note, do not call this method directly unless you are implementing your own Subload callback
<DL><DT><DD></DL><P>
<A NAME="applyTexImage2D_subload"></A>
<A NAME="DOC.2.240.61"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void applyTexImage2D_subload(<!1><A HREF="State.html">State</A>&amp; state, GLenum target, const <!1><A HREF="Image.html">Image</A>* image, GLsizei <!1><A HREF="Viewport.html#DOC.2.278.10">width</A>, GLsizei <!1><A HREF="Viewport.html#DOC.2.278.11">height</A>, GLint inInternalFormat, GLsizei numMipmapLevels) const </B></TT>
<DD>Helper method which subloads images to the texture itself, but does not set or use texture binding. 
Note, do not call this method directly unless you are implementing your own Subload callback
<DL><DT><DD></DL><P>
<A NAME="~Texture"></A>
<A NAME="DOC.2.240.62"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~Texture()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeInternalFormat"></A>
<A NAME="DOC.2.240.63"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void computeInternalFormat() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeInternalFormatWithImage"></A>
<A NAME="DOC.2.240.64"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void computeInternalFormatWithImage(const <!1><A HREF="Image.html">osg::Image</A>&amp; image) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeRequiredTextureDimensions"></A>
<A NAME="DOC.2.240.65"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void computeRequiredTextureDimensions(<!1><A HREF="State.html">State</A>&amp; state, const <!1><A HREF="Image.html">osg::Image</A>&amp; image, GLsizei&amp; <!1><A HREF="Viewport.html#DOC.2.278.10">width</A>, GLsizei&amp; <!1><A HREF="Viewport.html#DOC.2.278.11">height</A>, GLsizei&amp; numMipmapLevels) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="isCompressedInternalFormat"></A>
<A NAME="DOC.2.240.66"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool isCompressedInternalFormat(GLint internalFormat) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="applyTexParameters"></A>
<A NAME="DOC.2.240.67"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void applyTexParameters(GLenum target, <!1><A HREF="State.html">State</A>&amp; state) const </B></TT>
<DD>Helper method which does setting of texture paramters. 
<DL><DT><DD></DL><P>
<A NAME="compareTexture"></A>
<A NAME="DOC.2.240.68"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int compareTexture(const <!1><A HREF="Texture.html">Texture</A>&amp; rhs) const </B></TT>
<DD>return -1 if *this < *rhs, 0 if *this==*rhs, 1 if *this>*rhs
<DL><DT><DD></DL><P>
<A NAME="TexParameterDirtyList"></A>
<A NAME="DOC.2.240.69"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  <!1><A HREF="buffered_value.html">buffered_value</A>&lt;unsigned int&gt;  TexParameterDirtyList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_texParametersDirtyList"></A>
<A NAME="DOC.2.240.70"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>mutable <!1><A HREF="Texture.html#DOC.2.240.69">TexParameterDirtyList</A> _texParametersDirtyList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_wrap_s"></A>
<A NAME="DOC.2.240.71"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> _wrap_s</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_wrap_t"></A>
<A NAME="DOC.2.240.72"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> _wrap_t</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_wrap_r"></A>
<A NAME="DOC.2.240.73"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.11">WrapMode</A> _wrap_r</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_min_filter"></A>
<A NAME="DOC.2.240.74"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.19">FilterMode</A> _min_filter</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_mag_filter"></A>
<A NAME="DOC.2.240.75"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.19">FilterMode</A> _mag_filter</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_maxAnisotropy"></A>
<A NAME="DOC.2.240.76"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>float _maxAnisotropy</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_useHardwareMipMapGeneration"></A>
<A NAME="DOC.2.240.77"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _useHardwareMipMapGeneration</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_unrefImageDataAfterApply"></A>
<A NAME="DOC.2.240.78"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _unrefImageDataAfterApply</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_clientStorageHint"></A>
<A NAME="DOC.2.240.79"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _clientStorageHint</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_borderColor"></A>
<A NAME="DOC.2.240.80"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="osg.html#DOC.2.270">Vec4</A> _borderColor</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_borderWidth"></A>
<A NAME="DOC.2.240.81"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>GLint _borderWidth</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_internalFormatMode"></A>
<A NAME="DOC.2.240.82"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.30">InternalFormatMode</A> _internalFormatMode</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_internalFormat"></A>
<A NAME="DOC.2.240.83"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>mutable GLint _internalFormat</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_use_shadow_comparison"></A>
<A NAME="DOC.2.240.84"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _use_shadow_comparison</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_shadow_compare_func"></A>
<A NAME="DOC.2.240.85"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.42">ShadowCompareFunc</A> _shadow_compare_func</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_shadow_texture_mode"></A>
<A NAME="DOC.2.240.86"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Texture.html#DOC.2.240.45">ShadowTextureMode</A> _shadow_texture_mode</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_shadow_ambient"></A>
<A NAME="DOC.2.240.87"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>float _shadow_ambient</B></TT>
<DL><DT><DD></DL><P>
<A NAME="TextureObjectList"></A>
<A NAME="DOC.2.240.89"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::list&lt; <!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="TextureObject.html">TextureObject</A>&gt; &gt;  TextureObjectList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="TextureObjectListMap"></A>
<A NAME="DOC.2.240.90"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::map&lt;unsigned int, <!1><A HREF="Texture.html#DOC.2.240.89">TextureObjectList</A> &gt;  TextureObjectListMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="takeTextureObjects"></A>
<A NAME="DOC.2.240.91"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void takeTextureObjects(<!1><A HREF="Texture.html#DOC.2.240.90">TextureObjectListMap</A>&amp; toblm)</B></TT>
<DD>take the active texture objects from the Texture and place them in the specified TextureObjectListMap
<DL><DT><DD></DL><P>
<A NAME="TextureObjectBuffer"></A>
<A NAME="DOC.2.240.92"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  <!1><A HREF="buffered_object.html">buffered_object</A>&lt; <!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="TextureObject.html">TextureObject</A>&gt; &gt;  TextureObjectBuffer</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_textureObjectBuffer"></A>
<A NAME="DOC.2.240.93"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>mutable <!1><A HREF="Texture.html#DOC.2.240.92">TextureObjectBuffer</A> _textureObjectBuffer</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setTextureObjectManager"></A>
<A NAME="DOC.2.240.95"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   void setTextureObjectManager(<!1><A HREF="TextureObjectManager.html">TextureObjectManager</A>* tom)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getTextureObjectManager"></A>
<A NAME="DOC.2.240.96"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   <!1><A HREF="TextureObjectManager.html">TextureObjectManager</A>* getTextureObjectManager()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="flushTextureObjects"></A>
<A NAME="DOC.2.240.97"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   void flushTextureObjects(unsigned int contextID, double currentTime, double&amp; availableTime)</B></TT>
<DL><DT><DD></DL><P></DL>
<HR>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="TextureRectangle.html">TextureRectangle</A><BR>
<A HREF="TextureCubeMap.html">TextureCubeMap</A><BR>
<A HREF="Texture3D.html">Texture3D</A><BR>
<A HREF="Texture2D.html">Texture2D</A><BR>
<A HREF="Texture1D.html">Texture1D</A><BR>
</DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://www.linuxsupportline.com/~doc++">DOC++</A>.
</BODY>
</HTML>
