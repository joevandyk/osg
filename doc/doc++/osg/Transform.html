<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::Transform</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.8">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::Transform</A></H2></H2><BLOCKQUOTE>A Transform is a group node for which all children are transformed by a 4x4 matrix.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=185>
<param name=classes value="MNode,M,CGroup,MGroup.html,CTransform,MTransform.html,CPositionAttitudeTransform,MPositionAttitudeTransform.html,CMatrixTransform,MMatrixTransform.html,CDOFTransform,MDOFTransform.html">
<param name=before value="M,M,M,M|_,MR_,Mr_">
<param name=after value="Md_SP,Md_,M,M,M,M">
<param name=indent value="0,1,2,2,2,2">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.142.1">Transform</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.142.2">Transform</A></B>(const <!1><A HREF="Transform.html#DOC.2.142.2">Transform</A>&amp;, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)
<DD><I>Copy constructor using CopyOp to manage deep vs shallow copy</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.142.3">META_Node</A></B>(<!1><A HREF="osg.html">osg</A>, <!1><A HREF="Transform.html">Transform</A>)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.142.5">setReferenceFrame</A></B>(<!1><A HREF="Transform.html#DOC.2.142.4">ReferenceFrame</A> rf)
<DD><I>Set the transform's ReferenceFrame, either to be relative to its parent reference frame, or relative to an absolute coordinate frame.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="Transform.html#DOC.2.142.4">ReferenceFrame</A> <B><A HREF="#DOC.2.142.6">getReferenceFrame</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.142.8">setComputeTransformCallback</A></B>(<!1><A HREF="Transform.html#DOC.2.142.7">ComputeTransformCallback</A>* ctc)
<DD><I>Set the ComputerTransfromCallback which allows users to attach custom computation of the local transformation as seen by cull traversers and the like.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Transform.html#DOC.2.142.7">ComputeTransformCallback</A>* <B><A HREF="#DOC.2.142.9">getComputeTransformCallback</A></B>()
<DD><I>Get the non const ComputerTransfromCallback</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="Transform.html#DOC.2.142.7">ComputeTransformCallback</A>* <B><A HREF="#DOC.2.142.10">getComputeTransformCallback</A></B>() const 
<DD><I>Get the const ComputerTransfromCallback</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const bool <B><A HREF="#DOC.2.142.11">getLocalToWorldMatrix</A></B>(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>* nv) const 
<DD><I>Get the transformation matrix which moves from local coords to world coords.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const bool <B><A HREF="#DOC.2.142.12">getWorldToLocalMatrix</A></B>(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>* nv) const 
<DD><I>Get the transformation matrix which moves from world coords to local coords.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const bool <B><A HREF="#DOC.2.142.13">computeLocalToWorldMatrix</A></B>(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>*) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const bool <B><A HREF="#DOC.2.142.14">computeWorldToLocalMatrix</A></B>(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>*) const 
</DL></P>

<P><DL>
<DT><H3>Public Members</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>enum  <B><A HREF="#DOC.2.142.4">ReferenceFrame</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>struct  <B><A HREF="#DOC.2.142.7">ComputeTransformCallback</A></B>: public <!1><A HREF="Referenced.html">osg::Referenced</A>
<DD><I>Callback attached to an Transform to specify how to compute the modelview transformation for the transform below the Transform node.</I>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="Transform.html#DOC.2.142.7">ComputeTransformCallback</A>&gt;  <B><A HREF="#DOC.2.142.17">_computeTransformCallback</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Transform.html#DOC.2.142.4">ReferenceFrame</A> <B><A HREF="#DOC.2.142.18">_referenceFrame</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.142.15">~Transform</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const bool <B><A HREF="#DOC.2.142.16">computeBound</A></B>() const 
<DD><I>Overrides Group's computeBound.</I>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Group.html">Group</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>virtual   void <B>traverse</B>(<!1><A HREF="NodeVisitor.html">NodeVisitor</A>&amp; nv)
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   bool <B>addChild</B>( Node* child )
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   bool <B>removeChild</B>( Node* child )
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   bool <B>replaceChild</B>( Node* origChild, Node* newChild )
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const unsigned int <B>getNumChildren</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   Node* <B>getChild</B>( const unsigned int i )
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const Node* <B>getChild</B>( const unsigned int i ) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   bool <B>containsNode</B>( const Node* node ) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   ChildList::iterator <B>findNode</B>( const Node* node )
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   ChildList::const_iterator <B>findNode</B>( const Node* node ) const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>ChildList <B>_children</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>A Transform is a group node for which all children are transformed by
a 4x4 matrix.  It is often used for positioning objects within a scene,
producing trackball functionality or for animation.

<P>Transform itself does not provide set/get functions, only the interface
for defining what the 4x4 transformation is.  Subclasses, such as
MatrixTransform and PositionAttitudeTransform support the use of an
osg::Matrix or a osg::Vec3/osg::Quat resprectively.
The Transform node can be customized via the ComputeTransfromCallback
which can be attached to the node.  This might be used to convert from
internal representations of the transformation into generic osg::Matrix
objects which are used during scene grpah traversal, such as
CullTraversal and IntersectionTraversal.

<P>Note: if the transformation matrix scales the subgraph then the normals
of the underlying geometry will need to be renormalized to be unit
vectors once more.  This can be done transparently through OpenGL's 
use of either GL_NORMALIZE and GL_SCALE_NORMALIZE modes.  For further
background reading see the glNormalize documentation in the OpenGL
Reference Guide (the blue book). To enable it in the OSG, you simply
need to attach a local osg::StateSet to the osg::Transform, and set
the appropriate mode to ON via
stateset->setMode(GL_NORMALIZE, osg::StateAttribute::ON);</BLOCKQUOTE>
<DL>

<A NAME="Transform"></A>
<A NAME="DOC.2.142.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Transform()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Transform"></A>
<A NAME="DOC.2.142.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Transform(const <!1><A HREF="Transform.html#DOC.2.142.2">Transform</A>&amp;, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)</B></TT>
<DD>Copy constructor using CopyOp to manage deep vs shallow copy
<DL><DT><DD></DL><P>
<A NAME="META_Node"></A>
<A NAME="DOC.2.142.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> META_Node(<!1><A HREF="osg.html">osg</A>, <!1><A HREF="Transform.html">Transform</A>)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ReferenceFrame"></A>
<A NAME="DOC.2.142.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  ReferenceFrame</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="RELATIVE_TO_PARENTS"></A>
<A NAME="DOC.2.142.4.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> RELATIVE_TO_PARENTS</B></TT>
<DL><DT><DD></DL><P>
<A NAME="RELATIVE_TO_ABSOLUTE"></A>
<A NAME="DOC.2.142.4.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> RELATIVE_TO_ABSOLUTE</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="setReferenceFrame"></A>
<A NAME="DOC.2.142.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setReferenceFrame(<!1><A HREF="Transform.html#DOC.2.142.4">ReferenceFrame</A> rf)</B></TT>
<DD>Set the transform's ReferenceFrame, either to be relative to its
parent reference frame, or relative to an absolute coordinate
frame. RELATIVE_TO_PARENTS is the default.
Note: setting the ReferenceFrame to be RELATIVE_TO_ABSOLUTE will
also set the CullingActive flag on the transform, and hence all
of its parents, to false, thereby disabling culling of it and
all its parents.  This is neccessary to prevent inappropriate
culling, but may impact cull times if the absolute transform is
deep in the scene graph.  It is therefore recommend to only use
absolute Transforms at the top of the scene, for such things as
headlight LightSources or Heads up displays. 
<DL><DT><DD></DL><P>
<A NAME="getReferenceFrame"></A>
<A NAME="DOC.2.142.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="Transform.html#DOC.2.142.4">ReferenceFrame</A> getReferenceFrame() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="ComputeTransformCallback"></A>
<A NAME="DOC.2.142.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>struct  ComputeTransformCallback: public <!1><A HREF="Referenced.html">osg::Referenced</A></B></TT>
<DD>Callback attached to an Transform to specify how to compute the
modelview transformation for the transform below the Transform
node. 
<DL><DT><DD></DL><P><DL>

<A NAME="computeLocalToWorldMatrix"></A>
<A NAME="DOC.2.142.7.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const bool computeLocalToWorldMatrix(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, const <!1><A HREF="Transform.html">Transform</A>* <!1><A HREF="Polytope.html#DOC.2.97.32">transform</A>, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>* nv) const  = 0</B></TT>
<DD>Get the transformation matrix which moves from local coords
to world coords
<DL><DT><DD></DL><P>
<A NAME="computeWorldToLocalMatrix"></A>
<A NAME="DOC.2.142.7.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const bool computeWorldToLocalMatrix(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, const <!1><A HREF="Transform.html">Transform</A>* <!1><A HREF="Polytope.html#DOC.2.97.32">transform</A>, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>* nv) const  = 0</B></TT>
<DD>Get the transformation matrix which moves from world coords
to local coords
<DL><DT><DD></DL><P></DL>

<A NAME="setComputeTransformCallback"></A>
<A NAME="DOC.2.142.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setComputeTransformCallback(<!1><A HREF="Transform.html#DOC.2.142.7">ComputeTransformCallback</A>* ctc)</B></TT>
<DD>Set the ComputerTransfromCallback which allows users to attach
custom computation of the local transformation as seen by cull
traversers and the like. 
<DL><DT><DD></DL><P>
<A NAME="getComputeTransformCallback"></A>
<A NAME="DOC.2.142.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Transform.html#DOC.2.142.7">ComputeTransformCallback</A>* getComputeTransformCallback()</B></TT>
<DD>Get the non const ComputerTransfromCallback
<DL><DT><DD></DL><P>
<A NAME="getComputeTransformCallback"></A>
<A NAME="DOC.2.142.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="Transform.html#DOC.2.142.7">ComputeTransformCallback</A>* getComputeTransformCallback() const </B></TT>
<DD>Get the const ComputerTransfromCallback
<DL><DT><DD></DL><P>
<A NAME="getLocalToWorldMatrix"></A>
<A NAME="DOC.2.142.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const bool getLocalToWorldMatrix(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>* nv) const </B></TT>
<DD>Get the transformation matrix which moves from local coords to
world coords.
Returns true if the Matrix passed in has been updated. 
<DL><DT><DD></DL><P>
<A NAME="getWorldToLocalMatrix"></A>
<A NAME="DOC.2.142.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const bool getWorldToLocalMatrix(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>* nv) const </B></TT>
<DD>Get the transformation matrix which moves from world coords to
local coords.
Return true if the Matrix passed in has been updated. 
<DL><DT><DD></DL><P>
<A NAME="computeLocalToWorldMatrix"></A>
<A NAME="DOC.2.142.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const bool computeLocalToWorldMatrix(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>*) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeWorldToLocalMatrix"></A>
<A NAME="DOC.2.142.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const bool computeWorldToLocalMatrix(<!1><A HREF="Matrix.html">Matrix</A>&amp; matrix, <!1><A HREF="NodeVisitor.html">NodeVisitor</A>*) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="~Transform"></A>
<A NAME="DOC.2.142.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~Transform()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeBound"></A>
<A NAME="DOC.2.142.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const bool computeBound() const </B></TT>
<DD>Overrides Group's computeBound. 
There is no need to override in subclasses from osg::Transform
since this computeBound() uses the underlying matrix (calling
computeMatrix if required.) 
<DL><DT><DD></DL><P>
<A NAME="_computeTransformCallback"></A>
<A NAME="DOC.2.142.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="Transform.html#DOC.2.142.7">ComputeTransformCallback</A>&gt;  _computeTransformCallback</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_referenceFrame"></A>
<A NAME="DOC.2.142.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Transform.html#DOC.2.142.4">ReferenceFrame</A> _referenceFrame</B></TT>
<DL><DT><DD></DL><P></DL>
<HR>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="PositionAttitudeTransform.html">PositionAttitudeTransform</A><BR>
<A HREF="MatrixTransform.html">MatrixTransform</A><BR>
<A HREF="DOFTransform.html">DOFTransform</A><BR>
</DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
