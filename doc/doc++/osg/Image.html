<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  SG_EXPORT osg::Image</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.10">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  SG_EXPORT <A HREF="#DOC.DOCU">osg::Image</A></H2></H2><BLOCKQUOTE>Image class for encapsulating the storage texture image data</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=95>
<param name=classes value="CReferenced,MReferenced.html,CObject,MObject.html,CImage,MImage.html">
<param name=before value="M,M,M">
<param name=after value="Md_SP,Md_,M">
<param name=indent value="0,1,2">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.88.1">Image</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.88.2">Image</A></B>(const <!1><A HREF="Image.html#DOC.2.88.2">Image</A>&amp; image, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)
<DD><I>Copy constructor using CopyOp to manage deep vs shallow copy</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <!1><A HREF="Object.html">Object</A>* <B><A HREF="#DOC.2.88.3">cloneType</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <!1><A HREF="Object.html">Object</A>* <B><A HREF="#DOC.2.88.4">clone</A></B>(const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   bool <B><A HREF="#DOC.2.88.5">isSameKindAs</A></B>(const <!1><A HREF="Object.html">Object</A>* obj) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const char* <B><A HREF="#DOC.2.88.6">libraryName</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   const char* <B><A HREF="#DOC.2.88.7">className</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   int <B><A HREF="#DOC.2.88.8">compare</A></B>(const <!1><A HREF="Image.html">Image</A>&amp; rhs) const 
<DD><I>return -1 if *this < *rhs, 0 if *this==*rhs, 1 if *this>*rhs</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.9">setFileName</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const std::string&amp; <B><A HREF="#DOC.2.88.10">getFileName</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.12">setAllocationMode</A></B>(<!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> mode)
<DD><I>Set the method used for deleting data once it goes out of scope</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> <B><A HREF="#DOC.2.88.13">setAllocationMode</A></B>() const 
<DD><I>Get the method used for deleting data once it goes out of scope</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.14">allocateImage</A></B>(int <!1><A HREF="Image.html#DOC.2.88.20">s</A>, int <!1><A HREF="Image.html#DOC.2.88.21">t</A>, int <!1><A HREF="Image.html#DOC.2.88.22">r</A>, GLenum format, GLenum type, int packing=1)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.15">setImage</A></B>(int <!1><A HREF="Image.html#DOC.2.88.20">s</A>, int <!1><A HREF="Image.html#DOC.2.88.21">t</A>, int <!1><A HREF="Image.html#DOC.2.88.22">r</A>, GLint internalTextureformat, GLenum format, GLenum type, unsigned char* <!1><A HREF="Image.html#DOC.2.88.34">data</A>, <!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> mode, int packing=1)
<DD><I>set the image data and format.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.16">readPixels</A></B>(int <!1><A HREF="Viewport.html#DOC.2.232.8">x</A>, int <!1><A HREF="Viewport.html#DOC.2.232.9">y</A>, int <!1><A HREF="Viewport.html#DOC.2.232.10">width</A>, int <!1><A HREF="Viewport.html#DOC.2.232.11">height</A>, GLenum format, GLenum type)
<DD><I>readPixels from screen at specified position and size, using glReadPixels.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.17">readImageFromCurrentTexture</A></B>(unsigned int contextID=0)
<DD><I>read the contents of the current bound texture, handling compressed formats if present.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.18">scaleImage</A></B>(int <!1><A HREF="Image.html#DOC.2.88.20">s</A>, int <!1><A HREF="Image.html#DOC.2.88.21">t</A>, int <!1><A HREF="Image.html#DOC.2.88.22">r</A>)
<DD><I>Scale image to specified size.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.19">copySubImage</A></B>(int s_offset, int t_offset, int r_offset, <!1><A HREF="Image.html">osg::Image</A>* source)
<DD><I>Copy a source Image into a subpart of this Image at specified position.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   int <B><A HREF="#DOC.2.88.20">s</A></B>() const 
<DD><I>Width of image</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   int <B><A HREF="#DOC.2.88.21">t</A></B>() const 
<DD><I>Height of image</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   int <B><A HREF="#DOC.2.88.22">r</A></B>() const 
<DD><I>Depth of image</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.23">setInternalTextureFormat</A></B>(GLint internalFormat)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   GLint <B><A HREF="#DOC.2.88.24">getInternalTextureFormat</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.25">setPixelFormat</A></B>(GLenum format)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   GLenum <B><A HREF="#DOC.2.88.26">getPixelFormat</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   GLenum <B><A HREF="#DOC.2.88.27">getDataType</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.88.28">getPacking</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.88.29">getPixelSizeInBits</A></B>() const 
<DD><I>return the numbers of bits required for each pixel</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.88.30">getRowSizeInBytes</A></B>() const 
<DD><I>return the numbers of bytes each row of pixels occupies once it has been packed</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.88.31">getImageSizeInBytes</A></B>() const 
<DD><I>return the numbers of bytes each image (_s*_t) of pixels occupies</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.88.32">getTotalSizeInBytes</A></B>() const 
<DD><I>return the numbers of bytes the whole row/image/volume of pixels occupies</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.2.88.33">getTotalSizeInBytesIncludingMipmaps</A></B>() const 
<DD><I>return the numbers of bytes the whole row/image/volume of pixels occupies, including all mip maps if included</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned char* <B><A HREF="#DOC.2.88.34">data</A></B>()
<DD><I>raw image data</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   const unsigned char* <B><A HREF="#DOC.2.88.35">data</A></B>() const 
<DD><I>raw const image data</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned char* <B><A HREF="#DOC.2.88.36">data</A></B>(int column, int row=0, int image=0) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.37">flipHorizontal</A></B>(int image=0)
<DD><I>Flip the image horizontally</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.38">flipVertical</A></B>(int image=0)
<DD><I>Flip the image vertically</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.39">ensureValidSizeForTexturing</A></B>(GLint <!1><A HREF="Extensions.3.html#DOC.2.204.39.22">maxTextureSize</A>)
<DD><I>Ensure image dimensions are a power of two.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.88.40">dirty</A></B>()
<DD><I>Dirty the image, which increments the modified flag, to force osg::Texture to reload the image</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.88.41">setModifiedTag</A></B>(unsigned int value)
<DD><I>Set the modified tag value, only used by osg::Texture when using texture subloading.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned int <B><A HREF="#DOC.2.88.42">getModifiedTag</A></B>() const 
<DD><I>Get modified tag value, only used by osg::Texture when using texture subloading.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   bool <B><A HREF="#DOC.2.88.43">isPackedType</A></B>(GLenum type)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   unsigned int <B><A HREF="#DOC.2.88.44">computeNumComponents</A></B>(GLenum format)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   unsigned int <B><A HREF="#DOC.2.88.45">computePixelSizeInBits</A></B>(GLenum format, GLenum type)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   unsigned int <B><A HREF="#DOC.2.88.46">computeRowWidthInBytes</A></B>(int <!1><A HREF="Viewport.html#DOC.2.232.10">width</A>, GLenum format, GLenum type, int packing)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   int <B><A HREF="#DOC.2.88.47">computeNearestPowerOfTwo</A></B>(int <!1><A HREF="Image.html#DOC.2.88.20">s</A>, float bias=0.5f)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   bool <B><A HREF="#DOC.2.88.49">isMipmap</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.2.88.50">getNumMipmapLevels</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   void <B><A HREF="#DOC.2.88.51">setMipmapData</A></B>(const <!1><A HREF="Image.html#DOC.2.88.48">MipmapDataType</A>&amp; mipmapDataVector)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>inline   unsigned char* <B><A HREF="#DOC.2.88.52">getMipmapData</A></B>(unsigned int mipmapNumber) const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.53">computeMipMaps</A></B>()
<DD><I>converts a single image into mip mapped version image</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.88.54">isImageTranslucent</A></B>() const 
<DD><I>return true of this image is translucent - ie.</I>
</DL></P>

<P><DL>
<DT><H3>Public Members</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>enum  <B><A HREF="#DOC.2.88.11">AllocationMode</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt; unsigned int &gt; <B><A HREF="#DOC.2.88.48">MipmapDataType</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>std::string <B><A HREF="#DOC.2.88.57">_fileName</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.2.88.58">_s</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int  <B><A HREF="#DOC.2.88.59">_t</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int   <B><A HREF="#DOC.2.88.60">_r</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>GLint <B><A HREF="#DOC.2.88.61">_internalTextureFormat</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>GLenum <B><A HREF="#DOC.2.88.62">_pixelFormat</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>GLenum <B><A HREF="#DOC.2.88.63">_dataType</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.2.88.64">_packing</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> <B><A HREF="#DOC.2.88.65">_allocationMode</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned char* <B><A HREF="#DOC.2.88.66">_data</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.2.88.69">_modifiedTag</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Image.html#DOC.2.88.48">MipmapDataType</A> <B><A HREF="#DOC.2.88.70">_mipmapData</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.88.55">~Image</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Image.html">Image</A>&amp; <B><A HREF="#DOC.2.88.56">operator = </A></B>(const <!1><A HREF="Image.html">Image</A>&amp;)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.67">deallocateData</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.88.68">setData</A></B>(unsigned char* <!1><A HREF="Image.html#DOC.2.88.34">data</A>, <!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> allocationMode)
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Object.html">Object</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setDataVariance</B>(<!1><A HREF="Object.html#DOC.2.135.8">DataVariance</A> dv)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Object.html#DOC.2.135.8">DataVariance</A> <B>getDataVariance</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>setUserData</B>(<!1><A HREF="Referenced.html">Referenced</A>* obj)
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   <!1><A HREF="Referenced.html">Referenced</A>* <B>getUserData</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   const <!1><A HREF="Referenced.html">Referenced</A>* <B>getUserData</B>() const 
</DL></P>

<P><DL>
<DT><H3>Public Members</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>enum  <B>DataVariance</B>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="Object.html#DOC.2.135.8">DataVariance</A> <B>_dataVariance</B>
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="ref_ptr.html">ref_ptr</A>&lt;<!1><A HREF="Referenced.html">Referenced</A>&gt;  <B>_userData</B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Referenced.html">Referenced</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>static   void <B>setDeleteHandler</B>(<!1><A HREF="DeleteHandler.html">DeleteHandler</A>* handler)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   <!1><A HREF="DeleteHandler.html">DeleteHandler</A>* <B>getDeleteHandler</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>ref</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref_nodelete</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   int <B>referenceCount</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>inline   void <B>unref</B>() const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>mutable int <B>_refCount</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>Image class for encapsulating the storage texture image data</BLOCKQUOTE>
<DL>

<A NAME="Image"></A>
<A NAME="DOC.2.88.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Image()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Image"></A>
<A NAME="DOC.2.88.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Image(const <!1><A HREF="Image.html#DOC.2.88.2">Image</A>&amp; image, const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop=CopyOp::SHALLOW_COPY)</B></TT>
<DD>Copy constructor using CopyOp to manage deep vs shallow copy
<DL><DT><DD></DL><P>
<A NAME="cloneType"></A>
<A NAME="DOC.2.88.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="Object.html">Object</A>* cloneType() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="clone"></A>
<A NAME="DOC.2.88.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="Object.html">Object</A>* clone(const <!1><A HREF="CopyOp.html">CopyOp</A>&amp; copyop) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="isSameKindAs"></A>
<A NAME="DOC.2.88.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool isSameKindAs(const <!1><A HREF="Object.html">Object</A>* obj) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="libraryName"></A>
<A NAME="DOC.2.88.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const char* libraryName() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="className"></A>
<A NAME="DOC.2.88.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   const char* className() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="compare"></A>
<A NAME="DOC.2.88.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   int compare(const <!1><A HREF="Image.html">Image</A>&amp; rhs) const </B></TT>
<DD>return -1 if *this < *rhs, 0 if *this==*rhs, 1 if *this>*rhs
<DL><DT><DD></DL><P>
<A NAME="setFileName"></A>
<A NAME="DOC.2.88.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setFileName(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getFileName"></A>
<A NAME="DOC.2.88.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const std::string&amp; getFileName() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="AllocationMode"></A>
<A NAME="DOC.2.88.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  AllocationMode</B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="NO_DELETE"></A>
<A NAME="DOC.2.88.11.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> NO_DELETE</B></TT>
<DL><DT><DD></DL><P>
<A NAME="USE_NEW_DELETE"></A>
<A NAME="DOC.2.88.11.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> USE_NEW_DELETE</B></TT>
<DL><DT><DD></DL><P>
<A NAME="USE_MALLOC_FREE"></A>
<A NAME="DOC.2.88.11.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> USE_MALLOC_FREE</B></TT>
<DL><DT><DD></DL><P></DL>

<A NAME="setAllocationMode"></A>
<A NAME="DOC.2.88.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setAllocationMode(<!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> mode)</B></TT>
<DD>Set the method used for deleting data once it goes out of scope
<DL><DT><DD></DL><P>
<A NAME="setAllocationMode"></A>
<A NAME="DOC.2.88.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> setAllocationMode() const </B></TT>
<DD>Get the method used for deleting data once it goes out of scope
<DL><DT><DD></DL><P>
<A NAME="allocateImage"></A>
<A NAME="DOC.2.88.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void allocateImage(int <!1><A HREF="Image.html#DOC.2.88.20">s</A>, int <!1><A HREF="Image.html#DOC.2.88.21">t</A>, int <!1><A HREF="Image.html#DOC.2.88.22">r</A>, GLenum format, GLenum type, int packing=1)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setImage"></A>
<A NAME="DOC.2.88.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setImage(int <!1><A HREF="Image.html#DOC.2.88.20">s</A>, int <!1><A HREF="Image.html#DOC.2.88.21">t</A>, int <!1><A HREF="Image.html#DOC.2.88.22">r</A>, GLint internalTextureformat, GLenum format, GLenum type, unsigned char* <!1><A HREF="Image.html#DOC.2.88.34">data</A>, <!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> mode, int packing=1)</B></TT>
<DD>set the image data and format.
note, when the packing value is negative (the default is -1) this method assumes
a _packing width of 1 if the width is not a multiple of 4,
otherwise automatically sets to _packing to 4. If a positive
value of packing is supplied than _packing is simply set to that value.
<DL><DT><DD></DL><P>
<A NAME="readPixels"></A>
<A NAME="DOC.2.88.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void readPixels(int <!1><A HREF="Viewport.html#DOC.2.232.8">x</A>, int <!1><A HREF="Viewport.html#DOC.2.232.9">y</A>, int <!1><A HREF="Viewport.html#DOC.2.232.10">width</A>, int <!1><A HREF="Viewport.html#DOC.2.232.11">height</A>, GLenum format, GLenum type)</B></TT>
<DD>readPixels from screen at specified position and size, using glReadPixels.
Create memory for storage if required, reuse existing pixel coords if possible.
<DL><DT><DD></DL><P>
<A NAME="readImageFromCurrentTexture"></A>
<A NAME="DOC.2.88.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void readImageFromCurrentTexture(unsigned int contextID=0)</B></TT>
<DD>read the contents of the current bound texture, handling compressed formats if present.
Create memory for storage if required, reuse existing pixel coords if possible.
<DL><DT><DD></DL><P>
<A NAME="scaleImage"></A>
<A NAME="DOC.2.88.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void scaleImage(int <!1><A HREF="Image.html#DOC.2.88.20">s</A>, int <!1><A HREF="Image.html#DOC.2.88.21">t</A>, int <!1><A HREF="Image.html#DOC.2.88.22">r</A>)</B></TT>
<DD>Scale image to specified size. 
<DL><DT><DD></DL><P>
<A NAME="copySubImage"></A>
<A NAME="DOC.2.88.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void copySubImage(int s_offset, int t_offset, int r_offset, <!1><A HREF="Image.html">osg::Image</A>* source)</B></TT>
<DD>Copy a source Image into a subpart of this Image at specified position.
Typically used to copy to an already allocated image, such as creating
a 3D image from a stack 2D images.
If the this Image is empty then image data is created to
accomodate the imaging image in its offset position.
If source is NULL then no operation happens, this Image is left unchanged.
<DL><DT><DD></DL><P>
<A NAME="s"></A>
<A NAME="DOC.2.88.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   int s() const </B></TT>
<DD>Width of image
<DL><DT><DD></DL><P>
<A NAME="t"></A>
<A NAME="DOC.2.88.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   int t() const </B></TT>
<DD>Height of image
<DL><DT><DD></DL><P>
<A NAME="r"></A>
<A NAME="DOC.2.88.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   int r() const </B></TT>
<DD>Depth of image
<DL><DT><DD></DL><P>
<A NAME="setInternalTextureFormat"></A>
<A NAME="DOC.2.88.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setInternalTextureFormat(GLint internalFormat)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getInternalTextureFormat"></A>
<A NAME="DOC.2.88.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   GLint getInternalTextureFormat() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="setPixelFormat"></A>
<A NAME="DOC.2.88.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setPixelFormat(GLenum format)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getPixelFormat"></A>
<A NAME="DOC.2.88.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   GLenum getPixelFormat() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getDataType"></A>
<A NAME="DOC.2.88.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   GLenum getDataType() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getPacking"></A>
<A NAME="DOC.2.88.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getPacking() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getPixelSizeInBits"></A>
<A NAME="DOC.2.88.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getPixelSizeInBits() const </B></TT>
<DD>return the numbers of bits required for each pixel
<DL><DT><DD></DL><P>
<A NAME="getRowSizeInBytes"></A>
<A NAME="DOC.2.88.30"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getRowSizeInBytes() const </B></TT>
<DD>return the numbers of bytes each row of pixels occupies once it has been packed
<DL><DT><DD></DL><P>
<A NAME="getImageSizeInBytes"></A>
<A NAME="DOC.2.88.31"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getImageSizeInBytes() const </B></TT>
<DD>return the numbers of bytes each image (_s*_t) of pixels occupies
<DL><DT><DD></DL><P>
<A NAME="getTotalSizeInBytes"></A>
<A NAME="DOC.2.88.32"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getTotalSizeInBytes() const </B></TT>
<DD>return the numbers of bytes the whole row/image/volume of pixels occupies
<DL><DT><DD></DL><P>
<A NAME="getTotalSizeInBytesIncludingMipmaps"></A>
<A NAME="DOC.2.88.33"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int getTotalSizeInBytesIncludingMipmaps() const </B></TT>
<DD>return the numbers of bytes the whole row/image/volume of pixels occupies, including all mip maps if included
<DL><DT><DD></DL><P>
<A NAME="data"></A>
<A NAME="DOC.2.88.34"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned char* data()</B></TT>
<DD>raw image data
<DL><DT><DD></DL><P>
<A NAME="data"></A>
<A NAME="DOC.2.88.35"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   const unsigned char* data() const </B></TT>
<DD>raw const image data
<DL><DT><DD></DL><P>
<A NAME="data"></A>
<A NAME="DOC.2.88.36"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned char* data(int column, int row=0, int image=0) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="flipHorizontal"></A>
<A NAME="DOC.2.88.37"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void flipHorizontal(int image=0)</B></TT>
<DD>Flip the image horizontally
<DL><DT><DD></DL><P>
<A NAME="flipVertical"></A>
<A NAME="DOC.2.88.38"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void flipVertical(int image=0)</B></TT>
<DD>Flip the image vertically
<DL><DT><DD></DL><P>
<A NAME="ensureValidSizeForTexturing"></A>
<A NAME="DOC.2.88.39"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void ensureValidSizeForTexturing(GLint <!1><A HREF="Extensions.3.html#DOC.2.204.39.22">maxTextureSize</A>)</B></TT>
<DD>Ensure image dimensions are a power of two.
Mip Mapped texture require the image dimensions to be
power of two and are within the maxiumum texture size for
the host machine.
<DL><DT><DD></DL><P>
<A NAME="dirty"></A>
<A NAME="DOC.2.88.40"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void dirty()</B></TT>
<DD>Dirty the image, which increments the modified flag, to force osg::Texture to reload the image
<DL><DT><DD></DL><P>
<A NAME="setModifiedTag"></A>
<A NAME="DOC.2.88.41"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setModifiedTag(unsigned int value)</B></TT>
<DD>Set the modified tag value, only used by osg::Texture when using texture subloading. 
<DL><DT><DD></DL><P>
<A NAME="getModifiedTag"></A>
<A NAME="DOC.2.88.42"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned int getModifiedTag() const </B></TT>
<DD>Get modified tag value, only used by osg::Texture when using texture subloading. 
<DL><DT><DD></DL><P>
<A NAME="isPackedType"></A>
<A NAME="DOC.2.88.43"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   bool isPackedType(GLenum type)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeNumComponents"></A>
<A NAME="DOC.2.88.44"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   unsigned int computeNumComponents(GLenum format)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computePixelSizeInBits"></A>
<A NAME="DOC.2.88.45"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   unsigned int computePixelSizeInBits(GLenum format, GLenum type)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeRowWidthInBytes"></A>
<A NAME="DOC.2.88.46"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   unsigned int computeRowWidthInBytes(int <!1><A HREF="Viewport.html#DOC.2.232.10">width</A>, GLenum format, GLenum type, int packing)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeNearestPowerOfTwo"></A>
<A NAME="DOC.2.88.47"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   int computeNearestPowerOfTwo(int <!1><A HREF="Image.html#DOC.2.88.20">s</A>, float bias=0.5f)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="MipmapDataType"></A>
<A NAME="DOC.2.88.48"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt; unsigned int &gt; MipmapDataType</B></TT>
<DL><DT><DD></DL><P>
<A NAME="isMipmap"></A>
<A NAME="DOC.2.88.49"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   bool isMipmap() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="getNumMipmapLevels"></A>
<A NAME="DOC.2.88.50"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int getNumMipmapLevels() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="setMipmapData"></A>
<A NAME="DOC.2.88.51"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void setMipmapData(const <!1><A HREF="Image.html#DOC.2.88.48">MipmapDataType</A>&amp; mipmapDataVector)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getMipmapData"></A>
<A NAME="DOC.2.88.52"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   unsigned char* getMipmapData(unsigned int mipmapNumber) const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="computeMipMaps"></A>
<A NAME="DOC.2.88.53"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void computeMipMaps()</B></TT>
<DD>converts a single image into mip mapped version image
<DL><DT><DD></DL><P>
<A NAME="isImageTranslucent"></A>
<A NAME="DOC.2.88.54"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool isImageTranslucent() const </B></TT>
<DD>return true of this image is translucent - ie. it has alpha values that are less 1.0 (when normalized).
<DL><DT><DD></DL><P>
<A NAME="~Image"></A>
<A NAME="DOC.2.88.55"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~Image()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="operator = "></A>
<A NAME="DOC.2.88.56"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Image.html">Image</A>&amp; operator = (const <!1><A HREF="Image.html">Image</A>&amp;)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_fileName"></A>
<A NAME="DOC.2.88.57"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string _fileName</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_s"></A>
<A NAME="DOC.2.88.58"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int _s</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_t"></A>
<A NAME="DOC.2.88.59"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int  _t</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_r"></A>
<A NAME="DOC.2.88.60"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int   _r</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_internalTextureFormat"></A>
<A NAME="DOC.2.88.61"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>GLint _internalTextureFormat</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_pixelFormat"></A>
<A NAME="DOC.2.88.62"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>GLenum _pixelFormat</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_dataType"></A>
<A NAME="DOC.2.88.63"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>GLenum _dataType</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_packing"></A>
<A NAME="DOC.2.88.64"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int _packing</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_allocationMode"></A>
<A NAME="DOC.2.88.65"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> _allocationMode</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_data"></A>
<A NAME="DOC.2.88.66"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned char* _data</B></TT>
<DL><DT><DD></DL><P>
<A NAME="deallocateData"></A>
<A NAME="DOC.2.88.67"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void deallocateData()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setData"></A>
<A NAME="DOC.2.88.68"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setData(unsigned char* <!1><A HREF="Image.html#DOC.2.88.34">data</A>, <!1><A HREF="Image.html#DOC.2.88.11">AllocationMode</A> allocationMode)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_modifiedTag"></A>
<A NAME="DOC.2.88.69"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int _modifiedTag</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_mipmapData"></A>
<A NAME="DOC.2.88.70"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Image.html#DOC.2.88.48">MipmapDataType</A> _mipmapData</B></TT>
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
