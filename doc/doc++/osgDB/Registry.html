<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  OSGDB_EXPORT osgDB::Registry</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.8">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  OSGDB_EXPORT <A HREF="#DOC.DOCU">osgDB::Registry</A></H2></H2><BLOCKQUOTE> Registry is a singleton factory which stores the reader/writers which are linked in at runtime for reading non-native file formats.</BLOCKQUOTE>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.30.1">~Registry</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   <!1><A HREF="Registry.html">Registry</A>* <B><A HREF="#DOC.2.30.2">instance</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.30.3">readCommandLine</A></B>(std::vector&lt;std::string&gt;&amp; commandLine)
<DD><I>read the command line string list, removing any matched control sequences</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.30.4">addFileExtensionAlias</A></B>(const std::string mapExt, const std::string toExt)
<DD><I>register an fileextension alias to mapExt toExt, the later should the the extension name of the readerwriter plugin library.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.30.5">addDotOsgWrapper</A></B>(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.30.6">removeDotOsgWrapper</A></B>(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.30.7">addReaderWriter</A></B>(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.30.8">removeReaderWriter</A></B>(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>std::string <B><A HREF="#DOC.2.30.9">createLibraryNameForFile</A></B>(const std::string&amp; fileName)
<DD><I>create the platform specific library name associated with file</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>std::string <B><A HREF="#DOC.2.30.10">createLibraryNameForExt</A></B>(const std::string&amp; ext)
<DD><I>create the platform specific library name associated with file extension</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.30.11">loadLibrary</A></B>(const std::string&amp; fileName)
<DD><I>find the library in the SG_LIBRARY_PATH and load it</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.30.12">closeLibrary</A></B>(const std::string&amp; fileName)
<DD><I>close the attached library with specified name</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Object* <B><A HREF="#DOC.2.30.13">readObjectOfType</A></B>(const osg::Object&amp; compObj, <!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Object* <B><A HREF="#DOC.2.30.14">readObject</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Image* <B><A HREF="#DOC.2.30.15">readImage</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Drawable* <B><A HREF="#DOC.2.30.16">readDrawable</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::StateAttribute* <B><A HREF="#DOC.2.30.17">readStateAttribute</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Node* <B><A HREF="#DOC.2.30.18">readNode</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.30.19">writeObject</A></B>(const osg::Object&amp; obj, <!1><A HREF="Output.html">Output</A>&amp; fw)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::ReadResult <B><A HREF="#DOC.2.30.20">readObject</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::WriteResult <B><A HREF="#DOC.2.30.21">writeObject</A></B>(const osg::Object&amp; obj, const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::ReadResult <B><A HREF="#DOC.2.30.22">readImage</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::WriteResult <B><A HREF="#DOC.2.30.23">writeImage</A></B>(const osg::Image&amp; obj, const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::ReadResult <B><A HREF="#DOC.2.30.24">readNode</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::WriteResult <B><A HREF="#DOC.2.30.25">writeNode</A></B>(const osg::Node&amp; node, const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.30.26">setCreateNodeFromImage</A></B>(bool flag)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.30.27">getCreateNodeFromImage</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.30.28">setOptions</A></B>(ReaderWriter::Options* opt)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::Options* <B><A HREF="#DOC.2.30.29">getOptions</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const ReaderWriter::Options* <B><A HREF="#DOC.2.30.30">getOptions</A></B>() const 
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>
Registry is a singleton factory which stores
the reader/writers which are linked in
at runtime for reading non-native file formats.

<P>The RegisterDotOsgWrapperProxy can be used to automatically register
DotOsgWrappers, at runtime with the Registry. A DotOsgWrapper encapsulates
the functions that can read and write to the .osg for each osg::Object.

<P>The RegisterReaderWriterProxy can be used to automatically
register at runtime a reader/writer with the Registry.</BLOCKQUOTE>
<DL>

<A NAME="~Registry"></A>
<A NAME="DOC.2.30.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> ~Registry()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="instance"></A>
<A NAME="DOC.2.30.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   <!1><A HREF="Registry.html">Registry</A>* instance()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readCommandLine"></A>
<A NAME="DOC.2.30.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void readCommandLine(std::vector&lt;std::string&gt;&amp; commandLine)</B></TT>
<DD>read the command line string list, removing any matched control sequences
<DL><DT><DD></DL><P>
<A NAME="addFileExtensionAlias"></A>
<A NAME="DOC.2.30.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addFileExtensionAlias(const std::string mapExt, const std::string toExt)</B></TT>
<DD>register an fileextension alias to mapExt toExt, the later
should the the extension name of the readerwriter plugin library.
For example to map .tif files to the tiff loader, use
addExtAlias("tif","tiff") which will enable .tif to be read
by the libdb_tiff readerwriter plugin.
<DL><DT><DD></DL><P>
<A NAME="addDotOsgWrapper"></A>
<A NAME="DOC.2.30.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addDotOsgWrapper(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="removeDotOsgWrapper"></A>
<A NAME="DOC.2.30.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void removeDotOsgWrapper(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="addReaderWriter"></A>
<A NAME="DOC.2.30.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addReaderWriter(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="removeReaderWriter"></A>
<A NAME="DOC.2.30.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void removeReaderWriter(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="createLibraryNameForFile"></A>
<A NAME="DOC.2.30.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string createLibraryNameForFile(const std::string&amp; fileName)</B></TT>
<DD>create the platform specific library name associated with file
<DL><DT><DD></DL><P>
<A NAME="createLibraryNameForExt"></A>
<A NAME="DOC.2.30.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string createLibraryNameForExt(const std::string&amp; ext)</B></TT>
<DD>create the platform specific library name associated with file extension
<DL><DT><DD></DL><P>
<A NAME="loadLibrary"></A>
<A NAME="DOC.2.30.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool loadLibrary(const std::string&amp; fileName)</B></TT>
<DD>find the library in the SG_LIBRARY_PATH and load it
<DL><DT><DD></DL><P>
<A NAME="closeLibrary"></A>
<A NAME="DOC.2.30.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool closeLibrary(const std::string&amp; fileName)</B></TT>
<DD>close the attached library with specified name
<DL><DT><DD></DL><P>
<A NAME="readObjectOfType"></A>
<A NAME="DOC.2.30.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Object* readObjectOfType(const osg::Object&amp; compObj, <!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readObject"></A>
<A NAME="DOC.2.30.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Object* readObject(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readImage"></A>
<A NAME="DOC.2.30.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Image* readImage(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readDrawable"></A>
<A NAME="DOC.2.30.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Drawable* readDrawable(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readStateAttribute"></A>
<A NAME="DOC.2.30.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::StateAttribute* readStateAttribute(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readNode"></A>
<A NAME="DOC.2.30.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Node* readNode(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeObject"></A>
<A NAME="DOC.2.30.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool writeObject(const osg::Object&amp; obj, <!1><A HREF="Output.html">Output</A>&amp; fw)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readObject"></A>
<A NAME="DOC.2.30.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::ReadResult readObject(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeObject"></A>
<A NAME="DOC.2.30.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::WriteResult writeObject(const osg::Object&amp; obj, const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readImage"></A>
<A NAME="DOC.2.30.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::ReadResult readImage(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeImage"></A>
<A NAME="DOC.2.30.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::WriteResult writeImage(const osg::Image&amp; obj, const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readNode"></A>
<A NAME="DOC.2.30.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::ReadResult readNode(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeNode"></A>
<A NAME="DOC.2.30.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::WriteResult writeNode(const osg::Node&amp; node, const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setCreateNodeFromImage"></A>
<A NAME="DOC.2.30.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setCreateNodeFromImage(bool flag)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getCreateNodeFromImage"></A>
<A NAME="DOC.2.30.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool getCreateNodeFromImage() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="setOptions"></A>
<A NAME="DOC.2.30.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setOptions(ReaderWriter::Options* opt)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getOptions"></A>
<A NAME="DOC.2.30.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::Options* getOptions()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getOptions"></A>
<A NAME="DOC.2.30.30"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const ReaderWriter::Options* getOptions() const </B></TT>
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
