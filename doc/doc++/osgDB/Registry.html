<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  OSGDB_EXPORT osgDB::Registry</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.10">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  OSGDB_EXPORT <A HREF="#DOC.DOCU">osgDB::Registry</A></H2></H2><BLOCKQUOTE> Registry is a singleton factory which stores the reader/writers which are linked in at runtime for reading non-native file formats.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="Mosg::Referenced,M,CRegistry,MRegistry.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   <!1><A HREF="Registry.html">Registry</A>* <B><A HREF="#DOC.2.39.1">instance</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.2">readCommandLine</A></B>(osg::ArgumentParser&amp; commandLine)
<DD><I>read the command line arguments</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.3">addFileExtensionAlias</A></B>(const std::string mapExt, const std::string toExt)
<DD><I>register an fileextension alias to mapExt toExt, the later should the the extension name of the readerwriter plugin library.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.4">addDotOsgWrapper</A></B>(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.5">removeDotOsgWrapper</A></B>(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.6">addReaderWriter</A></B>(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.7">removeReaderWriter</A></B>(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>std::string <B><A HREF="#DOC.2.39.8">createLibraryNameForFile</A></B>(const std::string&amp; fileName)
<DD><I>create the platform specific library name associated with file</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>std::string <B><A HREF="#DOC.2.39.9">createLibraryNameForExt</A></B>(const std::string&amp; ext)
<DD><I>create the platform specific library name associated with file extension</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>std::string <B><A HREF="#DOC.2.39.10">createLibraryNameForNodeKit</A></B>(const std::string&amp; name)
<DD><I>create the platform specific library name associated with nodekit library name</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.39.11">loadLibrary</A></B>(const std::string&amp; fileName)
<DD><I>find the library in the SG_LIBRARY_PATH and load it</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.39.12">closeLibrary</A></B>(const std::string&amp; fileName)
<DD><I>close the attached library with specified name</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Object* <B><A HREF="#DOC.2.39.13">readObjectOfType</A></B>(const osg::Object&amp; compObj, <!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Object* <B><A HREF="#DOC.2.39.14">readObject</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Image* <B><A HREF="#DOC.2.39.15">readImage</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Drawable* <B><A HREF="#DOC.2.39.16">readDrawable</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::StateAttribute* <B><A HREF="#DOC.2.39.17">readStateAttribute</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Node* <B><A HREF="#DOC.2.39.18">readNode</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.39.19">writeObject</A></B>(const osg::Object&amp; obj, <!1><A HREF="Output.html">Output</A>&amp; fw)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::ReadResult <B><A HREF="#DOC.2.39.20">readObject</A></B>(const std::string&amp; fileName, bool useObjectCache)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::WriteResult <B><A HREF="#DOC.2.39.21">writeObject</A></B>(const osg::Object&amp; obj, const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::ReadResult <B><A HREF="#DOC.2.39.22">readImage</A></B>(const std::string&amp; fileName, bool useObjectCache)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::WriteResult <B><A HREF="#DOC.2.39.23">writeImage</A></B>(const osg::Image&amp; obj, const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::ReadResult <B><A HREF="#DOC.2.39.24">readNode</A></B>(const std::string&amp; fileName, bool useObjectCache)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::WriteResult <B><A HREF="#DOC.2.39.25">writeNode</A></B>(const osg::Node&amp; node, const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.26">setCreateNodeFromImage</A></B>(bool flag)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.39.27">getCreateNodeFromImage</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.28">setOptions</A></B>(ReaderWriter::Options* opt)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::Options* <B><A HREF="#DOC.2.39.29">getOptions</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const ReaderWriter::Options* <B><A HREF="#DOC.2.39.30">getOptions</A></B>() const 
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.31">initFilePathLists</A></B>()
<DD><I>initilize both the Data and Library FilePaths, by default called by the  constructor, so it should only be required if you want to force the re-reading of environmental variables</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.32">initDataFilePathList</A></B>()
<DD><I>initilize the Data FilePath by reading the OSG_FILE_PATH environmental variable</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.33">setDataFilePathList</A></B>(const <!1><A HREF="FilePathList.html">FilePathList</A>&amp; filepath)
<DD><I>Set the data file path using a list of paths stored in a FilePath, which is used when search for data files</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.34">setDataFilePathList</A></B>(const std::string&amp; paths)
<DD><I>Set the data file path using a single string deliminated either with ';' (Windows) or ':' (All other platforms), which is used when search for data files</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="FilePathList.html">FilePathList</A>&amp; <B><A HREF="#DOC.2.39.35">getDataFilePathList</A></B>()
<DD><I>get the data file path which is used when search for data files</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="FilePathList.html">FilePathList</A>&amp; <B><A HREF="#DOC.2.39.36">getDataFilePathList</A></B>() const 
<DD><I>get the const data file path which is used when search for data files</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.37">initLibraryFilePathList</A></B>()
<DD><I>initilize the Library FilePath by reading the OSG_LIBRARY_PATH  and the appropriate system environmental variables</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.38">setLibraryFilePathList</A></B>(const <!1><A HREF="FilePathList.html">FilePathList</A>&amp; filepath)
<DD><I>Set the library file path using a list of paths stored in a FilePath, which is used when search for data files</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.39">setLibraryFilePathList</A></B>(const std::string&amp; paths)
<DD><I>Set the library file path using a single string deliminated either with ';' (Windows) or ':' (All other platforms), which is used when search for data files</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="FilePathList.html">FilePathList</A>&amp; <B><A HREF="#DOC.2.39.40">getLibraryFilePathList</A></B>()
<DD><I>get the library file path which is used when search for library (dso/dll's) files</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>const <!1><A HREF="FilePathList.html">FilePathList</A>&amp; <B><A HREF="#DOC.2.39.41">getLibraryFilePathList</A></B>() const 
<DD><I>get the const library file path which is used when search for library (dso/dll's) files</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   void <B><A HREF="#DOC.2.39.42">convertStringPathIntoFilePathList</A></B>(const std::string&amp; paths, <!1><A HREF="FilePathList.html">FilePathList</A>&amp; filepath)
<DD><I>convert a string containing a list of paths  deliminated either with ';' (Windows) or ':' (All other platforms) into FilePath represetation</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.43">updateTimeStampOfObjectsInCacheWithExtenalReferences</A></B>(double currentTime)
<DD><I>For each object in the cache which has an reference count greater than 1  (and therefore referenced by elsewhere in the application) set the time stamp for that object in the cache to specified time.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.44">removeExpiredObjectsInCache</A></B>(double expiryTime)
<DD><I>Removed object in the cache which have a time stamp at or before the specified expiry time.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.45">clearObjectCache</A></B>()
<DD><I>Remove all objects in the cache regardless of having external references or expiry times</I>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.39.56">_createNodeFromImage</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> <B><A HREF="#DOC.2.39.62">_objectWrapperMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> <B><A HREF="#DOC.2.39.63">_imageWrapperMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> <B><A HREF="#DOC.2.39.64">_drawableWrapperMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> <B><A HREF="#DOC.2.39.65">_stateAttrWrapperMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> <B><A HREF="#DOC.2.39.66">_nodeWrapperMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> <B><A HREF="#DOC.2.39.67">_classNameWrapperMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.48">ReaderWriterList</A> <B><A HREF="#DOC.2.39.68">_rwList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.49">DynamicLibraryList</A> <B><A HREF="#DOC.2.39.69">_dlList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.39.70">_openingLibrary</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.50">ExtensionAliasMap</A> <B><A HREF="#DOC.2.39.71">_extAliasMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::ref_ptr&lt;ReaderWriter::Options&gt;  <B><A HREF="#DOC.2.39.72">_options</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="FilePathList.html">FilePathList</A> <B><A HREF="#DOC.2.39.73">_dataFilePath</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="FilePathList.html">FilePathList</A> <B><A HREF="#DOC.2.39.74">_libraryFilePath</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="Registry.html#DOC.2.39.52">ObjectCache</A> <B><A HREF="#DOC.2.39.75">_objectCache</A></B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.39.46">~Registry</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.39.53">Registry</A></B>()
<DD><I>constructor is private, as its a singleton, preventing construction other than via the instance() method and therefore ensuring only one copy is ever constructed</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>DynamicLibraryList::iterator <B><A HREF="#DOC.2.39.54">getLibraryItr</A></B>(const std::string&amp; fileName)
<DD><I>get the attached library with specified name</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="DynamicLibrary.html">DynamicLibrary</A>* <B><A HREF="#DOC.2.39.55">getLibrary</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Object* <B><A HREF="#DOC.2.39.57">readObject</A></B>(<!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A>&amp; dowMap, <!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.39.58">eraseWrapper</A></B>(<!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A>&amp; wrappermap, <!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::ReadResult <B><A HREF="#DOC.2.39.59">readObject</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::ReadResult <B><A HREF="#DOC.2.39.60">readImage</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>ReaderWriter::ReadResult <B><A HREF="#DOC.2.39.61">readNode</A></B>(const std::string&amp; fileName)
</DL></P>

<P><DL>
<DT><H3>Protected Members</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::map&lt; std::string, osg::ref_ptr&lt;<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>&gt; &gt; <B><A HREF="#DOC.2.39.47">DotOsgWrapperMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt; osg::ref_ptr&lt;<!1><A HREF="ReaderWriter.html">ReaderWriter</A>&gt; &gt; <B><A HREF="#DOC.2.39.48">ReaderWriterList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::vector&lt; osg::ref_ptr&lt;<!1><A HREF="DynamicLibrary.html">DynamicLibrary</A>&gt; &gt; <B><A HREF="#DOC.2.39.49">DynamicLibraryList</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::map&lt; std::string, std::string&gt; <B><A HREF="#DOC.2.39.50">ExtensionAliasMap</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::pair&lt;osg::ref_ptr&lt;osg::Object&gt;, double &gt; <B><A HREF="#DOC.2.39.51">ObjectTimeStampPair</A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>typedef  std::map&lt;std::string, <!1><A HREF="Registry.html#DOC.2.39.51">ObjectTimeStampPair</A> &gt; <B><A HREF="#DOC.2.39.52">ObjectCache</A></B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>
Registry is a singleton factory which stores
the reader/writers which are linked in
at runtime for reading non-native file formats.

<P>The RegisterDotOsgWrapperProxy can be used to automatically register
DotOsgWrappers, at runtime with the Registry. A DotOsgWrapper encapsulates
the functions that can read and write to the .osg for each osg::Object.

<P>The RegisterReaderWriterProxy can be used to automatically
register at runtime a reader/writer with the Registry.</BLOCKQUOTE>
<DL>

<A NAME="instance"></A>
<A NAME="DOC.2.39.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   <!1><A HREF="Registry.html">Registry</A>* instance()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readCommandLine"></A>
<A NAME="DOC.2.39.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void readCommandLine(osg::ArgumentParser&amp; commandLine)</B></TT>
<DD>read the command line arguments
<DL><DT><DD></DL><P>
<A NAME="addFileExtensionAlias"></A>
<A NAME="DOC.2.39.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addFileExtensionAlias(const std::string mapExt, const std::string toExt)</B></TT>
<DD>register an fileextension alias to mapExt toExt, the later
should the the extension name of the readerwriter plugin library.
For example to map .tif files to the tiff loader, use
addExtAlias("tif","tiff") which will enable .tif to be read
by the libdb_tiff readerwriter plugin.
<DL><DT><DD></DL><P>
<A NAME="addDotOsgWrapper"></A>
<A NAME="DOC.2.39.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addDotOsgWrapper(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="removeDotOsgWrapper"></A>
<A NAME="DOC.2.39.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void removeDotOsgWrapper(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="addReaderWriter"></A>
<A NAME="DOC.2.39.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addReaderWriter(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="removeReaderWriter"></A>
<A NAME="DOC.2.39.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void removeReaderWriter(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="createLibraryNameForFile"></A>
<A NAME="DOC.2.39.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string createLibraryNameForFile(const std::string&amp; fileName)</B></TT>
<DD>create the platform specific library name associated with file
<DL><DT><DD></DL><P>
<A NAME="createLibraryNameForExt"></A>
<A NAME="DOC.2.39.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string createLibraryNameForExt(const std::string&amp; ext)</B></TT>
<DD>create the platform specific library name associated with file extension
<DL><DT><DD></DL><P>
<A NAME="createLibraryNameForNodeKit"></A>
<A NAME="DOC.2.39.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string createLibraryNameForNodeKit(const std::string&amp; name)</B></TT>
<DD>create the platform specific library name associated with nodekit library name
<DL><DT><DD></DL><P>
<A NAME="loadLibrary"></A>
<A NAME="DOC.2.39.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool loadLibrary(const std::string&amp; fileName)</B></TT>
<DD>find the library in the SG_LIBRARY_PATH and load it
<DL><DT><DD></DL><P>
<A NAME="closeLibrary"></A>
<A NAME="DOC.2.39.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool closeLibrary(const std::string&amp; fileName)</B></TT>
<DD>close the attached library with specified name
<DL><DT><DD></DL><P>
<A NAME="readObjectOfType"></A>
<A NAME="DOC.2.39.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Object* readObjectOfType(const osg::Object&amp; compObj, <!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readObject"></A>
<A NAME="DOC.2.39.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Object* readObject(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readImage"></A>
<A NAME="DOC.2.39.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Image* readImage(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readDrawable"></A>
<A NAME="DOC.2.39.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Drawable* readDrawable(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readStateAttribute"></A>
<A NAME="DOC.2.39.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::StateAttribute* readStateAttribute(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readNode"></A>
<A NAME="DOC.2.39.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Node* readNode(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeObject"></A>
<A NAME="DOC.2.39.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool writeObject(const osg::Object&amp; obj, <!1><A HREF="Output.html">Output</A>&amp; fw)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readObject"></A>
<A NAME="DOC.2.39.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::ReadResult readObject(const std::string&amp; fileName, bool useObjectCache)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeObject"></A>
<A NAME="DOC.2.39.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::WriteResult writeObject(const osg::Object&amp; obj, const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readImage"></A>
<A NAME="DOC.2.39.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::ReadResult readImage(const std::string&amp; fileName, bool useObjectCache)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeImage"></A>
<A NAME="DOC.2.39.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::WriteResult writeImage(const osg::Image&amp; obj, const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readNode"></A>
<A NAME="DOC.2.39.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::ReadResult readNode(const std::string&amp; fileName, bool useObjectCache)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeNode"></A>
<A NAME="DOC.2.39.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::WriteResult writeNode(const osg::Node&amp; node, const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setCreateNodeFromImage"></A>
<A NAME="DOC.2.39.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setCreateNodeFromImage(bool flag)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getCreateNodeFromImage"></A>
<A NAME="DOC.2.39.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool getCreateNodeFromImage() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="setOptions"></A>
<A NAME="DOC.2.39.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setOptions(ReaderWriter::Options* opt)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getOptions"></A>
<A NAME="DOC.2.39.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::Options* getOptions()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getOptions"></A>
<A NAME="DOC.2.39.30"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const ReaderWriter::Options* getOptions() const </B></TT>
<DL><DT><DD></DL><P>
<A NAME="initFilePathLists"></A>
<A NAME="DOC.2.39.31"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void initFilePathLists()</B></TT>
<DD>initilize both the Data and Library FilePaths, by default called by the 
constructor, so it should only be required if you want to force
the re-reading of environmental variables
<DL><DT><DD></DL><P>
<A NAME="initDataFilePathList"></A>
<A NAME="DOC.2.39.32"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void initDataFilePathList()</B></TT>
<DD>initilize the Data FilePath by reading the OSG_FILE_PATH environmental variable
<DL><DT><DD></DL><P>
<A NAME="setDataFilePathList"></A>
<A NAME="DOC.2.39.33"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setDataFilePathList(const <!1><A HREF="FilePathList.html">FilePathList</A>&amp; filepath)</B></TT>
<DD>Set the data file path using a list of paths stored in a FilePath, which is used when search for data files
<DL><DT><DD></DL><P>
<A NAME="setDataFilePathList"></A>
<A NAME="DOC.2.39.34"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setDataFilePathList(const std::string&amp; paths)</B></TT>
<DD>Set the data file path using a single string deliminated either with ';' (Windows) or ':' (All other platforms), which is used when search for data files
<DL><DT><DD></DL><P>
<A NAME="getDataFilePathList"></A>
<A NAME="DOC.2.39.35"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="FilePathList.html">FilePathList</A>&amp; getDataFilePathList()</B></TT>
<DD>get the data file path which is used when search for data files
<DL><DT><DD></DL><P>
<A NAME="getDataFilePathList"></A>
<A NAME="DOC.2.39.36"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="FilePathList.html">FilePathList</A>&amp; getDataFilePathList() const </B></TT>
<DD>get the const data file path which is used when search for data files
<DL><DT><DD></DL><P>
<A NAME="initLibraryFilePathList"></A>
<A NAME="DOC.2.39.37"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void initLibraryFilePathList()</B></TT>
<DD>initilize the Library FilePath by reading the OSG_LIBRARY_PATH 
and the appropriate system environmental variables
<DL><DT><DD></DL><P>
<A NAME="setLibraryFilePathList"></A>
<A NAME="DOC.2.39.38"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setLibraryFilePathList(const <!1><A HREF="FilePathList.html">FilePathList</A>&amp; filepath)</B></TT>
<DD>Set the library file path using a list of paths stored in a FilePath, which is used when search for data files
<DL><DT><DD></DL><P>
<A NAME="setLibraryFilePathList"></A>
<A NAME="DOC.2.39.39"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setLibraryFilePathList(const std::string&amp; paths)</B></TT>
<DD>Set the library file path using a single string deliminated either with ';' (Windows) or ':' (All other platforms), which is used when search for data files
<DL><DT><DD></DL><P>
<A NAME="getLibraryFilePathList"></A>
<A NAME="DOC.2.39.40"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="FilePathList.html">FilePathList</A>&amp; getLibraryFilePathList()</B></TT>
<DD>get the library file path which is used when search for library (dso/dll's) files
<DL><DT><DD></DL><P>
<A NAME="getLibraryFilePathList"></A>
<A NAME="DOC.2.39.41"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const <!1><A HREF="FilePathList.html">FilePathList</A>&amp; getLibraryFilePathList() const </B></TT>
<DD>get the const library file path which is used when search for library (dso/dll's) files
<DL><DT><DD></DL><P>
<A NAME="convertStringPathIntoFilePathList"></A>
<A NAME="DOC.2.39.42"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   void convertStringPathIntoFilePathList(const std::string&amp; paths, <!1><A HREF="FilePathList.html">FilePathList</A>&amp; filepath)</B></TT>
<DD>convert a string containing a list of paths  deliminated either with ';' (Windows) or ':' (All other platforms) into FilePath represetation
<DL><DT><DD></DL><P>
<A NAME="updateTimeStampOfObjectsInCacheWithExtenalReferences"></A>
<A NAME="DOC.2.39.43"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void updateTimeStampOfObjectsInCacheWithExtenalReferences(double currentTime)</B></TT>
<DD>For each object in the cache which has an reference count greater than 1 
(and therefore referenced by elsewhere in the application) set the time stamp
for that object in the cache to specified time.
This would typically be called once per frame by applications which are doing database paging,
and need to prune objects that are no longer required.
Time value is time in sceonds.
<DL><DT><DD></DL><P>
<A NAME="removeExpiredObjectsInCache"></A>
<A NAME="DOC.2.39.44"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void removeExpiredObjectsInCache(double expiryTime)</B></TT>
<DD>Removed object in the cache which have a time stamp at or before the specified expiry time.
This would typically be called once per frame by applications which are doing database paging,
and need to prune objects that are no longer required, and called after the a called
after the call to updateTimeStampOfObjectsInCacheWithExtenalReferences(currentTime). 
Note, the currentTime is not the expiryTime, one would typically set the expiry time
to a fixed amount of time before currentTime, such as expiryTime = currentTime-10.0.
Time value is time in sceonds.
<DL><DT><DD></DL><P>
<A NAME="clearObjectCache"></A>
<A NAME="DOC.2.39.45"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void clearObjectCache()</B></TT>
<DD>Remove all objects in the cache regardless of having external references or expiry times
<DL><DT><DD></DL><P>
<A NAME="~Registry"></A>
<A NAME="DOC.2.39.46"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~Registry()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="DotOsgWrapperMap"></A>
<A NAME="DOC.2.39.47"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::map&lt; std::string, osg::ref_ptr&lt;<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>&gt; &gt; DotOsgWrapperMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ReaderWriterList"></A>
<A NAME="DOC.2.39.48"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt; osg::ref_ptr&lt;<!1><A HREF="ReaderWriter.html">ReaderWriter</A>&gt; &gt; ReaderWriterList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="DynamicLibraryList"></A>
<A NAME="DOC.2.39.49"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::vector&lt; osg::ref_ptr&lt;<!1><A HREF="DynamicLibrary.html">DynamicLibrary</A>&gt; &gt; DynamicLibraryList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ExtensionAliasMap"></A>
<A NAME="DOC.2.39.50"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::map&lt; std::string, std::string&gt; ExtensionAliasMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ObjectTimeStampPair"></A>
<A NAME="DOC.2.39.51"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::pair&lt;osg::ref_ptr&lt;osg::Object&gt;, double &gt; ObjectTimeStampPair</B></TT>
<DL><DT><DD></DL><P>
<A NAME="ObjectCache"></A>
<A NAME="DOC.2.39.52"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>typedef  std::map&lt;std::string, <!1><A HREF="Registry.html#DOC.2.39.51">ObjectTimeStampPair</A> &gt; ObjectCache</B></TT>
<DL><DT><DD></DL><P>
<A NAME="Registry"></A>
<A NAME="DOC.2.39.53"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Registry()</B></TT>
<DD>constructor is private, as its a singleton, preventing
construction other than via the instance() method and
therefore ensuring only one copy is ever constructed
<DL><DT><DD></DL><P>
<A NAME="getLibraryItr"></A>
<A NAME="DOC.2.39.54"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>DynamicLibraryList::iterator getLibraryItr(const std::string&amp; fileName)</B></TT>
<DD>get the attached library with specified name
<DL><DT><DD></DL><P>
<A NAME="getLibrary"></A>
<A NAME="DOC.2.39.55"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="DynamicLibrary.html">DynamicLibrary</A>* getLibrary(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_createNodeFromImage"></A>
<A NAME="DOC.2.39.56"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _createNodeFromImage</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readObject"></A>
<A NAME="DOC.2.39.57"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Object* readObject(<!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A>&amp; dowMap, <!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="eraseWrapper"></A>
<A NAME="DOC.2.39.58"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void eraseWrapper(<!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A>&amp; wrappermap, <!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readObject"></A>
<A NAME="DOC.2.39.59"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::ReadResult readObject(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readImage"></A>
<A NAME="DOC.2.39.60"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::ReadResult readImage(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readNode"></A>
<A NAME="DOC.2.39.61"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>ReaderWriter::ReadResult readNode(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_objectWrapperMap"></A>
<A NAME="DOC.2.39.62"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> _objectWrapperMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_imageWrapperMap"></A>
<A NAME="DOC.2.39.63"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> _imageWrapperMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_drawableWrapperMap"></A>
<A NAME="DOC.2.39.64"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> _drawableWrapperMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_stateAttrWrapperMap"></A>
<A NAME="DOC.2.39.65"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> _stateAttrWrapperMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_nodeWrapperMap"></A>
<A NAME="DOC.2.39.66"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> _nodeWrapperMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_classNameWrapperMap"></A>
<A NAME="DOC.2.39.67"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.47">DotOsgWrapperMap</A> _classNameWrapperMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_rwList"></A>
<A NAME="DOC.2.39.68"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.48">ReaderWriterList</A> _rwList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_dlList"></A>
<A NAME="DOC.2.39.69"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.49">DynamicLibraryList</A> _dlList</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_openingLibrary"></A>
<A NAME="DOC.2.39.70"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool _openingLibrary</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_extAliasMap"></A>
<A NAME="DOC.2.39.71"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.50">ExtensionAliasMap</A> _extAliasMap</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_options"></A>
<A NAME="DOC.2.39.72"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::ref_ptr&lt;ReaderWriter::Options&gt;  _options</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_dataFilePath"></A>
<A NAME="DOC.2.39.73"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="FilePathList.html">FilePathList</A> _dataFilePath</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_libraryFilePath"></A>
<A NAME="DOC.2.39.74"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="FilePathList.html">FilePathList</A> _libraryFilePath</B></TT>
<DL><DT><DD></DL><P>
<A NAME="_objectCache"></A>
<A NAME="DOC.2.39.75"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="Registry.html#DOC.2.39.52">ObjectCache</A> _objectCache</B></TT>
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
