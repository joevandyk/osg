<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  OSGDB_EXPORT osgDB::Registry</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.8">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  OSGDB_EXPORT <A HREF="#DOC.DOCU">osgDB::Registry</A></H2></H2><BLOCKQUOTE> Registry is a singleton factory which stores the Objects types available at runtime for loading, and any Object reader or writers which are linked in at runtime for reading non-native file formats.</BLOCKQUOTE>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.2.28.1">~Registry</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>static   <!1><A HREF="Registry.html">Registry</A>* <B><A HREF="#DOC.2.28.2">instance</A></B>()
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.28.3">addFileExtensionAlias</A></B>(const std::string mapExt, const std::string toExt)
<DD><I>register an fileextension alias to mapExt toExt, the later should the the extension name of the readerwriter plugin library.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.28.4">addDotOsgWrapper</A></B>(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.28.5">removeDotOsgWrapper</A></B>(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.28.6">addReaderWriter</A></B>(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.28.7">removeReaderWriter</A></B>(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>std::string <B><A HREF="#DOC.2.28.8">createLibraryNameForFile</A></B>(const std::string&amp; fileName)
<DD><I>create the platform specific library name associated with file</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>std::string <B><A HREF="#DOC.2.28.9">createLibraryNameForExt</A></B>(const std::string&amp; ext)
<DD><I>create the platform specific library name associated with file extension</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.28.10">loadLibrary</A></B>(const std::string&amp; fileName)
<DD><I>find the library in the SG_LIBRARY_PATH and load it</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.28.11">closeLibrary</A></B>(const std::string&amp; fileName)
<DD><I>close the attached library with specified name</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Object* <B><A HREF="#DOC.2.28.12">readObjectOfType</A></B>(const osg::Object&amp; compObj, <!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Object* <B><A HREF="#DOC.2.28.13">readObject</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Image* <B><A HREF="#DOC.2.28.14">readImage</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Drawable* <B><A HREF="#DOC.2.28.15">readDrawable</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::StateAttribute* <B><A HREF="#DOC.2.28.16">readStateAttribute</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Node* <B><A HREF="#DOC.2.28.17">readNode</A></B>(<!1><A HREF="Input.html">Input</A>&amp; fr)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.28.18">writeObject</A></B>(const osg::Object&amp; obj, <!1><A HREF="Output.html">Output</A>&amp; fw)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Object* <B><A HREF="#DOC.2.28.19">readObject</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.28.20">writeObject</A></B>(const osg::Object&amp; obj, const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Image* <B><A HREF="#DOC.2.28.21">readImage</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.28.22">writeImage</A></B>(const osg::Image&amp; obj, const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>osg::Node* <B><A HREF="#DOC.2.28.23">readNode</A></B>(const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.28.24">writeNode</A></B>(const osg::Node&amp; node, const std::string&amp; fileName)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.2.28.25">setCreateNodeFromImage</A></B>(bool flag)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.2.28.26">getCreateNodeFromImage</A></B>() const 
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>
Registry is a singleton factory which stores
the Objects types available at runtime for loading,
and any Object reader or writers which are linked in
at runtime for reading non-native file formats.

<P>The RegisterObjectProxy can be used to automatically register
at runtime a Object with the Registry.

<P>The RegisterReaderWriterProxy can be used to automatically
register at runtime a reader/writer with the Registry.</BLOCKQUOTE>
<DL>

<A NAME="~Registry"></A>
<A NAME="DOC.2.28.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> ~Registry()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="instance"></A>
<A NAME="DOC.2.28.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   <!1><A HREF="Registry.html">Registry</A>* instance()</B></TT>
<DL><DT><DD></DL><P>
<A NAME="addFileExtensionAlias"></A>
<A NAME="DOC.2.28.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addFileExtensionAlias(const std::string mapExt, const std::string toExt)</B></TT>
<DD>register an fileextension alias to mapExt toExt, the later
should the the extension name of the readerwriter plugin library.
For example to map .tif files to the tiff loader, use
addExtAlias("tif","tiff") which will enable .tif to be read
by the libdb_tiff readerwriter plugin.
<DL><DT><DD></DL><P>
<A NAME="addDotOsgWrapper"></A>
<A NAME="DOC.2.28.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addDotOsgWrapper(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="removeDotOsgWrapper"></A>
<A NAME="DOC.2.28.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void removeDotOsgWrapper(<!1><A HREF="DotOsgWrapper.html">DotOsgWrapper</A>* wrapper)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="addReaderWriter"></A>
<A NAME="DOC.2.28.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void addReaderWriter(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="removeReaderWriter"></A>
<A NAME="DOC.2.28.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void removeReaderWriter(<!1><A HREF="ReaderWriter.html">ReaderWriter</A>* rw)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="createLibraryNameForFile"></A>
<A NAME="DOC.2.28.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string createLibraryNameForFile(const std::string&amp; fileName)</B></TT>
<DD>create the platform specific library name associated with file
<DL><DT><DD></DL><P>
<A NAME="createLibraryNameForExt"></A>
<A NAME="DOC.2.28.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>std::string createLibraryNameForExt(const std::string&amp; ext)</B></TT>
<DD>create the platform specific library name associated with file extension
<DL><DT><DD></DL><P>
<A NAME="loadLibrary"></A>
<A NAME="DOC.2.28.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool loadLibrary(const std::string&amp; fileName)</B></TT>
<DD>find the library in the SG_LIBRARY_PATH and load it
<DL><DT><DD></DL><P>
<A NAME="closeLibrary"></A>
<A NAME="DOC.2.28.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool closeLibrary(const std::string&amp; fileName)</B></TT>
<DD>close the attached library with specified name
<DL><DT><DD></DL><P>
<A NAME="readObjectOfType"></A>
<A NAME="DOC.2.28.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Object* readObjectOfType(const osg::Object&amp; compObj, <!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readObject"></A>
<A NAME="DOC.2.28.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Object* readObject(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readImage"></A>
<A NAME="DOC.2.28.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Image* readImage(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readDrawable"></A>
<A NAME="DOC.2.28.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Drawable* readDrawable(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readStateAttribute"></A>
<A NAME="DOC.2.28.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::StateAttribute* readStateAttribute(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readNode"></A>
<A NAME="DOC.2.28.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Node* readNode(<!1><A HREF="Input.html">Input</A>&amp; fr)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeObject"></A>
<A NAME="DOC.2.28.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool writeObject(const osg::Object&amp; obj, <!1><A HREF="Output.html">Output</A>&amp; fw)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readObject"></A>
<A NAME="DOC.2.28.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Object* readObject(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeObject"></A>
<A NAME="DOC.2.28.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool writeObject(const osg::Object&amp; obj, const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readImage"></A>
<A NAME="DOC.2.28.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Image* readImage(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeImage"></A>
<A NAME="DOC.2.28.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool writeImage(const osg::Image&amp; obj, const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="readNode"></A>
<A NAME="DOC.2.28.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>osg::Node* readNode(const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="writeNode"></A>
<A NAME="DOC.2.28.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool writeNode(const osg::Node&amp; node, const std::string&amp; fileName)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="setCreateNodeFromImage"></A>
<A NAME="DOC.2.28.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setCreateNodeFromImage(bool flag)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="getCreateNodeFromImage"></A>
<A NAME="DOC.2.28.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool getCreateNodeFromImage() const </B></TT>
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
