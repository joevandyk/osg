<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.4.3-20mdk i686) [Netscape]">
   <title>Introduction to the OpenSceneGraph</title>
</head>
<body bgcolor="#FFFFFF">
<img SRC="images/OpenSceneGraphBanner_Distribution.jpg" BORDER=0>
<table>
<tr>
<td><a href="index.html">Index</a></td>

<td><a href="introduction.html">Introduction</a></td>

<td><a href="contents.html">Contents</a></td>

<td><a href="install.html">Install</a></td>

<td><a href="dependencies.html">Dependencies</a></td>

<td><a href="examples.html">examples</a></td>

<td><a href="data.html">Data</a></td>

<td><a href="osgviewer.html">Viewer</a></td>

<td><a href="stereo.html">Stereo</a></td>

<td><a href="plan.html">Plan</a></td>

<td><a href="documentation.html">Reference Guides</a></td>
</tr>
</table>

<h2>
<u>Introduction to the OpenSceneGraph</u></h2>

<p>The OpenSceneGraph is an portable, high level graphics toolkit for the development of high peformance
graphics applications such as flight simulators, games, virtual reality or scientific visualization.  
Providing an object orientated framework on top of OpenGL, it frees the developer
from implementing and optimizing low level graphics calls, and provide many additional utilities for 
rapid development of graphics applications.  
</p>
<p>
The project was started as a hobby by Don Burns in early 1999, as means of porting a hang gliding simulator written on top of the 
Peformer scene graph running on IRIX to what was then a humble Linux PC. In mid 1999, Robert Osfield began helping out with 
the simulator development and ported the scene graph element to Windows.  In september 1999 the source code was open sourced, 
and the openscenegraph.org website was born, with Robert taking over as project lead and Don remaining focused on the hang 
gliding simulator.  In April 2001, in response to growing interest in the project around the world, Robert went fulltime 
on the project, setting up OpenSceneGraph Professional Services, 
with the mission:
<ul>
<li><b>Source</b>
<br>To develop a high performance, high quality visualization toolkit which
is freely available and accessible to all.</li>

<li><b>Community</b>
<br>To nurture a world-wide community of graphics professionals and enthusiasts
for development, support and promotion of best practices in software engineering
and real-time computer graphics.</li>

<li><b>Service</b>
<br>To provide consultancy and development services for clients projects to
allow them to maximize the benefits of real-time 3D graphics and to facilitate
the rapid, yet seamless adoption of latest graphics technologies.</li>
</ul>
</p>

<br>
<h3>
<u>What is a Scene Graph?</u></h3>
Its a tree! Quite simply one the best and most reusable data structures
invented. Typically drawn schematically with the root at the top, leaves at the
bottom. It all starts with a top-most root node which encompasses your whole
virtual world, be it 2D or 3D. The world is then broken down into a hierarchy
of nodes representing either spatial groupings of objects, settings of the
position of objects, animations of objects, or definitions of logical relationships
between objects such as those to manage the various states of a traffic light.
The leaves of the graph represent the physical objects themselves, the
drawable geometry and their material properties.
</p>
<p>A scene graph isn't a complete game or simulation engine, although it may
be one of the main components of such an engine; it's primary focus is
representation of your 3d worlds, and efficient rendering thereof. Physics models,
collision detection and audio are left to other development libraries that
a user will integrate with. The fact that scene graphs don't typically
integrate all these features is actually a really good thing: it aids interoprability
with clients' own applications and tools and allows them to serve many varied
markets from games, visual simulation, virtual reality,
scientific and commercial visualization, training through to modeling programs.
</p>


<br>
<h3>
<u>Advantages that Scene Graphs provide</h3>

The key reasons that many graphics developers uses scene graphs are  <i>Performance, Productivity, Portability and Scalability:</i>

<ul>
<li><b><i>Performance</i></b></li>
Scene graphs provide an excellent framework for
maximizing graphics performance. A good scene graph employs two key techniques
- culling of the objects that won't be seen on screen, and state sorting
of properties such as textures and materials, so that all similar objects
are drawn together. Without culling the CPU, buses and GPU will all become
swamped by many times the amount of data than they actually require to
represent your work accurately. The hierarchical structure of the scene
graph makes this culling process very efficient, for instance a whole city can be culled
with just a few operations! Without state sorting, the the buses and GPU
will thrash between states, stalling the graphics pipeline and destroying graphics
througput. As GPU's get faster and faster, the cost of stalling the graphics
is also going up, so scene graphs are becoming ever more important.

<li><b><i>Productivity</i></b></li> 
Scene graphs take away much of the hard work required
to develop high performance graphics applications. The scene graph manages
all the graphics for you, reducing what would be thousands of lines of
OpenGL down to a few simple calls. Furthermore, one of most powerful concepts
in Object Oriented programming is that of object composition, enshrined
in the <i>Composite Design Pattern</i>, which fits the scene graph tree structure
perfectly and makes it a highly flexible and reusable design - in real
terms this means that it can be easily adapted to solve your problems.
With scene graphs often also come additional utility libraries which range from
helping users set up and manage graphics windows to importing of 3d models
and images. All this together allows the user to achieve a great deal with
very little coding. A dozen lines of code can be enough to load your data
and create an interactive viewer!

<li><b><i>Portability</i></b></li>
Scene graphs encapsulate much of the lower level
tasks of rendering graphics and reading and writing data, reducing or even
eradicating the platform specific coding that you require in your own application.
If the underlying scene graph is portable then moving from platform to
platform can be as simple as recompiling your source code.

<li><b><i>Scalability</i></b></li>
Along with being able to dynamic manage the complexity
of scenes automatically to account for differences in graphics performance
across a range of machines, scene graphs also make it much easier to manage
complex hardware configurations, such as clusters of graphics machines,
or multiprocessor/multipipe systems such as SGI's Onyx. A good scene graph
will allow the developer to concentrate on developing their own application
while the rendering framework of the scene graph handles the different
underlying hardware configurations.
</ul>


<br>
<h3>
<u>The OpenSceneGraph - <i> a robust, high peformance Open Source scene graph</i></u></h3>
With the OpenSceneGraph our goal is make the benefits of scene graph technology 
freely available to all, for both commericial and non commericial users. Whilst our scene graph
is still in development, it has already gained a respect
amongst the development community for its high performance, cleanness of
design and portability. Written entirely in Standard C++ and OpenGL, it
makes full use of the STL and Design Patterns, and leverages the open source
development model to provide a development library that is legacy free
and well focused on the solving the task. The OpenSceneGraph delivers on
the four key benefits of scene graph technology outlined above using the
following features:
<ul>
<li><b><i>Performance</i></b></li>
Supports view frustum culling, occlusion culling, small feature culling,
Level Of Detail (LOD) nodes, state sorting, vertex arrays and display
lists as part of the core scene graph. These together make the OpenSceneGraph
one of the highest performance scene graph available. User feedback is that
performance surpasses that of much more established scene graphs such as Performer, VTree, Vega
Scene Graph and Java3D! The OpenSceneGraph also supports easy customization
of the drawing process, which has allowed implementation of Continuous Level
of Detail (CLOD) meshes on top the scene graph. These allow the visualization
of massive terrain databases interactively, examples of this approach can
be found at Vterrain.org and TerrainEngine.com, both of which integrate
with the OpenSceneGraph.

<li><b><i>Productivity</i></b> </li>
Combining lessons learned from established scene graphs like Performer 
and Open Inventor, with modern software engineering
methods like Design Patterns, along with a great deal of feedback early on
in the development cycle, it has been possible to design a library that is
clean and highly interpretable. This has made it easy for users to adopt
to the OpenSceneGraph and to integrate it with their own applications. With
a full feature set in the core scene graph, utilities (osgUtil) to set up the scene
graph and viewers (osgProducer).
</p>
<p>
For reading and writing databases an addition database library (osgDB) adds support for a wide
variety of database formats via a extensible dynamic plugin mechansim - the distribution now includes 33
seperate plugins for loading various 3D and Image data formats. 3D Database loaders include OpenFlight (.flt), 
TerraPage (.txp) including multi-threading support, LightWave (.lwo), Alias Wavefront (.obj), 
Carbon Graphics GEO (.geo), 3D Studio MAX (.3ds), Peformer (.pfb), Quake Character Models (.md2). Direct X (.x), 
and Inventor Ascii 2.0 (.iv)/ VRML 1.0 (.wrl), Designer Workshop (.dw) and AC3D (.ac) and the native .osg ASCII format.
Image loaders include .rgb, .gif, .jpg, .png, .tiff, .pic, .bmp, .dds (include compressed mip mapped imagery), .tga and qucktime (under OSX).  A whole set of quality fonts 
can also be loaded via the freetype plugin.
</p>
<p>
The scene graph also has a set of <i>Node Kits</i> which are seperate libraries
that be compiled directly or loaded in at runtime to add support for particle systems (osgParticle),
high quality anti-aliased text (osgText) and navigational light points (osgSim).  

<li><b><i>Portability</i></b></li>
The core scene graph has also been designed to
have minimal dependency on any specific platform, requiring little more than
Standard C++ and OpenGL. This has allowed the scene graph to be rapidly
ported to a wide range of platforms - originally developed on IRIX, then
ported to Linux, then to Windows, then FreeBSD, Mac OSX, Solaris, HP-UX and 
we even a report of successful porting to PlayStation2! 
<br>
The core scene graph library being completely windowing system independent makes 
it easy for users to add their own window-specific libraries and applications on top.
In the distribution there is already the osgProducer library which integrates with <a href="http://www.andesengineering.com/Producer/">OpenProducer</a>, and in the Bazaar
found at openscenegrph.org/download/ one can find examples of applications
written on top of GLUT, Qt, MFC, WxWindows and SDL. Users have also integrated it
with Motif, and X.

<li><b><i>Scalability</i></b></li> 
The scene graph will not only run on portables all
the way up to Onyx Infinite Reality Monsters, but also supports the multiple
graphics subsystems found on machines like a mulitpipe Onyx. This is
possible because the core scene graph supports multiple graphics contexts
for both OpenGL Display Lists and texture objects, and the cull and draw
traversals have been designed to cache rendering data locally and use the
scene graph almost entirely as a read-only operation. This allows multiple
cull-draw pairs to run on multiple CPU's which are bound to multiple graphics
subsystems. Support for multiple graphic context and multi-threading is all
available out of the box via osgProducer - all the examples in the distribution
can run multi-pipe just by use a simple configuation file.

</ul>

All the source to the OSG is published under the Open Scene Graph Public License
(a relaxed version on the LGPL) which allows both open source and closed source projects to use,
modify and distribute it freely as long its usage complies with the OSGPL.
The project has been developed over the last four years, initiated by Don
Burns, and then taken over by Robert Osfield who continues to lead the project
today. There are many other contributors to the library, for a full list
check out the AUTHORS file. Both Robert and Don now work on the OpenSceneGraph
in a professional capacity providing consultancy and bespoke development
on top the library, and are also collaborating on the book. Work on the
core scene graph and support of public mailing list remains unpaid as are
the contributions of the rest of the community, but this hasn't impacted
the quality of the source or support which once you get stuck in you grow
to appreciate.
<p>The project is currently in beta, which means the main core features are now in
place, with a 1.0 release in second half of 2003. Despite the beta development status,
the project has already earned the reputation as the leading open source scene
graph, and is establishing itself as a viable alternative to the commercial
scene graphs. Numerous companies, university researchers and graphics enthusiasts
have already adopted the OpenSceneGraph for their projects, all over the world.
<br>

<br>
<h3>
<u>Getting started</u></h3>
The first thing is to select the distribution which suits you, there are
binary, development and source code distributions, these can be loaded
from the
<a href="http://www.openscenegraph.org/download">http://www.openscenegraph.org/download</a>
page. The latest developments area available as via a nightly tarball or
via cvs.
<p>The binary distribution contains just the libraries (.dll's /.so's)
and example executables. This is suitable for using the OpenSceneGraph with
an application that has already been compiled but depends at runtime on
the OpenSceneGraph.
</p>
<p>The development distribution contains the libraries (.dll's /.so's),
example executables, include files, and source to the examples. This is suitable
for using the developers using the OpenSceneGraph.
</p>
<p>The source distribution contains all the source and include files
required to build the OpenSceneGraph from scratch, and is ideal if you
want to learn more about how the scene graph works, how to extend it, and
to track down and fix any problems that you come across.
</p>
<p>If you are using a source distribution then read the <a href="install.html">installation</a>
instructions for how to get the OpenSceneGraph compiling and installed
on your system. You may also need to download libraries that parts of the
OpenSceneGraph depend upon, such as Producer. Check the <a href="dependencies.html">dependencies</a>
list for further details.
</p>
<p>For full instructions of how to run the examples read the <a href="examples.html">examples</a>
page.
</p>
<br>

<h3>
<u>Learning how to use the OpenSceneGraph</u></h3>
<p>The OpenSceneGraph distribution comes with a reference guide for each of
the component libraries - osg, osgDB, osgUtil, osgText, osgSim, osgParticle and osgProducer, a set
of 42 examples - the source of which can be found in examples/ directory in the distribution. For questions
or help which can't be easily be answered by the reference guide and examples
source, one should join the mailing list (details below). There are also
the beginnings of a <a href="http://www.c2.com/cgi/wiki?OpenSceneGraphFaq">Wiki
based FAQ</a> which may help answer a few of the common queries.
</p>
<p>A programming guide will be available in form of a OpenSceneGraph book
which is being written by Don Burns and Robert Osfield, parts of it will
be available online.
</p>
<p>Although not directly related to the OpenSceneGraph, once can learn
about scene graph technology from such sources as the <a href="http://www.sgi.com/software/inventor/manuals.html">Open
Inventor Mentor</a>, and <a href="http://www.cineca.it/manuali/Performer/ProgGuide24/html">Performer
Programming Guides</a>. The latter is the closer in design to
the OpenSceneGraph, although the Performer manuals are in C, alas. Also of use
as a background to some of the techniques used is a SIGGRAPH <a href="http://www.opengl.org/developers/code/sig99/advanced99/course_slides/vissim/index.htm">Vis-Sim
course</a>.
</p>
<p>The OpenSceneGraph uses OpenGL and does so with a deliberately thin layer,
making it easy to control the underlying OpenGL and to extend it with OpenGL
extensions. The close tie with OpenGL is also reflected in the naming of
many of the OpenGL state related classes, and the parameters that they
encapsulate, which means that knowledge of OpenGL itself will go a long way
to understanding how to get the best out of the OpenSceneGraph. To this
end it is worth obtaining a copy of the OpenGL programming guide - <a href="http://fly.cc.fer.hr/~unreal/theredbook/">`Red
Book`</a> and OpenGL reference guide 'Blue Book'. The main <a href="http://www.opengl.org">OpenGL
website</a> is also a good source of links and further information.
</p>
<br>

<br>
<h3>
<u>Support and discussion - the <i>openscenegraph-news</i> mailing list</u></h3>
For scene graph related questions, bug reports, bug fixes, and general
design and development discussion one should join the <a href="http://lists.sourceforge.net/mailman/listinfo/openscenegraph-news">openscenegraph-news</a>
mailing list, and check the the mailing list <a href="http://sourceforge.net/mailarchive/forum.php?forum_id=4775">archives</a>.
<p>Professional support is also available in the form of confidential online,
phone and onsite support and consultancy, for details contact Robert Osfield
at <a href="mailto:robert@openscenegraph.com">robert@openscenegraph.com</a>.
</body>
</html>
