// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/BoundingBox>
#include <osg/CoordinateSystemNode>
#include <osg/Image>
#include <osg/Matrixd>
#include <osg/Node>
#include <osg/StateSet>
#include <osg/Vec4>
#include <osgDB/Archive>
#include <osgTerrain/DataSet>

TYPE_NAME_ALIAS(std::map< unsigned int COMMA  osgTerrain::DataSet::CompositeDestination * >, osgTerrain::DataSet::Row);

TYPE_NAME_ALIAS(std::map< unsigned int COMMA  osgTerrain::DataSet::Row >, osgTerrain::DataSet::Level);

TYPE_NAME_ALIAS(std::map< unsigned int COMMA  osgTerrain::DataSet::Level >, osgTerrain::DataSet::QuadMap);

BEGIN_ENUM_REFLECTOR(osgTerrain::DataSet::CompositeType)
	EnumLabel(osgTerrain::DataSet::GROUP);
	EnumLabel(osgTerrain::DataSet::LOD);
	EnumLabel(osgTerrain::DataSet::PAGED_LOD);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osgTerrain::DataSet::DatabaseType)
	EnumLabel(osgTerrain::DataSet::LOD_DATABASE);
	EnumLabel(osgTerrain::DataSet::PagedLOD_DATABASE);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osgTerrain::DataSet::GeometryType)
	EnumLabel(osgTerrain::DataSet::HEIGHT_FIELD);
	EnumLabel(osgTerrain::DataSet::POLYGONAL);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osgTerrain::DataSet::TextureType)
	EnumLabel(osgTerrain::DataSet::RGB_24);
	EnumLabel(osgTerrain::DataSet::RGBA);
	EnumLabel(osgTerrain::DataSet::RGB_16);
	EnumLabel(osgTerrain::DataSet::RGBA_16);
	EnumLabel(osgTerrain::DataSet::COMPRESSED_TEXTURE);
	EnumLabel(osgTerrain::DataSet::COMPRESSED_RGBA_TEXTURE);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osgTerrain::DataSet::MipMappingMode)
	EnumLabel(osgTerrain::DataSet::NO_MIP_MAPPING);
	EnumLabel(osgTerrain::DataSet::MIP_MAPPING_HARDWARE);
	EnumLabel(osgTerrain::DataSet::MIP_MAPPING_IMAGERY);
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osgTerrain::DataSet)
	BaseType(osg::Referenced);
	Method1(void, insertTileToQuadMap, IN, osgTerrain::DataSet::CompositeDestination *, tile);
	Method3(osgTerrain::DataSet::DestinationTile *, getTile, IN, unsigned int, level, IN, unsigned int, X, IN, unsigned int, Y);
	Method3(osgTerrain::DataSet::CompositeDestination *, getComposite, IN, unsigned int, level, IN, unsigned int, X, IN, unsigned int, Y);
	Method2(osgTerrain::DataSet::Row &, getRow, IN, unsigned int, level, IN, unsigned int, Y);
	Constructor0();
	Method1(void, addSource, IN, osgTerrain::DataSet::Source *, source);
	Method1(void, addSource, IN, osgTerrain::DataSet::CompositeSource *, composite);
	Method0(void, loadSources);
	Method1(void, setMaximumTileImageSize, IN, unsigned int, size);
	Method0(unsigned int, getMaximumTileImageSize);
	Method1(void, setMaximumTileTerrainSize, IN, unsigned int, size);
	Method0(unsigned int, getMaximumTileTerrainSize);
	Method1(void, setMaximumVisibleDistanceOfTopLevel, IN, float, d);
	Method0(float, getMaximumVisibleDistanceOfTopLevel);
	Method1(void, setRadiusToMaxVisibleDistanceRatio, IN, float, ratio);
	Method0(float, getRadiusToMaxVisibleDistanceRatio);
	Method1(void, setVerticalScale, IN, float, verticalScale);
	Method0(float, getVerticalScale);
	Method1(void, setSkirtRatio, IN, float, skirtRatio);
	Method0(float, getSkirtRatio);
	Method1(void, setDefaultColor, IN, const osg::Vec4 &, defaultColor);
	Method0(const osg::Vec4 &, getDefaultColor);
	Method1(void, setDestinationCoordinateSystem, IN, const std::string &, wellKnownText);
	Method1(void, setDestinationCoordinateSystem, IN, osg::CoordinateSystemNode *, cs);
	Method0(osg::CoordinateSystemNode *, getDestinationCoordinateSystem);
	Method1(void, setIntermediateCoordinateSystem, IN, const std::string &, wellKnownText);
	Method1(void, setIntermediateCoordinateSystem, IN, osg::CoordinateSystemNode *, cs);
	Method0(osg::CoordinateSystemNode *, getIntermediateCoordinateSystem);
	Method1(void, setConvertFromGeographicToGeocentric, IN, bool, flag);
	Method0(bool, getConvertFromGeographicToGeocentric);
	Method1(void, setEllipsoidModel, IN, osg::EllipsoidModel *, et);
	Method0(osg::EllipsoidModel *, getEllipsoidModel);
	Method0(const osg::EllipsoidModel *, getEllipsoidModel);
	Method0(bool, mapLatLongsToXYZ);
	Method1(void, setDestinationExtents, IN, const osg::BoundingBox &, extents);
	Method1(void, setDestinationGeoTransform, IN, const osg::Matrixd &, geoTransform);
	Method1(void, setArchiveName, IN, const std::string &, filename);
	Method0(const std::string &, getArchiveName);
	Method1(void, setArchive, IN, osgDB::Archive *, archive);
	Method0(osgDB::Archive *, getArchive);
	Method1(void, setDestinationName, IN, const std::string &, filename);
	Method1(void, setDestinationTileBaseName, IN, const std::string &, basename);
	Method0(const std::string &, getDestinationTileBaseName);
	Method1(void, setDestinationTileExtension, IN, const std::string &, extension);
	Method0(const std::string &, getDestinationTileExtension);
	Method1(void, setDatabaseType, IN, osgTerrain::DataSet::DatabaseType, type);
	Method0(osgTerrain::DataSet::DatabaseType, getDatabaseType);
	Method1(void, setGeometryType, IN, osgTerrain::DataSet::GeometryType, type);
	Method0(osgTerrain::DataSet::GeometryType, getGeometryType);
	Method1(void, setTextureType, IN, osgTerrain::DataSet::TextureType, type);
	Method0(osgTerrain::DataSet::TextureType, getTextureType);
	Method1(void, setMaxAnisotropy, IN, float, d);
	Method0(float, getMaxAnisotropy);
	Method1(void, setMipMappingMode, IN, osgTerrain::DataSet::MipMappingMode, mipMappingMode);
	Method0(osgTerrain::DataSet::MipMappingMode, getMipMappingMode);
	Method1(void, setUseLocalTileTransform, IN, bool, flag);
	Method0(bool, getUseLocalTileTransform);
	Method1(void, setDecorateGeneratedSceneGraphWithCoordinateSystemNode, IN, bool, flag);
	Method0(bool, getDecorateGeneratedSceneGraphWithCoordinateSystemNode);
	Method1(void, setDecorateGeneratedSceneGraphWithMultiTextureControl, IN, bool, flag);
	Method0(bool, getDecorateGeneratedSceneGraphWithMultiTextureControl);
	Method0(unsigned int, getNumOfTextureLevels);
	Method1(void, setCommentString, IN, const std::string &, comment);
	Method0(const std::string &, getCommentString);
	Method1(void, setWriteNodeBeforeSimplification, IN, bool, flag);
	Method0(bool, getWriteNodeBeforeSimplification);
	Method9(osgTerrain::DataSet::CompositeDestination *, createDestinationGraph, IN, osgTerrain::DataSet::CompositeDestination *, parent, IN, osg::CoordinateSystemNode *, cs, IN, const osg::BoundingBox &, extents, IN, unsigned int, maxImageSize, IN, unsigned int, maxTerrainSize, IN, unsigned int, currentLevel, IN, unsigned int, currentX, IN, unsigned int, currentY, IN, unsigned int, maxNumLevels);
	Method1(void, computeDestinationGraphFromSources, IN, unsigned int, numLevels);
	Method0(void, updateSourcesForDestinationGraphNeeds);
	Method0(void, populateDestinationGraphFromSources);
	Method1(void, createDestination, IN, unsigned int, numLevels);
	Method0(void, buildDestination);
	Method0(void, writeDestination);
	Method0(osg::Node *, getDestinationRootNode);
	Method2(void, _writeNodeFile, IN, const osg::Node &, node, IN, const std::string &, filename);
	Method2(void, _writeImageFile, IN, const osg::Image &, image, IN, const std::string &, filename);
	Property(osgDB::Archive *, Archive);
	Property(const std::string &, ArchiveName);
	Property(const std::string &, CommentString);
	Property(bool, ConvertFromGeographicToGeocentric);
	Property(osgTerrain::DataSet::DatabaseType, DatabaseType);
	Property(bool, DecorateGeneratedSceneGraphWithCoordinateSystemNode);
	Property(bool, DecorateGeneratedSceneGraphWithMultiTextureControl);
	Property(const osg::Vec4 &, DefaultColor);
	Property(osg::CoordinateSystemNode *, DestinationCoordinateSystem);
	WriteOnlyProperty(const osg::BoundingBox &, DestinationExtents);
	WriteOnlyProperty(const osg::Matrixd &, DestinationGeoTransform);
	WriteOnlyProperty(const std::string &, DestinationName);
	ReadOnlyProperty(osg::Node *, DestinationRootNode);
	Property(const std::string &, DestinationTileBaseName);
	Property(const std::string &, DestinationTileExtension);
	Property(osg::EllipsoidModel *, EllipsoidModel);
	Property(osgTerrain::DataSet::GeometryType, GeometryType);
	Property(osg::CoordinateSystemNode *, IntermediateCoordinateSystem);
	Property(float, MaxAnisotropy);
	Property(unsigned int, MaximumTileImageSize);
	Property(unsigned int, MaximumTileTerrainSize);
	Property(float, MaximumVisibleDistanceOfTopLevel);
	Property(osgTerrain::DataSet::MipMappingMode, MipMappingMode);
	Property(float, RadiusToMaxVisibleDistanceRatio);
	Property(float, SkirtRatio);
	Property(osgTerrain::DataSet::TextureType, TextureType);
	Property(bool, UseLocalTileTransform);
	Property(float, VerticalScale);
	Property(bool, WriteNodeBeforeSimplification);
END_REFLECTOR

TYPE_NAME_ALIAS(std::vector< osg::ref_ptr< osgTerrain::DataSet::DestinationTile > >, osgTerrain::DataSet::CompositeDestination::TileList);

TYPE_NAME_ALIAS(std::vector< osg::ref_ptr< osgTerrain::DataSet::CompositeDestination > >, osgTerrain::DataSet::CompositeDestination::ChildList);

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::CompositeDestination)
	BaseType(osg::Referenced);
	BaseType(osgTerrain::DataSet::SpatialProperties);
	Constructor0();
	Constructor2(IN, osg::CoordinateSystemNode *, cs, IN, const osg::BoundingBox &, extents);
	Method0(void, computeNeighboursFromQuadMap);
	Method1(void, addRequiredResolutions, IN, osgTerrain::DataSet::CompositeSource *, sourceGraph);
	Method1(void, readFrom, IN, osgTerrain::DataSet::CompositeSource *, sourceGraph);
	Method0(void, equalizeBoundaries);
	Method0(osg::Node *, createScene);
	Method0(bool, areSubTilesComplete);
	Method0(std::string, getSubTileName);
	Method0(osg::Node *, createPagedLODScene);
	Method0(osg::Node *, createSubTileScene);
	Method0(void, unrefSubTileData);
	Method0(void, unrefLocalData);
	Method1(void, setSubTilesGenerated, IN, bool, generated);
	Method0(bool, getSubTilesGenerated);
	ReadOnlyProperty(std::string, SubTileName);
	Property(bool, SubTilesGenerated);
END_REFLECTOR

TYPE_NAME_ALIAS(std::vector< osg::ref_ptr< osgTerrain::DataSet::Source > >, osgTerrain::DataSet::CompositeSource::SourceList);

TYPE_NAME_ALIAS(std::vector< osg::ref_ptr< osgTerrain::DataSet::CompositeSource > >, osgTerrain::DataSet::CompositeSource::ChildList);

TYPE_NAME_ALIAS(osgTerrain::DataSet::CompositeSource::base_source_iterator< osgTerrain::DataSet::CompositeSource::DefaultSourceAdvancer >, osgTerrain::DataSet::CompositeSource::source_iterator);

TYPE_NAME_ALIAS(osgTerrain::DataSet::CompositeSource::base_source_iterator< osgTerrain::DataSet::CompositeSource::LODSourceAdvancer >, osgTerrain::DataSet::CompositeSource::source_lod_iterator);

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::CompositeSource)
	BaseType(osg::Referenced);
	BaseType(osgTerrain::DataSet::SpatialProperties);
	ConstructorWithDefaults1(IN, osgTerrain::DataSet::CompositeType, type, osgTerrain::DataSet::GROUP);
	Method1(void, setType, IN, osgTerrain::DataSet::CompositeType, type);
	Method0(osgTerrain::DataSet::CompositeType, getType);
	Method0(void, setSortValueFromSourceDataResolution);
	Method0(void, sort);
	Property(osgTerrain::DataSet::CompositeType, Type);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::CompositeSource::DefaultSourceAdvancer)
	Constructor0();
	Method2(bool, isActive, IN, const osgTerrain::DataSet::CompositeSource &, composite, IN, int, index);
	Method2(bool, advanceToNextSource, IN, const osgTerrain::DataSet::CompositeSource &, composite, IN, int &, index);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osgTerrain::DataSet::CompositeSource::iterator::IteratorMode)
	EnumLabel(osgTerrain::DataSet::CompositeSource::iterator::ACTIVE);
	EnumLabel(osgTerrain::DataSet::CompositeSource::iterator::ALL);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::CompositeSource::iterator)
	ConstructorWithDefaults2(IN, osgTerrain::DataSet::CompositeSource *, composite, 0, IN, osgTerrain::DataSet::CompositeSource::iterator::IteratorMode, mode, osgTerrain::DataSet::CompositeSource::iterator::ALL);
	Constructor1(IN, const osgTerrain::DataSet::CompositeSource::iterator &, rhs);
	Method0(bool, valid);
	Method0(bool, advance);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::CompositeSource::LODSourceAdvancer)
	ConstructorWithDefaults1(IN, float, targetResolution, 0.0f);
	Method2(bool, advanceToNextSource, IN, const osgTerrain::DataSet::CompositeSource &, composite, IN, int &, index);
END_REFLECTOR

TYPE_NAME_ALIAS(std::vector< osg::ref_ptr< osg::Image > >, osgTerrain::DataSet::DestinationData::ImageList);

TYPE_NAME_ALIAS(std::vector< osg::ref_ptr< osg::Node > >, osgTerrain::DataSet::DestinationData::ModelList);

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::DestinationData)
	BaseType(osg::Referenced);
	Constructor1(IN, osgTerrain::DataSet *, dataSet);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osgTerrain::DataSet::DestinationTile::Position)
	EnumLabel(osgTerrain::DataSet::DestinationTile::LEFT);
	EnumLabel(osgTerrain::DataSet::DestinationTile::LEFT_BELOW);
	EnumLabel(osgTerrain::DataSet::DestinationTile::BELOW);
	EnumLabel(osgTerrain::DataSet::DestinationTile::BELOW_RIGHT);
	EnumLabel(osgTerrain::DataSet::DestinationTile::RIGHT);
	EnumLabel(osgTerrain::DataSet::DestinationTile::RIGHT_ABOVE);
	EnumLabel(osgTerrain::DataSet::DestinationTile::ABOVE);
	EnumLabel(osgTerrain::DataSet::DestinationTile::ABOVE_LEFT);
	EnumLabel(osgTerrain::DataSet::DestinationTile::NUMBER_OF_POSITIONS);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::DestinationTile)
	BaseType(osg::Referenced);
	BaseType(osgTerrain::DataSet::SpatialProperties);
	Constructor0();
	Method0(void, computeNeighboursFromQuadMap);
	Method8(void, setNeighbours, IN, osgTerrain::DataSet::DestinationTile *, left, IN, osgTerrain::DataSet::DestinationTile *, left_below, IN, osgTerrain::DataSet::DestinationTile *, below, IN, osgTerrain::DataSet::DestinationTile *, below_right, IN, osgTerrain::DataSet::DestinationTile *, right, IN, osgTerrain::DataSet::DestinationTile *, right_above, IN, osgTerrain::DataSet::DestinationTile *, above, IN, osgTerrain::DataSet::DestinationTile *, above_left);
	Method0(void, checkNeighbouringTiles);
	Method2(void, setMaximumImagerySize, IN, unsigned int, maxNumColumns, IN, unsigned int, maxNumRows);
	Method2(void, setMaximumTerrainSize, IN, unsigned int, maxNumColumns, IN, unsigned int, maxNumRows);
	Method1(void, computeMaximumSourceResolution, IN, osgTerrain::DataSet::CompositeSource *, sourceGraph);
	Method5(bool, computeImageResolution, IN, unsigned int, layer, IN, unsigned int &, numColumns, IN, unsigned int &, numRows, IN, double &, resX, IN, double &, resY);
	Method4(bool, computeTerrainResolution, IN, unsigned int &, numColumns, IN, unsigned int &, numRows, IN, double &, resX, IN, double &, resY);
	Method0(void, allocate);
	Method1(void, addRequiredResolutions, IN, osgTerrain::DataSet::CompositeSource *, sourceGraph);
	Method1(void, readFrom, IN, osgTerrain::DataSet::CompositeSource *, sourceGraph);
	Method1(void, equalizeCorner, IN, osgTerrain::DataSet::DestinationTile::Position, position);
	Method1(void, equalizeEdge, IN, osgTerrain::DataSet::DestinationTile::Position, position);
	Method0(void, equalizeBoundaries);
	Method1(void, setTileComplete, IN, bool, complete);
	Method0(bool, getTileComplete);
	Method0(void, optimizeResolution);
	Method0(osg::Node *, createScene);
	Method0(osg::StateSet *, createStateSet);
	Method0(osg::Node *, createHeightField);
	Method0(osg::Node *, createPolygonal);
	Method0(void, unrefData);
	Method1(osgTerrain::DataSet::DestinationTile::ImageData &, getImageData, IN, unsigned int, layer);
	Property(bool, TileComplete);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::DestinationTile::ImageData)
	Constructor0();
END_REFLECTOR

TYPE_NAME_ALIAS(std::vector< osgTerrain::DataSet::Source::ResolutionPair >, osgTerrain::DataSet::Source::ResolutionList);

BEGIN_ENUM_REFLECTOR(osgTerrain::DataSet::Source::Type)
	EnumLabel(osgTerrain::DataSet::Source::IMAGE);
	EnumLabel(osgTerrain::DataSet::Source::HEIGHT_FIELD);
	EnumLabel(osgTerrain::DataSet::Source::MODEL);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osgTerrain::DataSet::Source::ParameterPolicy)
	EnumLabel(osgTerrain::DataSet::Source::PREFER_CONFIG_SETTINGS);
	EnumLabel(osgTerrain::DataSet::Source::PREFER_CONFIG_SETTINGS_BUT_SCALE_BY_FILE_RESOLUTION);
	EnumLabel(osgTerrain::DataSet::Source::PREFER_FILE_SETTINGS);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::Source)
	BaseType(osg::Referenced);
	BaseType(osgTerrain::DataSet::SpatialProperties);
	Constructor0();
	Constructor2(IN, osgTerrain::DataSet::Source::Type, type, IN, const std::string &, filename);
	Method1(void, setSortValue, IN, double, s);
	Method0(double, getSortValue);
	Method0(void, setSortValueFromSourceDataResolution);
	Method1(void, setType, IN, osgTerrain::DataSet::Source::Type, type);
	Method0(osgTerrain::DataSet::Source::Type, getType);
	Method1(void, setFileName, IN, const std::string &, filename);
	Method0(const std::string &, getFileName);
	Method1(void, setTemporaryFile, IN, bool, temporaryFile);
	Method0(bool, getTemporaryFile);
	Method1(void, setCoordinateSystemPolicy, IN, osgTerrain::DataSet::Source::ParameterPolicy, policy);
	Method0(osgTerrain::DataSet::Source::ParameterPolicy, getCoordinateSystemPolicy);
	Method1(void, setCoordinateSystem, IN, const std::string &, wellKnownText);
	Method1(void, setCoordinateSystem, IN, osg::CoordinateSystemNode *, cs);
	Method0(osg::CoordinateSystemNode *, getCoordinateSystem);
	Method1(void, setGeoTransformPolicy, IN, osgTerrain::DataSet::Source::ParameterPolicy, policy);
	Method0(osgTerrain::DataSet::Source::ParameterPolicy, getGeoTransformPolicy);
	Method1(void, setGeoTransform, IN, osg::Matrixd &, transform);
	Method0(osg::Matrixd &, getGeoTransform);
	Method4(void, setGeoTransformFromRange, IN, double, xMin, IN, double, xMax, IN, double, yMin, IN, double, yMax);
	Method0(void, assignCoordinateSystemAndGeoTransformAccordingToParameterPolicy);
	Method1(void, setMinLevel, IN, unsigned int, minLevel);
	Method1(void, setMaxLevel, IN, unsigned int, maxLevel);
	Method2(void, setMinMaxLevel, IN, unsigned int, minLevel, IN, unsigned int, maxLevel);
	Method0(unsigned int, getMinLevel);
	Method0(unsigned int, getMaxLevel);
	Method1(void, setLayer, IN, unsigned int, layer);
	Method0(unsigned int, getLayer);
	Method1(void, setSourceData, IN, osgTerrain::DataSet::SourceData *, data);
	Method0(osgTerrain::DataSet::SourceData *, getSourceData);
	Method1(bool, intersects, IN, const osgTerrain::DataSet::SpatialProperties &, sp);
	Method0(void, loadSourceData);
	Method1(bool, needReproject, IN, const osg::CoordinateSystemNode *, cs);
	Method3(bool, needReproject, IN, const osg::CoordinateSystemNode *, cs, IN, double, minResolution, IN, double, maxResolution);
	MethodWithDefaults3(osgTerrain::DataSet::Source *, doReproject, IN, const std::string &, filename, , IN, osg::CoordinateSystemNode *, cs, , IN, double, targetResolution, 0.0);
	Method0(void, buildOverviews);
	Method2(void, addRequiredResolution, IN, double, resX, IN, double, resY);
	Method1(void, setRequiredResolutions, IN, osgTerrain::DataSet::Source::ResolutionList &, resolutions);
	Method0(osgTerrain::DataSet::Source::ResolutionList &, getRequiredResolutions);
	Method0(const osgTerrain::DataSet::Source::ResolutionList &, getRequiredResolutions);
	Method0(void, consolodateRequiredResolutions);
	Property(osg::CoordinateSystemNode *, CoordinateSystem);
	Property(osgTerrain::DataSet::Source::ParameterPolicy, CoordinateSystemPolicy);
	Property(const std::string &, FileName);
	Property(osg::Matrixd &, GeoTransform);
	Property(osgTerrain::DataSet::Source::ParameterPolicy, GeoTransformPolicy);
	Property(unsigned int, Layer);
	Property(unsigned int, MaxLevel);
	Property(unsigned int, MinLevel);
	Property(osgTerrain::DataSet::Source::ResolutionList &, RequiredResolutions);
	Property(double, SortValue);
	Property(osgTerrain::DataSet::SourceData *, SourceData);
	Property(bool, TemporaryFile);
	Property(osgTerrain::DataSet::Source::Type, Type);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::Source::ResolutionPair)
	Constructor0();
	Constructor2(IN, double, x, IN, double, y);
END_REFLECTOR

TYPE_NAME_ALIAS(std::map< const osg::CoordinateSystemNode * COMMA  osgTerrain::DataSet::SpatialProperties >, osgTerrain::DataSet::SourceData::SpatialPropertiesMap);

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::SourceData)
	BaseType(osg::Referenced);
	BaseType(osgTerrain::DataSet::SpatialProperties);
	ConstructorWithDefaults1(IN, osgTerrain::DataSet::Source *, source, 0);
	Method1(osg::BoundingBox, getExtents, IN, const osg::CoordinateSystemNode *, cs);
	Method1(const osgTerrain::DataSet::SpatialProperties &, computeSpatialProperties, IN, const osg::CoordinateSystemNode *, cs);
	Method1(bool, intersects, IN, const osgTerrain::DataSet::SpatialProperties &, sp);
	Method1(void, read, IN, osgTerrain::DataSet::DestinationData &, destination);
	Method1(void, readImage, IN, osgTerrain::DataSet::DestinationData &, destination);
	Method1(void, readHeightField, IN, osgTerrain::DataSet::DestinationData &, destination);
	Method1(void, readModels, IN, osgTerrain::DataSet::DestinationData &, destination);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::SpatialProperties)
	Constructor0();
	Constructor1(IN, const osgTerrain::DataSet::SpatialProperties &, sp);
	Constructor2(IN, osg::CoordinateSystemNode *, cs, IN, const osg::BoundingBox &, extents);
	Method1(osgTerrain::DataSet::SpatialProperties &, assignSpatialProperties, IN, const osgTerrain::DataSet::SpatialProperties &, sp);
	Method0(void, computeExtents);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::ref_ptr< osg::Image >)
	Constructor0();
	Constructor1(IN, osg::Image *, t);
	Constructor1(IN, const osg::ref_ptr< osg::Image > &, rp);
	Method0(bool, valid);
	Method0(osg::Image *, get);
	Method0(const osg::Image *, get);
	Method0(osg::Image *, take);
	Method0(osg::Image *, release);
	ReadOnlyProperty(osg::Image *, );
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::ref_ptr< osgTerrain::DataSet::CompositeDestination >)
	Constructor0();
	Constructor1(IN, osgTerrain::DataSet::CompositeDestination *, t);
	Constructor1(IN, const osg::ref_ptr< osgTerrain::DataSet::CompositeDestination > &, rp);
	Method0(bool, valid);
	Method0(osgTerrain::DataSet::CompositeDestination *, get);
	Method0(const osgTerrain::DataSet::CompositeDestination *, get);
	Method0(osgTerrain::DataSet::CompositeDestination *, take);
	Method0(osgTerrain::DataSet::CompositeDestination *, release);
	ReadOnlyProperty(osgTerrain::DataSet::CompositeDestination *, );
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::ref_ptr< osgTerrain::DataSet::CompositeSource >)
	Constructor0();
	Constructor1(IN, osgTerrain::DataSet::CompositeSource *, t);
	Constructor1(IN, const osg::ref_ptr< osgTerrain::DataSet::CompositeSource > &, rp);
	Method0(bool, valid);
	Method0(osgTerrain::DataSet::CompositeSource *, get);
	Method0(const osgTerrain::DataSet::CompositeSource *, get);
	Method0(osgTerrain::DataSet::CompositeSource *, take);
	Method0(osgTerrain::DataSet::CompositeSource *, release);
	ReadOnlyProperty(osgTerrain::DataSet::CompositeSource *, );
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::ref_ptr< osgTerrain::DataSet::DestinationTile >)
	Constructor0();
	Constructor1(IN, osgTerrain::DataSet::DestinationTile *, t);
	Constructor1(IN, const osg::ref_ptr< osgTerrain::DataSet::DestinationTile > &, rp);
	Method0(bool, valid);
	Method0(osgTerrain::DataSet::DestinationTile *, get);
	Method0(const osgTerrain::DataSet::DestinationTile *, get);
	Method0(osgTerrain::DataSet::DestinationTile *, take);
	Method0(osgTerrain::DataSet::DestinationTile *, release);
	ReadOnlyProperty(osgTerrain::DataSet::DestinationTile *, );
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::ref_ptr< osgTerrain::DataSet::Source >)
	Constructor0();
	Constructor1(IN, osgTerrain::DataSet::Source *, t);
	Constructor1(IN, const osg::ref_ptr< osgTerrain::DataSet::Source > &, rp);
	Method0(bool, valid);
	Method0(osgTerrain::DataSet::Source *, get);
	Method0(const osgTerrain::DataSet::Source *, get);
	Method0(osgTerrain::DataSet::Source *, take);
	Method0(osgTerrain::DataSet::Source *, release);
	ReadOnlyProperty(osgTerrain::DataSet::Source *, );
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::CompositeSource::base_source_iterator< osgTerrain::DataSet::CompositeSource::DefaultSourceAdvancer >)
	ConstructorWithDefaults2(IN, osgTerrain::DataSet::CompositeSource *, composite, 0, IN, osgTerrain::DataSet::CompositeSource::DefaultSourceAdvancer, advancer, osgTerrain::DataSet::CompositeSource::DefaultSourceAdvancer());
	Constructor1(IN, const osgTerrain::DataSet::CompositeSource::base_source_iterator< osgTerrain::DataSet::CompositeSource::DefaultSourceAdvancer > &, rhs);
	Method0(bool, valid);
	Method0(bool, advance);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osgTerrain::DataSet::CompositeSource::base_source_iterator< osgTerrain::DataSet::CompositeSource::LODSourceAdvancer >)
	ConstructorWithDefaults2(IN, osgTerrain::DataSet::CompositeSource *, composite, 0, IN, osgTerrain::DataSet::CompositeSource::LODSourceAdvancer, advancer, osgTerrain::DataSet::CompositeSource::LODSourceAdvancer());
	Constructor1(IN, const osgTerrain::DataSet::CompositeSource::base_source_iterator< osgTerrain::DataSet::CompositeSource::LODSourceAdvancer > &, rhs);
	Method0(bool, valid);
	Method0(bool, advance);
END_REFLECTOR

STD_MAP_REFLECTOR(std::map< const osg::CoordinateSystemNode * COMMA  osgTerrain::DataSet::SpatialProperties >);

STD_MAP_REFLECTOR(std::map< unsigned int COMMA  osgTerrain::DataSet::CompositeDestination * >);

STD_MAP_REFLECTOR(std::map< unsigned int COMMA  osgTerrain::DataSet::Level >);

STD_MAP_REFLECTOR(std::map< unsigned int COMMA  osgTerrain::DataSet::Row >);

STD_VECTOR_REFLECTOR(std::vector< osg::ref_ptr< osg::Image > >);

STD_VECTOR_REFLECTOR(std::vector< osg::ref_ptr< osgTerrain::DataSet::CompositeDestination > >);

STD_VECTOR_REFLECTOR(std::vector< osg::ref_ptr< osgTerrain::DataSet::CompositeSource > >);

STD_VECTOR_REFLECTOR(std::vector< osg::ref_ptr< osgTerrain::DataSet::DestinationTile > >);

STD_VECTOR_REFLECTOR(std::vector< osg::ref_ptr< osgTerrain::DataSet::Source > >);

STD_VECTOR_REFLECTOR(std::vector< osgTerrain::DataSet::Source::ResolutionPair >);

