// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/CopyOp>
#include <osg/Image>
#include <osg/Object>
#include <osg/State>
#include <osg/StateAttribute>
#include <osg/Texture>
#include <osg/Vec4>

TYPE_NAME_ALIAS(std::list< osg::ref_ptr< osg::Texture::TextureObject > >, osg::Texture::TextureObjectList);

TYPE_NAME_ALIAS(std::map< unsigned int COMMA  osg::Texture::TextureObjectList >, osg::Texture::TextureObjectListMap);

BEGIN_ENUM_REFLECTOR(osg::Texture::WrapParameter)
	EnumLabel(osg::Texture::WRAP_S);
	EnumLabel(osg::Texture::WRAP_T);
	EnumLabel(osg::Texture::WRAP_R);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osg::Texture::WrapMode)
	EnumLabel(osg::Texture::CLAMP);
	EnumLabel(osg::Texture::CLAMP_TO_EDGE);
	EnumLabel(osg::Texture::CLAMP_TO_BORDER);
	EnumLabel(osg::Texture::REPEAT);
	EnumLabel(osg::Texture::MIRROR);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osg::Texture::FilterParameter)
	EnumLabel(osg::Texture::MIN_FILTER);
	EnumLabel(osg::Texture::MAG_FILTER);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osg::Texture::FilterMode)
	EnumLabel(osg::Texture::LINEAR);
	EnumLabel(osg::Texture::LINEAR_MIPMAP_LINEAR);
	EnumLabel(osg::Texture::LINEAR_MIPMAP_NEAREST);
	EnumLabel(osg::Texture::NEAREST);
	EnumLabel(osg::Texture::NEAREST_MIPMAP_LINEAR);
	EnumLabel(osg::Texture::NEAREST_MIPMAP_NEAREST);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osg::Texture::InternalFormatMode)
	EnumLabel(osg::Texture::USE_IMAGE_DATA_FORMAT);
	EnumLabel(osg::Texture::USE_USER_DEFINED_FORMAT);
	EnumLabel(osg::Texture::USE_ARB_COMPRESSION);
	EnumLabel(osg::Texture::USE_S3TC_DXT1_COMPRESSION);
	EnumLabel(osg::Texture::USE_S3TC_DXT3_COMPRESSION);
	EnumLabel(osg::Texture::USE_S3TC_DXT5_COMPRESSION);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osg::Texture::ShadowCompareFunc)
	EnumLabel(osg::Texture::LEQUAL);
	EnumLabel(osg::Texture::GEQUAL);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osg::Texture::ShadowTextureMode)
	EnumLabel(osg::Texture::LUMINANCE);
	EnumLabel(osg::Texture::INTENSITY);
	EnumLabel(osg::Texture::ALPHA);
END_REFLECTOR

BEGIN_ABSTRACT_OBJECT_REFLECTOR(osg::Texture)
	BaseType(osg::StateAttribute);
	Constructor0();
	ConstructorWithDefaults2(IN, const osg::Texture &, text, , IN, const osg::CopyOp &, copyop, osg::CopyOp::SHALLOW_COPY);
	Method0(osg::Object *, cloneType);
	Method1(osg::Object *, clone, IN, const osg::CopyOp &, copyop);
	Method1(bool, isSameKindAs, IN, const osg::Object *, obj);
	Method0(const char *, libraryName);
	Method0(const char *, className);
	Method0(osg::StateAttribute::Type, getType);
	Method0(bool, isTextureAttribute);
	Method2(void, setWrap, IN, osg::Texture::WrapParameter, which, IN, osg::Texture::WrapMode, wrap);
	Method1(osg::Texture::WrapMode, getWrap, IN, osg::Texture::WrapParameter, which);
	Method1(void, setBorderColor, IN, const osg::Vec4 &, color);
	Method0(const osg::Vec4 &, getBorderColor);
	Method1(void, setBorderWidth, IN, GLint, width);
	Method0(GLint, getBorderWidth);
	Method2(void, setFilter, IN, osg::Texture::FilterParameter, which, IN, osg::Texture::FilterMode, filter);
	Method1(osg::Texture::FilterMode, getFilter, IN, osg::Texture::FilterParameter, which);
	Method1(void, setMaxAnisotropy, IN, float, anis);
	Method0(float, getMaxAnisotropy);
	Method1(void, setUseHardwareMipMapGeneration, IN, bool, useHardwareMipMapGeneration);
	Method0(bool, getUseHardwareMipMapGeneration);
	Method1(void, setUnRefImageDataAfterApply, IN, bool, flag);
	Method0(bool, getUnRefImageDataAfterApply);
	Method1(void, setClientStorageHint, IN, bool, flag);
	Method0(bool, getClientStorageHint);
	Method1(void, setInternalFormatMode, IN, osg::Texture::InternalFormatMode, mode);
	Method0(osg::Texture::InternalFormatMode, getInternalFormatMode);
	Method1(void, setInternalFormat, IN, GLint, internalFormat);
	Method0(GLint, getInternalFormat);
	Method0(bool, isCompressedInternalFormat);
	Method1(osg::Texture::TextureObject *, getTextureObject, IN, unsigned int, contextID);
	Method0(void, dirtyTextureObject);
	Method0(bool, areAllTextureObjectsLoaded);
	Method1(unsigned int &, getTextureParameterDirty, IN, unsigned int, contextID);
	Method0(void, dirtyTextureParameters);
	Method1(void, setShadowComparison, IN, bool, flag);
	Method1(void, setShadowCompareFunc, IN, osg::Texture::ShadowCompareFunc, func);
	Method0(osg::Texture::ShadowCompareFunc, getShadowCompareFunc);
	Method1(void, setShadowTextureMode, IN, osg::Texture::ShadowTextureMode, mode);
	Method0(osg::Texture::ShadowTextureMode, getShadowTextureMode);
	Method1(void, setShadowAmbient, IN, float, shadow_ambient);
	Method0(float, getShadowAmbient);
	Method2(void, setImage, IN, unsigned int, face, IN, osg::Image *, image);
	Method1(osg::Image *, getImage, IN, unsigned int, face);
	Method1(const osg::Image *, getImage, IN, unsigned int, face);
	Method0(unsigned int, getNumImages);
	Method1(void, apply, IN, osg::State &, state);
	Method1(void, compileGLObjects, IN, osg::State &, state);
	MethodWithDefaults1(void, releaseGLObjects, IN, osg::State *, state, 0);
	Method6(void, applyTexImage2D_load, IN, osg::State &, state, IN, GLenum, target, IN, const osg::Image *, image, IN, GLsizei, width, IN, GLsizei, height, IN, GLsizei, numMipmapLevels);
	Method7(void, applyTexImage2D_subload, IN, osg::State &, state, IN, GLenum, target, IN, const osg::Image *, image, IN, GLsizei, width, IN, GLsizei, height, IN, GLint, inInternalFormat, IN, GLsizei, numMipmapLevels);
	Method1(void, takeTextureObjects, IN, osg::Texture::TextureObjectListMap &, toblm);
	Property(const osg::Vec4 &, BorderColor);
	Property(GLint, BorderWidth);
	Property(bool, ClientStorageHint);
	IndexedProperty1(osg::Texture::FilterMode, Filter, osg::Texture::FilterParameter, which);
	ArrayProperty_G(osg::Image *, Image, Images, unsigned int, void);
	Property(GLint, InternalFormat);
	Property(osg::Texture::InternalFormatMode, InternalFormatMode);
	Property(float, MaxAnisotropy);
	Property(float, ShadowAmbient);
	Property(osg::Texture::ShadowCompareFunc, ShadowCompareFunc);
	WriteOnlyProperty(bool, ShadowComparison);
	Property(osg::Texture::ShadowTextureMode, ShadowTextureMode);
	ReadOnlyProperty(osg::StateAttribute::Type, Type);
	Property(bool, UnRefImageDataAfterApply);
	Property(bool, UseHardwareMipMapGeneration);
	IndexedProperty1(osg::Texture::WrapMode, Wrap, osg::Texture::WrapParameter, which);
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osg::Texture::Extensions)
	BaseType(osg::Referenced);
	Constructor0();
	Constructor1(IN, const osg::Texture::Extensions &, rhs);
	Method1(void, lowestCommonDenominator, IN, const osg::Texture::Extensions &, rhs);
	Method0(void, setupGLExtensions);
	Method1(void, setMultiTexturingSupported, IN, bool, flag);
	Method0(bool, isMultiTexturingSupported);
	Method1(void, setTextureFilterAnisotropicSupported, IN, bool, flag);
	Method0(bool, isTextureFilterAnisotropicSupported);
	Method1(void, setTextureCompressionARBSupported, IN, bool, flag);
	Method0(bool, isTextureCompressionARBSupported);
	Method1(void, setTextureCompressionS3TCSupported, IN, bool, flag);
	Method0(bool, isTextureCompressionS3TCSupported);
	Method1(void, setTextureMirroredRepeatSupported, IN, bool, flag);
	Method0(bool, isTextureMirroredRepeatSupported);
	Method1(void, setTextureEdgeClampSupported, IN, bool, flag);
	Method0(bool, isTextureEdgeClampSupported);
	Method1(void, setTextureBorderClampSupported, IN, bool, flag);
	Method0(bool, isTextureBorderClampSupported);
	Method1(void, setGenerateMipMapSupported, IN, bool, flag);
	Method0(bool, isGenerateMipMapSupported);
	Method1(void, setShadowSupported, IN, bool, flag);
	Method0(bool, isShadowSupported);
	Method1(void, setShadowAmbientSupported, IN, bool, flag);
	Method0(bool, isShadowAmbientSupported);
	Method1(void, setMaxTextureSize, IN, GLint, maxsize);
	Method0(GLint, maxTextureSize);
	Method1(void, setNumTextureUnits, IN, GLint, nunits);
	Method0(GLint, numTextureUnits);
	Method0(bool, isCompressedTexImage2DSupported);
	Method1(void, setCompressedTexImage2DProc, IN, void *, ptr);
	Method8(void, glCompressedTexImage2D, IN, GLenum, target, IN, GLint, level, IN, GLenum, internalformat, IN, GLsizei, width, IN, GLsizei, height, IN, GLint, border, IN, GLsizei, imageSize, IN, const GLvoid *, data);
	Method1(void, setCompressedTexSubImage2DProc, IN, void *, ptr);
	Method9(void, glCompressedTexSubImage2D, IN, GLenum, target, IN, GLint, level, IN, GLint, xoffset, IN, GLint, yoffset, IN, GLsizei, width, IN, GLsizei, height, IN, GLenum, format, IN, GLsizei, type, IN, const GLvoid *, data);
	Method1(void, setGetCompressedTexImageProc, IN, void *, ptr);
	Method3(void, glGetCompressedTexImage, IN, GLenum, target, IN, GLint, level, IN, GLvoid *, data);
	Method0(bool, isClientStorageSupported);
	WriteOnlyProperty(void *, CompressedTexImage2DProc);
	WriteOnlyProperty(void *, CompressedTexSubImage2DProc);
	WriteOnlyProperty(bool, GenerateMipMapSupported);
	WriteOnlyProperty(void *, GetCompressedTexImageProc);
	WriteOnlyProperty(GLint, MaxTextureSize);
	WriteOnlyProperty(bool, MultiTexturingSupported);
	WriteOnlyProperty(GLint, NumTextureUnits);
	WriteOnlyProperty(bool, ShadowAmbientSupported);
	WriteOnlyProperty(bool, ShadowSupported);
	WriteOnlyProperty(bool, TextureBorderClampSupported);
	WriteOnlyProperty(bool, TextureCompressionARBSupported);
	WriteOnlyProperty(bool, TextureCompressionS3TCSupported);
	WriteOnlyProperty(bool, TextureEdgeClampSupported);
	WriteOnlyProperty(bool, TextureFilterAnisotropicSupported);
	WriteOnlyProperty(bool, TextureMirroredRepeatSupported);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::Texture::TextureObject)
	BaseType(osg::Referenced);
	Constructor2(IN, GLuint, id, IN, GLenum, target);
	Constructor8(IN, GLuint, id, IN, GLenum, target, IN, GLint, numMipmapLevels, IN, GLenum, internalFormat, IN, GLsizei, width, IN, GLsizei, height, IN, GLsizei, depth, IN, GLint, border);
	Method7(bool, match, IN, GLenum, target, IN, GLint, numMipmapLevels, IN, GLenum, internalFormat, IN, GLsizei, width, IN, GLsizei, height, IN, GLsizei, depth, IN, GLint, border);
	Method0(void, bind);
	MethodWithDefaults1(void, setAllocated, IN, bool, allocated, true);
	Method6(void, setAllocated, IN, GLint, numMipmapLevels, IN, GLenum, internalFormat, IN, GLsizei, width, IN, GLsizei, height, IN, GLsizei, depth, IN, GLint, border);
	Method0(bool, isAllocated);
	Method0(bool, isReusable);
	WriteOnlyProperty(bool, Allocated);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::ref_ptr< osg::Texture::TextureObject >)
	Constructor0();
	Constructor1(IN, osg::Texture::TextureObject *, t);
	Constructor1(IN, const osg::ref_ptr< osg::Texture::TextureObject > &, rp);
	Method0(bool, valid);
	Method0(osg::Texture::TextureObject *, get);
	Method0(const osg::Texture::TextureObject *, get);
	Method0(osg::Texture::TextureObject *, take);
	Method0(osg::Texture::TextureObject *, release);
	ReadOnlyProperty(osg::Texture::TextureObject *, );
END_REFLECTOR

STD_LIST_REFLECTOR(std::list< osg::ref_ptr< osg::Texture::TextureObject > >);

STD_MAP_REFLECTOR(std::map< unsigned int COMMA  osg::Texture::TextureObjectList >);

