// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/StaticMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/BoundingBox>
#include <osg/CopyOp>
#include <osg/Geode>
#include <osg/Geometry>
#include <osg/KdTree>
#include <osg/Object>
#include <osg/Shape>
#include <osg/Vec3>

// Must undefine IN and OUT macros defined in Windows headers
#ifdef IN
#undef IN
#endif
#ifdef OUT
#undef OUT
#endif

TYPE_NAME_ALIAS(std::multiset< osg::KdTree::LineSegmentIntersection >, osg::KdTree::LineSegmentIntersections)

TYPE_NAME_ALIAS(int, osg::KdTree::value_type)

TYPE_NAME_ALIAS(std::vector< osg::KdTree::value_type >, osg::KdTree::Indices)

TYPE_NAME_ALIAS(std::vector< unsigned int >, osg::KdTree::AxisStack)

TYPE_NAME_ALIAS(std::vector< osg::KdTree::KdNode >, osg::KdTree::KdNodeList)

TYPE_NAME_ALIAS(std::vector< osg::KdTree::KdLeaf >, osg::KdTree::KdLeafList)

TYPE_NAME_ALIAS(std::vector< osg::BoundingBox >, osg::KdTree::BoundingBoxList)

TYPE_NAME_ALIAS(std::vector< osg::KdTree::Triangle >, osg::KdTree::TriangleList)

TYPE_NAME_ALIAS(std::vector< osg::Vec3 >, osg::KdTree::CenterList)

BEGIN_OBJECT_REFLECTOR(osg::KdTree)
	I_DeclaringFile("osg/KdTree");
	I_BaseType(osg::Shape);
	I_Constructor0(____KdTree,
	               "",
	               "");
	I_ConstructorWithDefaults2(IN, const osg::KdTree &, rhs, , IN, const osg::CopyOp &, copyop, osg::CopyOp::SHALLOW_COPY,
	                           ____KdTree__C5_KdTree_R1__C5_osg_CopyOp_R1,
	                           "",
	                           "");
	I_Method0(osg::Object *, cloneType,
	          Properties::VIRTUAL,
	          __osg_Object_P1__cloneType,
	          "Clone the type of an attribute, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(osg::Object *, clone, IN, const osg::CopyOp &, copyop,
	          Properties::VIRTUAL,
	          __osg_Object_P1__clone__C5_osg_CopyOp_R1,
	          "Clone an attribute, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(bool, isSameKindAs, IN, const osg::Object *, obj,
	          Properties::VIRTUAL,
	          __bool__isSameKindAs__C5_osg_Object_P1,
	          "return true if this and obj are of the same kind of object. ",
	          "");
	I_Method0(const char *, libraryName,
	          Properties::VIRTUAL,
	          __C5_char_P1__libraryName,
	          "return the name of the attribute's library. ",
	          "");
	I_Method0(const char *, className,
	          Properties::VIRTUAL,
	          __C5_char_P1__className,
	          "return the name of the attribute's class type. ",
	          "");
	I_Method1(void, accept, IN, osg::ShapeVisitor &, sv,
	          Properties::VIRTUAL,
	          __void__accept__osg_ShapeVisitor_R1,
	          "accept a non const shape visitor which can be used on non const shape objects. ",
	          "Must be defined by derived classes. ");
	I_Method1(void, accept, IN, osg::ConstShapeVisitor &, csv,
	          Properties::VIRTUAL,
	          __void__accept__osg_ConstShapeVisitor_R1,
	          "accept a const shape visitor which can be used on const shape objects. ",
	          "Must be defined by derived classes. ");
	I_Method2(bool, build, IN, osg::KdTree::BuildOptions &, buildOptions, IN, osg::Geometry *, geometry,
	          Properties::VIRTUAL,
	          __bool__build__BuildOptions_R1__osg_Geometry_P1,
	          "Build the kdtree from the specified source geometry object. ",
	          "retun true on success. ");
	I_Method3(bool, intersect, IN, const osg::Vec3 &, start, IN, const osg::Vec3 &, end, IN, osg::KdTree::LineSegmentIntersections &, intersections,
	          Properties::VIRTUAL,
	          __bool__intersect__C5_osg_Vec3_R1__C5_osg_Vec3_R1__LineSegmentIntersections_R1,
	          "compute the intersection of a line segment and the kdtree, return true if an intersection has been found. ",
	          "");
	I_Method1(int, addLeaf, IN, const osg::KdTree::KdLeaf &, leaf,
	          Properties::NON_VIRTUAL,
	          __int__addLeaf__C5_KdLeaf_R1,
	          "note, leafNum is negative to distinguish from nodeNum ",
	          "");
	I_Method2(int, replaceLeaf, IN, int, leafNum, IN, const osg::KdTree::KdLeaf &, leaf,
	          Properties::NON_VIRTUAL,
	          __int__replaceLeaf__int__C5_KdLeaf_R1,
	          "",
	          "");
	I_Method1(osg::KdTree::KdLeaf &, getLeaf, IN, int, leafNum,
	          Properties::NON_VIRTUAL,
	          __KdLeaf_R1__getLeaf__int,
	          "note, leafNum is negative to distinguish from nodeNum ",
	          "");
	I_Method1(const osg::KdTree::KdLeaf &, getLeaf, IN, int, leafNum,
	          Properties::NON_VIRTUAL,
	          __C5_KdLeaf_R1__getLeaf__int,
	          "",
	          "");
	I_Method1(int, addNode, IN, const osg::KdTree::KdNode &, node,
	          Properties::NON_VIRTUAL,
	          __int__addNode__C5_KdNode_R1,
	          "",
	          "");
	I_Method1(osg::KdTree::KdNode &, getNode, IN, int, nodeNum,
	          Properties::NON_VIRTUAL,
	          __KdNode_R1__getNode__int,
	          "note, nodeNum is positive to distinguish from leftNum ",
	          "");
	I_Method1(const osg::KdTree::KdNode &, getNode, IN, int, nodeNum,
	          Properties::NON_VIRTUAL,
	          __C5_KdNode_R1__getNode__int,
	          "note, nodeNum is positive to distinguish from leftNum ",
	          "");
	I_Method1(osg::BoundingBox &, getBoundingBox, IN, int, nodeNum,
	          Properties::NON_VIRTUAL,
	          __osg_BoundingBox_R1__getBoundingBox__int,
	          "",
	          "");
	I_Method1(void, computeDivisions, IN, osg::KdTree::BuildOptions &, options,
	          Properties::NON_VIRTUAL,
	          __void__computeDivisions__BuildOptions_R1,
	          "",
	          "");
	I_Method4(int, divide, IN, osg::KdTree::BuildOptions &, options, IN, osg::BoundingBox &, bb, IN, int, nodeIndex, IN, unsigned int, level,
	          Properties::NON_VIRTUAL,
	          __int__divide__BuildOptions_R1__osg_BoundingBox_R1__int__unsigned_int,
	          "",
	          "");
	I_Method4(bool, intersect, IN, const osg::KdTree::KdLeaf &, leaf, IN, const osg::Vec3 &, start, IN, const osg::Vec3 &, end, IN, osg::KdTree::LineSegmentIntersections &, intersections,
	          Properties::NON_VIRTUAL,
	          __bool__intersect__C5_KdLeaf_R1__C5_osg_Vec3_R1__C5_osg_Vec3_R1__LineSegmentIntersections_R1,
	          "",
	          "");
	I_Method6(bool, intersect, IN, const osg::KdTree::KdNode &, node, IN, const osg::Vec3 &, start, IN, const osg::Vec3 &, end, IN, const osg::Vec3 &, s, IN, const osg::Vec3 &, e, IN, osg::KdTree::LineSegmentIntersections &, intersections,
	          Properties::NON_VIRTUAL,
	          __bool__intersect__C5_KdNode_R1__C5_osg_Vec3_R1__C5_osg_Vec3_R1__C5_osg_Vec3_R1__C5_osg_Vec3_R1__LineSegmentIntersections_R1,
	          "",
	          "");
	I_Method3(bool, intersectAndClip, IN, osg::Vec3 &, s, IN, osg::Vec3 &, e, IN, const osg::BoundingBox &, bb,
	          Properties::NON_VIRTUAL,
	          __bool__intersectAndClip__osg_Vec3_R1__osg_Vec3_R1__C5_osg_BoundingBox_R1,
	          "",
	          "");
	I_PublicMemberProperty(osg::observer_ptr< osg::Geometry >, _geometry);
	I_PublicMemberProperty(osg::BoundingBox, _bb);
	I_PublicMemberProperty(osg::KdTree::AxisStack, _axisStack);
	I_PublicMemberProperty(osg::KdTree::KdNodeList, _kdNodes);
	I_PublicMemberProperty(osg::KdTree::KdLeafList, _kdLeaves);
	I_PublicMemberProperty(osg::ref_ptr< osg::Vec3Array >, _vertices);
	I_PublicMemberProperty(osg::KdTree::Indices, _primitiveIndices);
	I_PublicMemberProperty(osg::KdTree::BoundingBoxList, _boundingBoxes);
	I_PublicMemberProperty(osg::KdTree::TriangleList, _triangles);
	I_PublicMemberProperty(osg::KdTree::CenterList, _centers);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::KdTree::BuildOptions)
	I_DeclaringFile("osg/KdTree");
	I_Constructor0(____BuildOptions,
	               "",
	               "");
	I_PublicMemberProperty(int, _numVerticesProcessed);
	I_PublicMemberProperty(int, _targetNumTrianglesPerLeaf);
	I_PublicMemberProperty(int, _maxNumLevels);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::KdTree::KdLeaf)
	I_DeclaringFile("osg/KdTree");
	I_Constructor0(____KdLeaf,
	               "",
	               "");
	I_Constructor2(IN, osg::KdTree::value_type, f, IN, osg::KdTree::value_type, s,
	               ____KdLeaf__value_type__value_type,
	               "",
	               "");
	I_PublicMemberProperty(osg::KdTree::value_type, first);
	I_PublicMemberProperty(osg::KdTree::value_type, second);
	I_PublicMemberProperty(osg::BoundingBox, bb);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::KdTree::KdNode)
	I_DeclaringFile("osg/KdTree");
	I_Constructor0(____KdNode,
	               "",
	               "");
	I_Constructor2(IN, osg::KdTree::value_type, f, IN, osg::KdTree::value_type, s,
	               ____KdNode__value_type__value_type,
	               "",
	               "");
	I_PublicMemberProperty(osg::KdTree::value_type, first);
	I_PublicMemberProperty(osg::KdTree::value_type, second);
	I_PublicMemberProperty(osg::BoundingBox, bb);
END_REFLECTOR

TYPE_NAME_ALIAS(std::vector< unsigned int >, osg::KdTree::LineSegmentIntersection::IndexList)

TYPE_NAME_ALIAS(std::vector< double >, osg::KdTree::LineSegmentIntersection::RatioList)

BEGIN_VALUE_REFLECTOR(osg::KdTree::LineSegmentIntersection)
	I_DeclaringFile("osg/KdTree");
	I_Constructor0(____LineSegmentIntersection,
	               "",
	               "");
	I_PublicMemberProperty(double, ratio);
	I_PublicMemberProperty(osg::Vec3d, intersectionPoint);
	I_PublicMemberProperty(osg::Vec3, intersectionNormal);
	I_PublicMemberProperty(osg::KdTree::LineSegmentIntersection::IndexList, indexList);
	I_PublicMemberProperty(osg::KdTree::LineSegmentIntersection::RatioList, ratioList);
	I_PublicMemberProperty(unsigned int, primitiveIndex);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::KdTree::Triangle)
	I_DeclaringFile("osg/KdTree");
	I_Constructor3(IN, unsigned int, p1, IN, unsigned int, p2, IN, unsigned int, p3,
	               ____Triangle__unsigned_int__unsigned_int__unsigned_int,
	               "",
	               "");
	I_PublicMemberProperty(unsigned int, _p1);
	I_PublicMemberProperty(unsigned int, _p2);
	I_PublicMemberProperty(unsigned int, _p3);
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osg::KdTreeBuilder)
	I_DeclaringFile("osg/KdTree");
	I_BaseType(osg::NodeVisitor);
	I_Constructor0(____KdTreeBuilder,
	               "",
	               "");
	I_Constructor1(IN, const osg::KdTreeBuilder &, rhs,
	               Properties::NON_EXPLICIT,
	               ____KdTreeBuilder__C5_KdTreeBuilder_R1,
	               "",
	               "");
	I_Method0(osg::KdTreeBuilder *, clone,
	          Properties::VIRTUAL,
	          __KdTreeBuilder_P1__clone,
	          "",
	          "");
	I_Method1(void, apply, IN, osg::Geode &, geode,
	          Properties::VIRTUAL,
	          __void__apply__osg_Geode_R1,
	          "",
	          "");
	I_PublicMemberProperty(osg::KdTree::BuildOptions, _buildOptions);
	I_PublicMemberProperty(osg::ref_ptr< osg::KdTree >, _kdTreePrototype);
END_REFLECTOR

STD_SET_REFLECTOR(std::multiset< osg::KdTree::LineSegmentIntersection >)

STD_VECTOR_REFLECTOR(std::vector< double >)

STD_VECTOR_REFLECTOR(std::vector< osg::BoundingBox >)

STD_VECTOR_REFLECTOR(std::vector< osg::KdTree::KdLeaf >)

STD_VECTOR_REFLECTOR(std::vector< osg::KdTree::KdNode >)

STD_VECTOR_REFLECTOR(std::vector< osg::KdTree::Triangle >)

STD_VECTOR_REFLECTOR(std::vector< osg::KdTree::value_type >)

