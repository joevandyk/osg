// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/StaticMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/Geometry>
#include <osg/Vec3>
#include <osgUtil/Tesselator>

// Must undefine IN and OUT macros defined in Windows headers
#ifdef IN
#undef IN
#endif
#ifdef OUT
#undef OUT
#endif

TYPE_NAME_ALIAS(std::vector< osg::Vec3 * >, osgUtil::Tesselator::VertexPointList);

TYPE_NAME_ALIAS(std::vector< osg::ref_ptr< osgUtil::Tesselator::Prim > >, osgUtil::Tesselator::PrimList);

BEGIN_ENUM_REFLECTOR(osgUtil::Tesselator::WindingType)
	I_EnumLabel(osgUtil::Tesselator::TESS_WINDING_ODD);
	I_EnumLabel(osgUtil::Tesselator::TESS_WINDING_NONZERO);
	I_EnumLabel(osgUtil::Tesselator::TESS_WINDING_POSITIVE);
	I_EnumLabel(osgUtil::Tesselator::TESS_WINDING_NEGATIVE);
	I_EnumLabel(osgUtil::Tesselator::TESS_WINDING_ABS_GEQ_TWO);
END_REFLECTOR

BEGIN_ENUM_REFLECTOR(osgUtil::Tesselator::TesselationType)
	I_EnumLabel(osgUtil::Tesselator::TESS_TYPE_GEOMETRY);
	I_EnumLabel(osgUtil::Tesselator::TESS_TYPE_DRAWABLE);
	I_EnumLabel(osgUtil::Tesselator::TESS_TYPE_POLYGONS);
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osgUtil::Tesselator)
	I_BaseType(osg::Referenced);
	I_Constructor0(____Tesselator,
	               "",
	               "");
	I_Method1(void, setBoundaryOnly, IN, const bool, tt,
	          __void__setBoundaryOnly__C5_bool,
	          "Set and get tesselation request boundary only on/off. ",
	          "");
	I_Method0(const bool, getBoundaryOnly,
	          __C5_bool__getBoundaryOnly,
	          "",
	          "");
	I_Method1(void, setWindingType, IN, const osgUtil::Tesselator::WindingType, wt,
	          __void__setWindingType__C5_WindingType,
	          "Set and get tesselation windong rule. ",
	          "");
	I_Method0(const osgUtil::Tesselator::WindingType, getWindingType,
	          __C5_WindingType__getWindingType,
	          "",
	          "");
	I_Method1(void, setTesselationType, IN, const osgUtil::Tesselator::TesselationType, tt,
	          __void__setTesselationType__C5_TesselationType,
	          "Set and get tesselation type. ",
	          "");
	I_Method0(const osgUtil::Tesselator::TesselationType, getTesselationType,
	          __C5_TesselationType__getTesselationType,
	          "",
	          "");
	I_Method1(void, retesselatePolygons, IN, osg::Geometry &, cxgeom,
	          __void__retesselatePolygons__osg_Geometry_R1,
	          "Change the contours lists of the geometry into tesselated primitives (the list of primitives in the original geometry is stored in the tesselator for possible re-use. ",
	          "The name remains retesselatePolygons although it now handles trifans, strips, quads etc. as well as Polygons so as to not break old codes relying on this function name. ");
	I_Method1(void, setTesselationNormal, IN, const osg::Vec3, norm,
	          __void__setTesselationNormal__C5_osg_Vec3,
	          "Define the normal to the tesselated polygon - this provides a hint how to tesselate the contours; see gluTessNormal in red book or man pages. ",
	          "GWM July 2005. Can improve teselation \"For example, if you know that all polygons lie in the x-y plane, call gluTessNormal(tess, 0.0, 0.0, 1.0) before rendering any polygons.\"");
	I_Method0(osg::Geometry::PrimitiveSetList, getContours,
	          __osg_Geometry_PrimitiveSetList__getContours,
	          "",
	          "");
	I_Method0(void, beginTesselation,
	          __void__beginTesselation,
	          "",
	          "");
	I_Method0(void, beginContour,
	          __void__beginContour,
	          "",
	          "");
	I_Method1(void, addVertex, IN, osg::Vec3 *, vertex,
	          __void__addVertex__osg_Vec3_P1,
	          "",
	          "");
	I_Method0(void, endContour,
	          __void__endContour,
	          "",
	          "");
	I_Method0(void, endTesselation,
	          __void__endTesselation,
	          "",
	          "");
	I_Method0(osgUtil::Tesselator::PrimList &, getPrimList,
	          __PrimList_R1__getPrimList,
	          "",
	          "");
	I_Method0(void, reset,
	          __void__reset,
	          "",
	          "");
	I_SimpleProperty(const bool, BoundaryOnly, 
	                 __C5_bool__getBoundaryOnly, 
	                 __void__setBoundaryOnly__C5_bool);
	I_SimpleProperty(osg::Geometry::PrimitiveSetList, Contours, 
	                 __osg_Geometry_PrimitiveSetList__getContours, 
	                 0);
	I_SimpleProperty(osgUtil::Tesselator::PrimList &, PrimList, 
	                 __PrimList_R1__getPrimList, 
	                 0);
	I_SimpleProperty(const osg::Vec3, TesselationNormal, 
	                 0, 
	                 __void__setTesselationNormal__C5_osg_Vec3);
	I_SimpleProperty(const osgUtil::Tesselator::TesselationType, TesselationType, 
	                 __C5_TesselationType__getTesselationType, 
	                 __void__setTesselationType__C5_TesselationType);
	I_SimpleProperty(const osgUtil::Tesselator::WindingType, WindingType, 
	                 __C5_WindingType__getWindingType, 
	                 __void__setWindingType__C5_WindingType);
END_REFLECTOR

TYPE_NAME_ALIAS(std::vector< osg::Vec3 * >, osgUtil::Tesselator::Prim::VecList);

BEGIN_OBJECT_REFLECTOR(osgUtil::Tesselator::Prim)
	I_BaseType(osg::Referenced);
	I_Constructor1(IN, GLenum, mode,
	               ____Prim__GLenum,
	               "",
	               "");
	I_PublicMemberProperty(GLenum, _mode);
	I_PublicMemberProperty(osgUtil::Tesselator::Prim::VecList, _vertices);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::ref_ptr< osgUtil::Tesselator::Prim >)
	I_Constructor0(____ref_ptr,
	               "",
	               "");
	I_Constructor1(IN, osgUtil::Tesselator::Prim *, ptr,
	               ____ref_ptr__T_P1,
	               "",
	               "");
	I_Constructor1(IN, const osg::ref_ptr< osgUtil::Tesselator::Prim > &, rp,
	               ____ref_ptr__C5_ref_ptr_R1,
	               "",
	               "");
	I_Method0(osgUtil::Tesselator::Prim *, get,
	          __T_P1__get,
	          "",
	          "");
	I_Method0(bool, valid,
	          __bool__valid,
	          "",
	          "");
	I_Method0(osgUtil::Tesselator::Prim *, release,
	          __T_P1__release,
	          "",
	          "");
	I_Method1(void, swap, IN, osg::ref_ptr< osgUtil::Tesselator::Prim > &, rp,
	          __void__swap__ref_ptr_R1,
	          "",
	          "");
	I_SimpleProperty(osgUtil::Tesselator::Prim *, , 
	                 __T_P1__get, 
	                 0);
END_REFLECTOR

STD_VECTOR_REFLECTOR(std::vector< osg::Vec3 * >);

STD_VECTOR_REFLECTOR(std::vector< osg::ref_ptr< osgUtil::Tesselator::Prim > >);

