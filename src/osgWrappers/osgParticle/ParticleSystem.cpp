// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/BoundingBox>
#include <osg/CopyOp>
#include <osg/Object>
#include <osg/State>
#include <osg/Vec3>
#include <osgParticle/Particle>
#include <osgParticle/ParticleSystem>

BEGIN_ENUM_REFLECTOR(osgParticle::ParticleSystem::Alignment)
	EnumLabel(osgParticle::ParticleSystem::BILLBOARD);
	EnumLabel(osgParticle::ParticleSystem::FIXED);
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osgParticle::ParticleSystem)
	BaseType(osg::Drawable);
	Constructor0();
	ConstructorWithDefaults2(IN, const osgParticle::ParticleSystem &, copy, , IN, const osg::CopyOp &, copyop, osg::CopyOp::SHALLOW_COPY);
	Method0(osg::Object *, cloneType);
	Method1(osg::Object *, clone, IN, const osg::CopyOp &, copyop);
	Method1(bool, isSameKindAs, IN, const osg::Object *, obj);
	Method0(const char *, libraryName);
	Method0(const char *, className);
	Method0(osgParticle::ParticleSystem::Alignment, getParticleAlignment);
	Method1(void, setParticleAlignment, IN, osgParticle::ParticleSystem::Alignment, a);
	Method0(const osg::Vec3 &, getAlignVectorX);
	Method1(void, setAlignVectorX, IN, const osg::Vec3 &, v);
	Method0(const osg::Vec3 &, getAlignVectorY);
	Method1(void, setAlignVectorY, IN, const osg::Vec3 &, v);
	Method2(void, setAlignVectors, IN, const osg::Vec3 &, X, IN, const osg::Vec3 &, Y);
	Method0(const osg::BoundingBox &, getDefaultBoundingBox);
	Method1(void, setDefaultBoundingBox, IN, const osg::BoundingBox &, bbox);
	Method0(bool, getDoublePassRendering);
	Method1(void, setDoublePassRendering, IN, bool, v);
	Method0(bool, isFrozen);
	Method1(void, setFrozen, IN, bool, v);
	Method0(int, numParticles);
	Method0(int, numDeadParticles);
	Method0(bool, areAllParticlesDead);
	Method1(osgParticle::Particle *, getParticle, IN, int, i);
	Method1(const osgParticle::Particle *, getParticle, IN, int, i);
	Method1(osgParticle::Particle *, createParticle, IN, const osgParticle::Particle *, ptemplate);
	Method1(void, destroyParticle, IN, int, i);
	Method0(int, getLastFrameNumber);
	Method0(osgParticle::Particle &, getDefaultParticleTemplate);
	Method0(const osgParticle::Particle &, getDefaultParticleTemplate);
	Method1(void, setDefaultParticleTemplate, IN, const osgParticle::Particle &, p);
	Method0(bool, getFreezeOnCull);
	Method1(void, setFreezeOnCull, IN, bool, v);
	MethodWithDefaults4(void, setDefaultAttributes, IN, const std::string &, texturefile, "", IN, bool, emissive_particles, true, IN, bool, lighting, false, IN, int, texture_unit, 0);
	Method0(int, getLevelOfDetail);
	Method1(void, setLevelOfDetail, IN, int, v);
	Method1(void, update, IN, double, dt);
	Method1(void, drawImplementation, IN, osg::State &, state);
	Method0(osg::BoundingBox, computeBound);
	Property(const osg::Vec3 &, AlignVectorX);
	Property(const osg::Vec3 &, AlignVectorY);
	Property(const osg::BoundingBox &, DefaultBoundingBox);
	Property(const osgParticle::Particle &, DefaultParticleTemplate);
	Property(bool, DoublePassRendering);
	Property(bool, FreezeOnCull);
	WriteOnlyProperty(bool, Frozen);
	ReadOnlyProperty(int, LastFrameNumber);
	Property(int, LevelOfDetail);
	Property(osgParticle::ParticleSystem::Alignment, ParticleAlignment);
END_REFLECTOR

