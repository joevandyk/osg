/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_KDTREE
#define OSG_KDTREE 1

#include <osg/Shape>
#include <osg/Geometry>

namespace osg
{

/** Implementation of a kdtree for Geometry leaves, to enable fast intersection tests.*/
class OSG_EXPORT KdTree : public osg::Shape 
{
    public:
    
        
        KdTree();
        
        KdTree(const KdTree& rhs, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);

        META_Shape(osg, KdTree)
        
        struct BuildOptions
        {
            BuildOptions();
                        
            int _numVerticesProcessed;
            int _targetNumTrianglesPerLeaf;
            int _maxNumLevels;
        };
        
        
        /** Build the kdtree from the specified source geometry object.
          * retun true on success. */ 
        virtual bool build(BuildOptions& buildOptions, osg::Geometry* geometry);
        
        struct LineSegmentIntersection
        {
            LineSegmentIntersection():
                ratio(-1.0),
                primitiveIndex(0) {}

            bool operator < (const LineSegmentIntersection& rhs) const { return ratio < rhs.ratio; }

            typedef std::vector<unsigned int>   IndexList;
            typedef std::vector<double>         RatioList;

            double                          ratio;
            osg::Vec3d                      intersectionPoint;
            osg::Vec3                       intersectionNormal;
            IndexList                       indexList;
            RatioList                       ratioList;
            unsigned int                    primitiveIndex;
        };        
        

        typedef std::multiset<LineSegmentIntersection> LineSegmentIntersections;
        
        /** compute the intersection of a line segment and the kdtree, return true if an intersection has been found.*/
        virtual bool intersect(const osg::Vec3& start, const osg::Vec3& end, LineSegmentIntersections& intersections) const;



        typedef int value_type;
        typedef std::vector< value_type >   Indices;

        struct KdNode
        {
            KdNode():
                first(0),
                second(0) {}

            KdNode(value_type f, value_type s):
                first(f),
                second(s) {}

            osg::BoundingBox bb;

            value_type first;    
            value_type second;
        };


        struct KdLeaf
        {
            KdLeaf():
                first(0),
                second(0) {}

            KdLeaf(value_type f, value_type s):
                first(f),
                second(s) {}

            osg::BoundingBox bb;

            value_type first;    
            value_type second;
        };

        struct Triangle
        {
            Triangle(unsigned int p1, unsigned int p2, unsigned int p3):
                _p1(p1), _p2(p2), _p3(p3) {}

            bool operator < (const Triangle& rhs) const
            {
                if (_p1<rhs._p1) return true;
                if (_p1>rhs._p1) return false;
                if (_p2<rhs._p2) return true;
                if (_p2>rhs._p2) return false;
                return _p3<rhs._p3;
            }

            unsigned int _p1;
            unsigned int _p2;
            unsigned int _p3;    
        };

        typedef std::vector< unsigned int > AxisStack;
        typedef std::vector< KdNode >       KdNodeList;
        typedef std::vector< KdLeaf >       KdLeafList;

        /// note, leafNum is negative to distinguish from nodeNum
        int addLeaf(const KdLeaf& leaf) { int num = _kdLeaves.size(); _kdLeaves.push_back(leaf); return -(num+1); }

        int replaceLeaf(int leafNum, const KdLeaf& leaf)
        {
            int num = -leafNum-1; 
            
            if (num>static_cast<int>(_kdLeaves.size())-1)
            {
                osg::notify(osg::NOTICE)<<"Warning: replaceChild("<<leafNum<<", leaf), num = "<<num<<" _kdLeaves.size()="<<_kdLeaves.size()<<std::endl;
                return leafNum;
            }
            
            _kdLeaves[num] = leaf; return leafNum;
        }

        /// note, leafNum is negative to distinguish from nodeNum
        KdLeaf& getLeaf(int leafNum)
        {
            int num = -leafNum-1;
            if (num<0 || num>static_cast<int>(_kdLeaves.size())-1)
            {
                osg::notify(osg::NOTICE)<<"Warning: getLeaf("<<leafNum<<", num = "<<num<<") _kdLeaves.size()="<<_kdLeaves.size()<<std::endl;
            }

            return _kdLeaves[num];
        }

        const KdLeaf& getLeaf(int leafNum) const
        {
            int num = -leafNum-1;
            if (num<0 || num>static_cast<int>(_kdLeaves.size())-1)
            {
                osg::notify(osg::NOTICE)<<"Warning: getLeaf("<<leafNum<<", num = "<<num<<") _kdLeaves.size()="<<_kdLeaves.size()<<std::endl;
            }

            return _kdLeaves[num];
        }

        int addNode(const KdNode& node)
        {
            int num = _kdNodes.size(); 
            _kdNodes.push_back(node); 
            return num;
        }

        /// note, nodeNum is positive to distinguish from leftNum
        KdNode& getNode(int nodeNum)
        {
            if (nodeNum<0 || nodeNum>static_cast<int>(_kdNodes.size())-1)
            {
                osg::notify(osg::NOTICE)<<"Warning: getNode("<<nodeNum<<") _kdNodes.size()="<<_kdNodes.size()<<std::endl;
            }
            return _kdNodes[nodeNum];
        }

        /// note, nodeNum is positive to distinguish from leftNum
        const KdNode& getNode(int nodeNum) const
        {
            if (nodeNum<0 || nodeNum>static_cast<int>(_kdNodes.size())-1)
            {
                osg::notify(osg::NOTICE)<<"Warning: getNode("<<nodeNum<<") _kdNodes.size()="<<_kdNodes.size()<<std::endl;
            }
            return _kdNodes[nodeNum];
        }
        
        osg::BoundingBox& getBoundingBox(int nodeNum)
        {
            if (nodeNum<0)
            {
                int num = -nodeNum-1;
                return _kdLeaves[num].bb;            
            }
            else
            {
                return _kdNodes[nodeNum].bb;
            }
        }


        void computeDivisions(BuildOptions& options);

        int divide(BuildOptions& options, osg::BoundingBox& bb, int nodeIndex, unsigned int level);

        bool intersect(const KdLeaf& leaf, const osg::Vec3& start, const osg::Vec3& end, LineSegmentIntersections& intersections) const;
        bool intersect(const KdNode& node, const osg::Vec3& start, const osg::Vec3& end, const osg::Vec3& s, const osg::Vec3& e, LineSegmentIntersections& intersections) const;
        bool intersectAndClip(osg::Vec3& s, osg::Vec3& e, const osg::BoundingBox& bb) const;

        typedef std::vector< osg::BoundingBox >                 BoundingBoxList;
        typedef std::vector< Triangle >                         TriangleList;
        typedef std::vector< osg::Vec3 >                        CenterList;

        osg::observer_ptr<osg::Geometry>    _geometry;

        osg::BoundingBox                    _bb;

        AxisStack                           _axisStack;
        KdNodeList                          _kdNodes;
        KdLeafList                          _kdLeaves;

        osg::ref_ptr<osg::Vec3Array>        _vertices;
        
        Indices                             _primitiveIndices;
        
        BoundingBoxList                     _boundingBoxes;
        TriangleList                        _triangles;
        CenterList                          _centers;

};

class OSG_EXPORT KdTreeBuilder : public osg::NodeVisitor
{
    public:
    
        KdTreeBuilder();
    
        KdTreeBuilder(const KdTreeBuilder& rhs);

        virtual KdTreeBuilder* clone() { return new KdTreeBuilder(*this); }

        void apply(osg::Geode& geode);
    
        KdTree::BuildOptions _buildOptions;

        osg::ref_ptr<osg::KdTree> _kdTreePrototype;
                
    protected:
    
        virtual ~KdTreeBuilder() {}
        
};

}

#endif
