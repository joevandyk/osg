//C++ header - Open Scene Graph - Copyright (C) 1998-2001 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSG_NODECALLBACK
#define OSG_NODECALLBACK 1

#include <osg/Referenced>

namespace osg {

class Node;
class NodeVisitor;

class SG_EXPORT NodeCallback : public Referenced {

    public :
    
        /** The range of values which can be accumulated by the NodeVisitor. */
        enum Requirements
        {
            NO_REQUIREMENTS = 0x0,
            REQUIRES_TRAVERSAL = 0x1,
            REQUIRES_PARENT_PATH = 0x2,
            REQUIRES_ACCUMULATED_MATRIX = 0x4,
            REQUIRES_ACCUMULATED_INVERSE = 0x8
        };

        NodeCallback(const Requirements ncr=NO_REQUIREMENTS):_requirements(ncr) {}
        virtual ~NodeCallback() {}
        
        
        /** Set what values from traversal are required by this NodeCallback.*/
        inline void setRequirements(const Requirements ncr) { _requirements=ncr; }

        /** Get what values from traversal are required by this NodeCallback.*/
        inline const Requirements getRequirements() const { return _requirements; }
        
        /** Callback method call by the NodeVisitor when visiting a node.*/
        virtual void operator()(Node*, NodeVisitor*) {}
        
        /** Call any nested callbacks and then traverse the scene graph. */
        void traverse(Node* node,NodeVisitor* nv);
        
        void setNestedCallback(NodeCallback* nc) { _nestedCallback = nc; }
        NodeCallback* getNestedCallback() { return _nestedCallback.get(); }
        
        inline void addNestedCallback(NodeCallback* nc)
        {
            if (nc)
            {
                if (_nestedCallback.valid())
                {
                    nc->addNestedCallback(_nestedCallback.get());
                    _nestedCallback = nc;
                }
                else
                {
                    _nestedCallback = nc;
                }
            }
        }
        
        inline void removeNestedCallback(NodeCallback* nc)
        {
            if (nc)
            {
                if (_nestedCallback==nc)
                {
                    NodeCallback* nested_nc = _nestedCallback->getNestedCallback();
                    if (nested_nc) _nestedCallback = nc;
                    else _nestedCallback = 0;
                }
                else
                {
                    _nestedCallback->removeNestedCallback(nc);
                }
            }
        }
        
   public:

        Requirements _requirements;
        
        ref_ptr<NodeCallback> _nestedCallback;
};

} // namespace

#endif

