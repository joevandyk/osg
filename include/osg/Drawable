//C++ header - Open Scene Graph - Copyright (C) 1998-2001 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSG_DRAWABLE
#define OSG_DRAWABLE 1

#include <osg/BoundingBox>
#include <osg/StateSet>
#include <osg/State>
#include <osg/Types>
#include <osg/Vec2>

#include <vector>
#include <map>
#include <set>

namespace osg {

class Statistics;
class Vec2;
class Vec3;
class Vec4;



/** Pure virtual base class for drawable Geometry.  Contains no drawing primitives
    directly, these are provided by subclasses such as GeoSet. State attributes 
    for a Drawable are maintained in StateSet which the Drawable maintains
    a referenced counted pointer to.  Both Drawable's and StateSet's can 
    be shared for optimal memory usage and graphics performance.
*/
class SG_EXPORT Drawable : public Object
{
    public:

        Drawable();

        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const Drawable*>(obj)!=NULL; }
        virtual const char* className() const { return "Drawable"; }

        /** Set the StateSet attached to the Drawable.
            Previously attached StateSet are automatically unreferenced on 
            assignment of a new drawstate.*/
        inline void setStateSet(StateSet *state) { _dstate = state; }
        
        /** Get the attached StateSet.*/
        inline StateSet* getStateSet() { return _dstate.get();}

        /** Get the attached const StateSet.*/
        inline const StateSet* getStateSet() const { return _dstate.get();}


        /** Set the drawable to it can or cannot be used in conjunction with OpenGL
          * display lists.  With set to true, calls to Drawable::setUseDisplayList,
          * whereas when set to false, no display lists can be created and calls
          * to setUseDisplayList are ignored, and a warning is produced.  The later
          * is typically used to guard against the switching on of display lists
          * on objects with dynamic internal data such as continuous Level of Detail
          * algorithms.*/
        void setSupportsDisplayList(const bool flag);
      
        /** Get whether display lists are supported for this drawable instance.*/  
        inline const bool getSupportsDisplayList() const { return _supportsDisplayList; }


        /** When set to true, force the draw method to use OpenGL Display List for rendering.
            If false rendering directly.  If the display list has not been already
            compile the next call to draw will automatically create the display list.*/
        void setUseDisplayList(const bool flag);

        /** Return whether OpenGL display lists are being used for rendering.*/
        inline const bool getUseDisplayList() const { return _useDisplayList; }

        /** Force a recompile on next draw() of any OpenGL display list associated with this geoset.*/
        void dirtyDisplayList();
        
        
        /** Dirty the bounding box, forcing a computeBound() on the next call
          * to getBound(). Should be called in the internal geometry of the Drawable
          * is modified.*/        
        inline void dirtyBound() { _bbox_computed = false; }

        /** get bounding box of geoset. 
          * Note, now made virtual to make it possible to implement user-drawn
          * objects albeit so what crudely, to be improved later.
          */
        inline const BoundingBox& getBound() const
        {
            if( !_bbox_computed)
                computeBound();
            return _bbox;
        }

        /** draw OpenGL primitives. 
          * If the drawable has _useDisplayList set to true then use an OpenGL display
          * list, automatically compiling one if required.
          * Otherwise call drawImmediateMode().
          * Note, draw method should *not* be overridden in subclasses as it 
          * manages the optional display list.
          */
        inline void draw(State& state);
        
        /** Immediately compile this drawable into an OpenGL Display List.
            Note I, operation is ignored if _useDisplayList to false.
            Note II, compile is not intended to be overridden in subclasses.*/
        void compile(State& state);

        /** draw directly ignoring an OpenGL display list which could be attached.
          * This is the internal draw method which does the drawing itself,
          * and is the method to override when deriving from Drawable.
          */
        virtual void drawImmediateMode(State& state) = 0;

        /** use deleteDisplayList instead of glDeleteList to allow
          * OpenGL display list to cached until they can be deleted
          * by the OpenGL context in which they were created, specified
          * by contextID.*/
        static void deleteDisplayList(uint contextID,uint globj);
        
        /** flush all the cached display list which need to be deleted
          * in the OpenGL context related to contextID.*/
        static void flushDeletedDisplayLists(uint contextID);
        

        /** Collect Stistics count from Drawable.*/
        virtual bool getStats(Statistics&) { return false; }
        

        typedef uint AttributeBitMask;

        enum AttributeBitMaskValues
        {
            COORDS              = 0x1,
            NORMALS             = 0x2,
            COLORS              = 0x4,
            TEXTURE_COORDS      = 0x8,
            TEXTURE_COORDS_0    = TEXTURE_COORDS,
	    /*
	     * Robert,
	     * These would have kept you up late if you were
	     * trying to use these as bitmasks
            TEXTURE_COORDS_1    = 0x16,
            TEXTURE_COORDS_2    = 0x32,
            TEXTURE_COORDS_3    = 0x64
	     */
            TEXTURE_COORDS_1    = 0x10,
            TEXTURE_COORDS_2    = 0x20,
            TEXTURE_COORDS_3    = 0x40
        };
        
        class AttributeFunctor
        {
        public:
        
            AttributeFunctor(AttributeBitMask abm):_abm(abm) {}
            virtual ~AttributeFunctor() {}
        
            void setAttributeBitMask(AttributeBitMask abm) { _abm=abm; }
            AttributeBitMask getAttributeBitMask() const { return _abm; }
        
            virtual bool apply(AttributeBitMask,Vec2*,Vec2*) { return false; }
            virtual bool apply(AttributeBitMask,Vec3*,Vec3*) { return false; }
            virtual bool apply(AttributeBitMask,Vec4*,Vec4*) { return false; }
            
        protected:
        
            AttributeBitMask _abm;
        };

        /** return the attributes supported by applyAttrbuteOperation() as an AttributeBitMask.*/
        virtual AttributeBitMask suppportsAttributeOperation() const { return (AttributeBitMask)0; }

        /** return the attributes successully applied in applyAttributeUpdate.*/
        virtual AttributeBitMask applyAttributeOperation(AttributeFunctor&) { return 0; }
        

    protected:

        Drawable(const Drawable&):Object() {}
        Drawable& operator = (const Drawable&) { return *this;}

        virtual ~Drawable();

        /** compute the bounding box of the drawable. Method must be 
            implemented by subclasses.*/
        virtual const bool computeBound() const = 0;

        ref_ptr<StateSet>      _dstate;

        bool                    _supportsDisplayList;
        bool                    _useDisplayList;

        typedef std::vector<uint> GLObjectList;
        mutable GLObjectList _globjList;

        mutable BoundingBox     _bbox;
        mutable bool            _bbox_computed;
        
        // static cache of deleted display lists which can only 
        // by completely deleted once the appropriate OpenGL context
        // is set.
        typedef std::map<uint,std::set<uint> > DeletedDisplayListCache;
        static DeletedDisplayListCache s_deletedDisplayListCache;

};

inline void Drawable::draw(State& state)
{
    if (_useDisplayList)
    {

        // get the contextID (user defined ID of 0 upwards) for the 
        // current OpenGL context.
        uint contextID = state.getContextID();

        // fill in array if required.
        while (_globjList.size()<=contextID) _globjList.push_back(0);

        // get the globj for the current contextID.
        uint& globj = _globjList[contextID];

        // call the globj if already set otherwise compile and execute.
        if( globj != 0 )
        {
            glCallList( globj );
        }
        else if (_useDisplayList)
        {
            globj = glGenLists( 1 );
            glNewList( globj, GL_COMPILE_AND_EXECUTE );
            drawImmediateMode(state);
            glEndList();
        }

    }
    else
    {
        // draw object as nature intended..
        drawImmediateMode(state);
    }
}

};

#endif
