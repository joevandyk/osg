//C++ header - Open Scene Graph - Copyright (C) 1998-2001 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSG_TRANSFORM
#define OSG_TRANSFORM 1

#include <osg/Group>
#include <osg/Matrix>

namespace osg {

/** Transform - is group which all children
  * are transformed by the the Transform's osg::Matrix.  Typical uses
  * of the Transform is for positioning objects within a scene or 
  * producing trackball functionality or for animation.
  * Note, if the transformation matrix scales the subgraph then the
  * normals of the underlying geometry will need to be renormalized to
  * be unit vectors once more.  One can done transparently through OpenGL's 
  * use of either GL_NORMALIZE and GL_SCALE_NORMALIZE modes.  Further
  * background reading see the glNormalize documentation in the OpenGL Reference 
  * Guide (the blue book). To enable it in the OSG, you simple need to
  * attach a local osg::StateSet to the osg::Transform, and set the appropriate
  * mode to on via stateset->setMode(GL_NORMALIZE,osg::StateAttribute::ON);.
*/
class SG_EXPORT Transform : public Group
{
    public :
        Transform();
        Transform(const Matrix& matix);

        META_Node(Transform);

        /** Range of types that the Transform can be.*/
        enum Type
        {
            DYNAMIC,
            STATIC
        };
        
        /** Set the Transform Type, which can be DYNAMIC - the Matrix
          * value is updated during the main loop, or STATIC - the Matrix
          * is constant throughout the life of the main loop.  STATIC 
          * Transforms can be optimized away is some instances, which
          * can improve performance so unless you plan to modify the
          * Matrix explicitly set the Matrix to STATIC.  The default
          * value is DYNAMIC.*/
        inline void setType(Type type) { _type = type; }

        /** Get the Transform Type.*/
        inline const Type getType() const { return _type; }
        
        
        
        /** Get the transform's matrix. */
        inline const Matrix& getMatrix() const { if (_matrixDirty) computeMatrix(); return *_matrix; }


        /** Get the inverse of the transform's matrix.
          * Automatically compute the inverse if it is not up to date. */
        inline const Matrix& getInverse() const { if (_inverseDirty) computeInverse(); return *_inverse; }


        /** Set the transform's matrix.*/
        inline void setMatrix(const Matrix& mat )
        {
            (*_matrix) = mat;

            _matrixDirty = false; // matrix is valid, so no need to compute
            _inverseDirty = true; // inverse is now invalid, so will need to recompute.
            
            dirtyBound();
        }

        /** preMult trasforms relative to the childrens coordinate system.*/
        inline void preMult( const Matrix& mat )
        {
            (*_matrix) =  mat * (*_matrix);
            
            _matrixDirty = false; // matrix is valid, so no need to compute
            _inverseDirty = true; // inverse is now invalid, so will need to recompute.
            
            dirtyBound();
        }

        /** postMult trasforms relative to the parents coordinate system.*/
        inline void postMult( const Matrix& mat )
        {
            (*_matrix) =  (*_matrix) * mat;

            _matrixDirty = false; // matrix is valid, so no need to compute
            _inverseDirty = true; // inverse is now invalid, so will need to recompute.

            dirtyBound();
        }
    
    protected :
    
        virtual ~Transform();
        
        /** Override's Group's computeBound. 
          * There is no need to override in subclasses from osg::Transform since this computeBound() uses 
          * the underlying matrix (calling computeMatrix if required.) */
        virtual const bool computeBound() const;
        
        /** If you subclass from osg::Transform you must override computeMatrix() to provide your own mechanism for
          * setting up the 4x4 matrix. An example of a subclass might a PositionAttitudeTransfrom which is its own
          * Vec3 and Quat to calculate the matrix.*/
        virtual void computeMatrix() const { _matrixDirty = false; }

        /** If you subclass from osg::Transform it is safe to rely on this default implementation which uses osg::Matrix::invert(getMatrix())
          * to compute the inverse.  However, you may wish to override this method too since there may well be a more optimal way to
          * compute the inverse rather than rely on the brute force method of osg::Matrix::invert(..).*/
        virtual void computeInverse() const { if (_inverseDirty) _inverse->invert(getMatrix()); _inverseDirty = false; }

        Type                    _type;
        
        mutable bool            _matrixDirty;
        mutable ref_ptr<Matrix> _matrix;

        mutable bool            _inverseDirty;
        mutable ref_ptr<Matrix> _inverse;
        
};

};

#endif
