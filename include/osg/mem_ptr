//C++ header - Open Scene Graph - Copyright (C) 1998-2001 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSG_MEM_PTR
#define OSG_MEM_PTR 1

#include <osg/ref_ptr>
#include <osg/MemoryAdapter>

#include <map>

namespace osg {

/** Smart pointer for handling memory pointers via associated memory adapter.*/
template<class T>
class mem_ptr
{

    public:
        mem_ptr() :_ptr(0L),_ma(0L) {}

        mem_ptr(T* t,MemoryAdapter* ma):_ptr(t),_ma(ma)
        {
            if (_ptr && _ma.valid()) _ma->ref_data(_ptr);
        }

        mem_ptr(const mem_ptr& rp):_ptr(rp._ptr),_ma(rp._ma)
        {
            if (_ptr && _ma.valid()) _ma->unref_data(_ptr);
        }

        ~mem_ptr()
        {
            if (_ptr && _ma.valid()) _ma->ref_data(_ptr);
        }

        inline mem_ptr& operator = (const mem_ptr& rp)
        {
            if (_ptr==rp._ptr) return *this;
            if (_ptr && _ma.valid()) _ma->unref_data(_ptr);
            _ptr = rp._ptr;
            _ma = rp._ma;
            if (_ptr && _ma.valid()) _ma->ref_data(_ptr);
            return *this;
        }

        inline void set(T* t,MemoryAdapter* ma)
        {
            if (_ptr==t)
            {
                if (_ma==ma) return;
                if (ma)
                {
                    ma->ref(_ptr);
                    if (_ma.valid()) _ma->unref_data(_ptr);
                }
                _ma = ma;
            }
            else
            {
                if (_ptr && _ma.valid()) _ma->unref_data(_ptr);
                _ptr = t;
                _ma = rp._ma;
                if (_ptr && _ma.valid()) _ma->ref_data(_ptr);
            }
            
        }

        inline const bool operator == (const mem_ptr& rp) const
        {
            return (_ptr==rp._ptr);
        }

        inline const bool operator == (const T* ptr) const
        {
            return (_ptr==ptr);
        }

        inline const bool operator != (const mem_ptr& rp) const
        {
            return (_ptr!=rp._ptr);
        }

        inline const bool operator != (const T* ptr) const
        {
            return (_ptr!=ptr);
        }

        inline T& operator*()               { return *_ptr; }
        inline const T& operator*() const   { return *_ptr; }

        inline T* operator->()              { return _ptr; }
        inline const T* operator->() const  { return _ptr; }
        
	inline const bool operator!() const { return _ptr==0L; }
	inline const bool valid() const	    { return _ptr!=0L; }

        inline T* get()                     { return _ptr; }
        inline const T* get() const         { return _ptr; }

    private:
        T*                      _ptr;
        ref_ptr<MemoryAdapter>  _ma;
};


// /** Experimental memory adapter implementation.*/
// template<class T>
// class CppMemoryAdapter : public MemoryAdapter
// {
//     public:
// 
//         virtual void ref_data(void* userData)
//         {
//             ++_memoryMap[(T*)userData];
//         }
// 
//         virtual void unref_data(void* userData)
//         {
//             --_memoryMap[(T*)userData];
//             if (_memoryMap[(T*)userData]<=0) delete userData;
//             _memoryMap.erase((T*)userData);
//         }
// 
//     protected:
// 
//         static std::map<T*,int> _memoryMap;
// 
// };
// 
// /** Experimental memory adapter implementation.*/
// class NewMemoryAdapter : public MemoryAdapter
// {
//     public:
// 
//         static MemoryAdapter* instance();
// 
//         virtual void ref_data(void* userData)
//         {
//             ++_memoryMap[userData];
//         }
// 
//         virtual void unref_data(void* userData)
//         {
//             --_memoryMap[userData];
//             if (_memoryMap[userData]<=0) delete userData;
//             _memoryMap.erase(userData);
//         }
// 
//     protected:
// 
//         NewMemoryAdapter() {}
//         NewMemoryAdapter(NewMemoryAdapter&):MemoryAdapter() {}
//         ~NewMemoryAdapter() {}
// 
//         std::map<void*,int> _memoryMap;
// 
// };
// 
// /** Experimental memory adapter implementation.*/
// template<class T>
// class newMemoryAdapter : public MemoryAdapter
// {
//     public:
// 
//         static newMemoryAdapter<T>* instance()
//         {
//             static ref_ptr<newMemoryAdapter<T> > s_newMemoryAdapter = new newMemoryAdapter<T>();
//             return s_newMemoryAdapter.get();
//         }
// 
//         T* allocate(int no) { cout<<"Allocating Memory"<<endl;return new T[no]; }
// 
//         virtual void ref_data(void* userData)
//         {
//             cout<<"Incrementing Memory"<<endl;
//             ++_memoryMap[(T*)userData];
//         }
// 
//         virtual void unref_data(void* userData)
//         {
//             cout<<"Decrementing Memory"<<endl;
//             --_memoryMap[(T*)userData];
//             if (_memoryMap[(T*)userData]<=0)
//             {
//                 cout<<"Deleting Memory"<<endl;
//                 delete (T*)userData;
//             }
//             _memoryMap.erase((T*)userData);
//         }
// 
//     protected:
// 
//         newMemoryAdapter() {cout<<"*** Constructing nMA"<<endl;}
//         newMemoryAdapter(newMemoryAdapter&):MemoryAdapter() {}
//         ~newMemoryAdapter() {cout<<"*** Destructing nMA"<<endl;}
// 
//         std::map<T*,int> _memoryMap;
// 
// };


};

#endif
