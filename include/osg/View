/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_VIEW
#define OSG_VIEW 1

#include <osg/Camera>

#include <OpenThreads/Mutex>

namespace osg {

/** View - maintains a master camera view and a list of slave cameras that are relative to this master camera.
  * Note, if no slave cameras are attached to the view then the master camera does both the control and implementation of the rendering of the scene,
  * but if slave cameras are present then the master controls the view onto the scene, while the slaves implement the rendering of the scene.
*/
class OSG_EXPORT View : public virtual osg::Referenced
{
    public :


        View();

        /** Set the master camera of the view. */        
        void setCamera(osg::Camera* camera) { _camera = camera; }

        /** Get the master camera of the view. */        
        osg::Camera* getCamera() { return _camera.get(); }

        /** Get the const master camera of the view. */        
        const osg::Camera* getCamera() const { return _camera.get(); }

        /** Slave allows one to up a camera that follows the master with a local offset to the project and view matrices.*/
        struct Slave
        {
            Slave() {}
            Slave(osg::Camera* camera, const osg::Matrixd& projectionOffset, const osg::Matrixd& viewOffset):
                _camera(camera), _projectionOffset(projectionOffset), _viewOffset(viewOffset) {}
        
            Slave(const Slave& rhs) :
                _camera(rhs._camera), _projectionOffset(rhs._projectionOffset), _viewOffset(rhs._viewOffset) {}

            Slave& operator = (const Slave& rhs)
            {
                _camera = rhs._camera;
                _projectionOffset = rhs._projectionOffset;
                _viewOffset = rhs._viewOffset;
                return *this;
            }

            osg::ref_ptr<osg::Camera>   _camera;
            osg::Matrixd                    _projectionOffset;
            osg::Matrixd                    _viewOffset;
        };

        bool addSlave(osg::Camera* camera) { return addSlave(camera, osg::Matrix::identity(), osg::Matrix::identity()); }

        bool addSlave(osg::Camera* camera, const osg::Matrix& projectionOffset, const osg::Matrix& viewOffse);

        bool removeSlave(unsigned int pos);
        
        unsigned int getNumSlaves() const { return _slaves.size(); }

        Slave& getSlave(unsigned int pos) { return _slaves[pos]; }
        const Slave& getSlave(unsigned int pos) const { return _slaves[pos]; }

    protected :
    
        virtual ~View();

        void updateSlaves();
        
        osg::ref_ptr<osg::Camera>   _camera;
        
        typedef std::vector<Slave> Slaves;
        Slaves _slaves;
};

}

#endif
