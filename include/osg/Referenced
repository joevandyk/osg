/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2003 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_REFERENCED
#define OSG_REFERENCED 1

// When building OSG with Java need to derive from Noodle::CBridgable class,
// therefore so OSG_JAVA_BUILD must be defined. Also the thread-safe ref/unref test
// as built in for the NoodleCore wrapping. NoodleCore has a Garbage collector mechanism 
// which is very similar to osg::DeletionManager. So these aspects of osg::Referenced
// have been removed
//#define OSG_JAVA_BUILD

#include <osg/Export>
#ifdef OSG_JAVA_BUILD
#include <NoodleCore/Bridgable.h>
#else
#include <OpenThreads/Mutex>
#endif

namespace osg {

#ifndef OSG_JAVA_BUILD
// forward declar, declared after Referenced below.
class DeleteHandler;

/** Base class from providing referencing counted objects.*/
class SG_EXPORT Referenced
{

    public:


        Referenced() 
        {
           
           _refCount=0;
        }
        Referenced(const Referenced&) {
            _refCount=0;
        }

        inline Referenced& operator = (const Referenced&) { return *this; }



        /** increment the reference count by one, indicating that 
            this object has another pointer which is referencing it.*/
        void ref() const;
        
        /** decrement the reference count by one, indicating that 
            a pointer to this object is referencing it.  If the
            reference count goes to zero, it is assumed that this object
            is no longer referenced and is automatically deleted.*/
        void unref() const;
        
        /** decrement the reference count by one, indicating that 
            a pointer to this object is referencing it.  However, do
            not delete it, even if ref count goes to 0.  Warning, unref_nodelete() 
            should only be called if the user knows exactly who will
            be resonsible for, one should prefer unref() over unref_nodelete() 
            as the later can lead to memory leaks.*/
        void unref_nodelete() const;
        
        /** return the number pointers currently referencing this object. */
        inline int referenceCount() const { return _refCount; }


    public:

        /** Set whether reference counting should be use a mutex to create thread reference counting.*/
        static void setThreadSafeReferenceCounting(bool enableThreadSafeReferenceCounting);
        
        /** Get whether reference counting is active.*/
        static bool getThreadSafeReferenceCounting();

        friend class DeleteHandler;

        /** Set a DeleteHandler to which deletion of all referenced counted objects
          * will be delegated to.*/
        static void setDeleteHandler(DeleteHandler* handler);

        /** Get a DeleteHandler.*/
        static DeleteHandler* getDeleteHandler();

       
    protected:
        virtual ~Referenced();
        
        mutable OpenThreads::Mutex  _refMutex;

        mutable int                 _refCount;
        
};


/** Class for override the default delete behavior so that users can implment their own object
  * deletion schemes.  This might be done to help implement protection of multiple threads from deleting
  * objects unintentionally.
  * Note, the DeleteHandler cannot itself be reference counted, otherwise it
  * would be responsible for deleting itself!
  * An static auto_ptr<> is used internally in Referenced.cpp to manage the 
  * DeleteHandler's memory.*/
class DeleteHandler
{
    public:

        virtual ~DeleteHandler() {}

        /** flush any cache of objects that need to be deleted by doing an actual delete.*/
        virtual void flush() {}
        
        inline void doDelete(const Referenced* object) { delete object; }
         
        /** Request the deletion of an object. 
          * Depending on users implementation of DeleteHandler, the delete of the object may occur 
          * straight away or be delayed until doDelete is called.
          * The default implementation does a delete straight away.*/
        virtual void requestDelete(const Referenced* object) { doDelete(object); }
};
#else 
/** Java wrappers use the CBridgable base-class for referencing
  * and garbage collection.
  */
class SG_EXPORT Referenced : public Noodle::CBridgable 
{
	public:
		/** Method not used in NoodleCore referencing 
		  */
		inline void unref_nodelete() const { --_refCount; }
		inline int referenceCount() const { return _refCount; }
	protected:
		virtual ~Referenced() {}
};
#endif //OSG_JAVA_BUILD

}

#endif
