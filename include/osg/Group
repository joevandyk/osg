#ifndef OSG_GROUP
#define OSG_GROUP 1

#include <osg/Node>
#include <osg/NodeVisitor>

#include <vector>

namespace osg {

/** General group node which maintains a list of children.
    Children are reference counted to allow children to be shared
    with memory management handled automatically via osg::Referenced.
*/
class SG_EXPORT Group : public Node
{
    public :

        typedef std::vector<ref_ptr<Node> > ChildList;

        Group();

        virtual Object* clone() const { return new Group(); }
        virtual bool isSameKindAs(Object* obj) { return dynamic_cast<Group*>(obj)!=NULL; }
        virtual const char* className() const { return "Group"; }
        virtual void accept(NodeVisitor& nv) { nv.apply(*this); }
        
        virtual void traverse(NodeVisitor& nv);

        /** Add Node to Group.
         *  If node is not NULL and is not contained in Group then increment its  
         *  reference count, add it to the child list and dirty the bounding 
         *  sphere to force it to recompute on next getBound() and return true for success.
         *  Otherwise return false.
         */
        virtual bool addChild( Node *child );

        /** Remove Node from Group.
         *  If Node is contained in Group then remove it from the child
         *  list, decrement its reference count, and dirty the 
         *  bounding sphere to force it to recompute on next getBound() and
         *  return true for success.  If Node is not found then return false
         *  and do not change the reference count of the Node.
         */
        virtual bool removeChild( Node *child );

        /** Replace specified Node with another Node.
         *  Decrement the reference count origNode and increments the
         *  reference count of newNode, and dirty the bounding sphere
         *  to force it to recompute on next getBound() and returns true.
         *  If origNode is not found then return false and do not 
         *  add newNode.  If newNode is NULL then return false and do
         *  not remove origNode.
         */
        virtual bool replaceChild( Node *origChild, Node* newChild );

        /** return the number of chilren nodes.*/
        int  getNumChildren( void )       { return _children.size(); }

        /** return child node at position i.*/
        Node *getChild( int i )     { return _children[i].get(); }

        /** return true is node is contained within Group.*/
        bool containsNode( Node* node )
        {
            
            for (ChildList::iterator itr=_children.begin();
                 itr!=_children.end();
                 ++itr)
            {
                if (itr->get()==node) return true;
            }
            return false;
        }

        /** return the iterator postion for specified Node.
         *  return _chilren.end() if node is not contained in Group.
         */
        ChildList::iterator findNode( Node* node )
        {
            
            for (ChildList::iterator itr=_children.begin();
                 itr!=_children.end();
                 ++itr)
            {
                if (itr->get()==node) return itr;
            }
            return _children.end();
        }

    protected:

        virtual ~Group();

        virtual bool readLocalData(Input& fr);
        virtual bool writeLocalData(Output& fw);

        ChildList _children;

        bool computeBound( void );

};

};

#endif
