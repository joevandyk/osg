//C++ header - Open Scene Graph - Copyright (C) 1998-2001 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSG_MATRIX
#define OSG_MATRIX 1

#include <osg/Object>
#include <osg/Vec3>
#include <osg/Vec4>

#ifdef OSG_USE_IO_DOT_H
#include <iostream.h>
#else
#include <iostream>
using namespace std;
#endif

// temporary #define to keep backwards compatibility.
//#define USE_DEPRECATED_MATRIX_METHODS

namespace osg {

class Quat;

class SG_EXPORT Matrix : public Object
{

    private:
        float _mat[4][4];
        bool fully_realized;

    public:

        META_Object(Matrix);

        Matrix();
        Matrix( const Matrix& other );
        explicit Matrix( float const * const def );
        Matrix( float a00, float a01, float a02, float a03,
            float a10, float a11, float a12, float a13,
            float a20, float a21, float a22, float a23,
            float a30, float a31, float a32, float a33);

        virtual ~Matrix() {}

        Matrix& operator = (const Matrix& );

        int compare(const Matrix& m) const { ensureRealized();  m.ensureRealized(); return memcmp(_mat,m._mat,sizeof(_mat)); }

        bool operator < (const Matrix& m) const { return compare(m)<0; }
        bool operator == (const Matrix& m) const { return compare(m)==0; }
        bool operator != (const Matrix& m) const { return compare(m)!=0; }

        inline float& operator()(int row, int col) { ensureRealized(); return _mat[row][col]; }
        inline float operator()(int row, int col) const { ensureRealized(); return _mat[row][col]; }

        void set( float const * const );
        void set( float a00, float a01, float a02, float a03,
                  float a10, float a11, float a12, float a13,
                  float a20, float a21, float a22, float a23,
                  float a30, float a31, float a32, float a33);
                  
        float * ptr() { ensureRealized(); return (float *)_mat; }
        const float * ptr() const { ensureRealized(); return (const float *)_mat; }

        inline void ensureRealized() const { if (!fully_realized) const_cast<Matrix*>(this)->makeIdent();}

        void makeIdent();
        void makeScale( const Vec3& );
        void makeScale( float, float, float );
        
        void makeTrans( const Vec3& );
        void makeTrans( float, float, float );
        //TODO: original preTrans was optimized (M=Tr*M)
        // but also has the assumption that M (this) is an affine transformation Matrix
        // can I still do something to optimize the same case now?

        void makeRot( const Vec3& from, const Vec3& to );
        void makeRot( float angle, const Vec3& axis );
        void makeRot( float angle, float x, float y, float z );
        void makeRot( const Quat& );
        void makeRot( float, float, float ); //Euler angles

        bool invert( const Matrix& );
        bool invertAffine( const Matrix& );

        //basic utility functions to create new matrices or vectors
	inline static Matrix identity( void );
        inline static Matrix scale( const Vec3& );
        inline static Matrix scale( float, float, float );
        inline static Matrix trans( const Vec3& );
        inline static Matrix trans( float, float, float );
        inline static Matrix rotate( const Vec3&, const Vec3& );
        inline static Matrix rotate( float, float, float, float );
        inline static Matrix rotate( float angle, const Vec3& axis);
        inline static Matrix rotate( const Quat& );

        inline Vec3 preMult( const Vec3& v ) const;
        inline Vec3 postMult( const Vec3& v ) const;
        inline Vec3 operator* ( const Vec3& v ) const;
        inline Vec4 preMult( const Vec4& v ) const;
        inline Vec4 postMult( const Vec4& v ) const;
        inline Vec4 operator* ( const Vec4& v ) const;

        void setTrans( float tx, float ty, float tz );
	void setTrans( const Vec3& v );
        Vec3 getTrans() const { ensureRealized(); return Vec3(_mat[3][0],_mat[3][1],_mat[3][2]); } 

#ifdef USE_DEPRECATED_MATRIX_METHODS

        void copy( const Matrix& );
        void preScale( float sx, float sy, float sz, const Matrix& m );
        void postScale( const Matrix& m, float sx, float sy, float sz );
        void preScale( float sx, float sy, float sz );
        void postScale( float sx, float sy, float sz );

        void preTrans( float tx, float ty, float tz, const Matrix& m );
        void postTrans( const Matrix& m, float tx, float ty, float tz );
        void preTrans( float tx, float ty, float tz);
        void postTrans( float tx, float ty, float tz );

        void preRot( float deg, float x, float y, float z, const Matrix& m  );
        void postRot( const Matrix& m, float deg, float x, float y, float z );
        void preRot( float deg, float x, float y, float z );
        void postRot( float deg, float x, float y, float z );
        
#endif

    	/** apply apply an 3x3 transform of v*M[0..2,0..2]  */
    	inline static Vec3 transform3x3(const Vec3& v,const Matrix& m);
    	/** apply apply an 3x3 transform of M[0..2,0..2]*v  */
    	inline static Vec3 transform3x3(const Matrix& m,const Vec3& v);
        
//end of Deprecated methods 


        // basic Matrix multiplication, our workhorse methods.
        void mult( const Matrix&, const Matrix& );
        void preMult( const Matrix& );
        void postMult( const Matrix& );

        // Helper class to optimize product expressions somewhat
        class MatrixProduct {
        public:
            const Matrix& A;
            const Matrix& B;

            MatrixProduct( const Matrix& lhs, const Matrix& rhs ) : A(lhs), B(rhs) {}
        };

        inline MatrixProduct operator * ( const Matrix& other ) const    
            {    return MatrixProduct(*this, other); }

        inline void operator *= ( const Matrix& other ) 
            {    if( this == &other ) {
                    Matrix temp(other);
                    postMult( temp );
                }
                else postMult( other ); 
            }
        inline void operator = ( const MatrixProduct& p ) 
            {
                if( this == &(p.A)) postMult(p.B);
                else if( this == &(p.B)) preMult(p.A);
                else mult( p.A, p.B );
            }

        Matrix( const MatrixProduct& p ) //allows implicit evaluation of the product
            {    mult( p.A, p.B ); }


        Matrix operator *( const Matrix &m ) 
	{
	    osg::Matrix r;
            r.mult(*this,m);
	    return  r;
	}

	float * operator [] ( int i ) { return &_mat[i][0]; }
};

//static utility methods
inline Matrix Matrix::identity(void)
{
    Matrix m;
    m.makeIdent();
    return m;
}

inline Matrix Matrix::scale(float sx, float sy, float sz)
{
    Matrix m;
    m.makeScale(sx,sy,sz);
    return m;
}

inline Matrix Matrix::scale(const Vec3& v )
{
    return scale(v.x(), v.y(), v.z() );
}

inline Matrix Matrix::trans(float tx, float ty, float tz)
{
    Matrix m;
    m.makeTrans(tx,ty,tz);
    return m;
}

inline Matrix Matrix::trans(const Vec3& v )
{
    return trans(v.x(), v.y(), v.z() );
}

inline Matrix Matrix::rotate( const Quat& q )
{
    Matrix m;
    m.makeRot( q );
    return m;
}
inline Matrix Matrix::rotate(float angle, float x, float y, float z )
{
    Matrix m;
    m.makeRot(angle,x,y,z);
    return m;
}
inline Matrix Matrix::rotate(float angle, const Vec3& axis )
{
    Matrix m;
    m.makeRot(angle,axis);
    return m;
}
inline Matrix Matrix::rotate(const Vec3& from, const Vec3& to )
{
    Matrix m;
    m.makeRot(from,to);
    return m;
}

inline Vec3 Matrix::postMult( const Vec3& v ) const
{
    float d = 1.0f/(_mat[3][0]*v.x()+_mat[3][1]*v.y()+_mat[3][2]*v.z()+_mat[3][3]) ;
    return Vec3( (_mat[0][0]*v.x() + _mat[0][1]*v.y() + _mat[0][2]*v.z() + _mat[0][3])*d,
        (_mat[1][0]*v.x() + _mat[1][1]*v.y() + _mat[1][2]*v.z() + _mat[1][3])*d,
        (_mat[2][0]*v.x() + _mat[2][1]*v.y() + _mat[2][2]*v.z() + _mat[2][3])*d) ;
}

inline Vec3 Matrix::preMult( const Vec3& v ) const
{
    float d = 1.0f/(_mat[0][3]*v.x()+_mat[1][3]*v.y()+_mat[2][3]*v.z()+_mat[3][3]) ;
    return Vec3( (_mat[0][0]*v.x() + _mat[1][0]*v.y() + _mat[2][0]*v.z() + _mat[3][0])*d,
        (_mat[0][1]*v.x() + _mat[1][1]*v.y() + _mat[2][1]*v.z() + _mat[3][1])*d,
        (_mat[0][2]*v.x() + _mat[1][2]*v.y() + _mat[2][2]*v.z() + _mat[3][2])*d);
}

inline Vec4 Matrix::postMult( const Vec4& v ) const
{
    return Vec4( (_mat[0][0]*v.x() + _mat[0][1]*v.y() + _mat[0][2]*v.z() + _mat[0][3]*v.w()),
        (_mat[1][0]*v.x() + _mat[1][1]*v.y() + _mat[1][2]*v.z() + _mat[1][3]*v.w()),
        (_mat[2][0]*v.x() + _mat[2][1]*v.y() + _mat[2][2]*v.z() + _mat[2][3]*v.w()),
        (_mat[3][0]*v.x() + _mat[3][1]*v.y() + _mat[3][2]*v.z() + _mat[3][3]*v.w())) ;
}

inline Vec4 Matrix::preMult( const Vec4& v ) const
{
    return Vec4( (_mat[0][0]*v.x() + _mat[1][0]*v.y() + _mat[2][0]*v.z() + _mat[3][0]*v.w()),
        (_mat[0][1]*v.x() + _mat[1][1]*v.y() + _mat[2][1]*v.z() + _mat[3][1]*v.w()),
        (_mat[0][2]*v.x() + _mat[1][2]*v.y() + _mat[2][2]*v.z() + _mat[3][2]*v.w()),
        (_mat[0][3]*v.x() + _mat[1][3]*v.y() + _mat[2][3]*v.z() + _mat[3][3]*v.w()));
}
inline Vec3 Matrix::transform3x3(const Vec3& v,const Matrix& m)
{
    return Vec3( (m._mat[0][0]*v.x() + m._mat[1][0]*v.y() + m._mat[2][0]*v.z()),
                 (m._mat[0][1]*v.x() + m._mat[1][1]*v.y() + m._mat[2][1]*v.z()),
                 (m._mat[0][2]*v.x() + m._mat[1][2]*v.y() + m._mat[2][2]*v.z()));
}

inline Vec3 Matrix::transform3x3(const Matrix& m,const Vec3& v)
{
    return Vec3( (m._mat[0][0]*v.x() + m._mat[0][1]*v.y() + m._mat[0][2]*v.z()),
                 (m._mat[1][0]*v.x() + m._mat[1][1]*v.y() + m._mat[1][2]*v.z()),
                 (m._mat[2][0]*v.x() + m._mat[2][1]*v.y() + m._mat[2][2]*v.z()) ) ;
}


inline Vec3 operator* (const Vec3& v, const Matrix& m )
{
	return m.preMult(v);
}
inline Vec4 operator* (const Vec4& v, const Matrix& m )
{
	return m.preMult(v);
}

inline Vec3 Matrix::operator* (const Vec3& v) const
{
	return postMult(v);
}
inline Vec4 Matrix::operator* (const Vec4& v) const
{
	return postMult(v);
}

inline ostream& operator<< (ostream& os, const Matrix& m )
{
    os << "{"<<endl;
    for(int row=0; row<4; ++row) {
        os << "\t";
        for(int col=0; col<4; ++col)
            os << m(row,col) << " ";
        os << endl;
    }
    os << "}" << endl;
    return os;
}


}; //namespace osg


#endif
