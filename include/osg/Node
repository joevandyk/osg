#ifndef OSG_NODE
#define OSG_NODE 1

#include <osg/Types>
#include <osg/Object>
#include <osg/BoundingSphere>

#include <string>
#include <vector>

namespace osg {

class NodeVisitor;
class Group;

/** Class for adapting the memory management of external data.
 *  Typically used to specify the memory management of user data
 *  which can be attached to osg::Node.
 */
class SG_EXPORT MemoryAdapter : public Referenced
{
    public:
        MemoryAdapter() {}
        
        /** Increment the reference count of the userData.*/ 
        virtual void incrementReference(void* /*userData*/) = 0;

        /** Decrement the reference count of the userData.
            Is usually implemented such that if reference count 
            is decremented to zero the userData should be
            deleted.  However, this is entirely up to the
            discression of the user who is extending this base class.*/ 
        virtual void decrementReference(void* /*userData*/) = 0;
   
        /** not current used, but will be used in future.*/ 
        virtual void* clone(void* /*userData*/) { return 0L; }
        
        /** not current used, but will be used in future.*/ 
        virtual bool write(Output& /*fw*/,void* /*userData*/) { return false; }

        /** not current used, but will be used in future.*/ 
        virtual bool read(Input& /*fr*/,void* /*userData*/) { return false; }

    protected:
    
        virtual ~MemoryAdapter() {}
};

/** Base class for all internal nodes in the scene graph.
    Provides interface for most common node operations (Composite Pattern).
*/
class SG_EXPORT Node : public Object
{
    public:

        /** Construct a node.
            Initialize the parent list to empty, node name to "" and 
            bounding sphere dirty flag to true.*/
        Node();

        /** return a shallow copy of a node, with Object* return type.*/
        virtual Object* clone() const { return new Node(); }
        /** return a shallow copy of a node, with Node* return type.*/
        Node* cloneNode() const { return (Node*)clone(); }

        /** return true if this and obj are of the same kind of object.*/
        virtual bool isSameKindAs(Object* obj) { return dynamic_cast<Node*>(obj)!=NULL; }

        /** return the name of the node's class type.*/
        virtual const char* className() const { return "Node"; }

        /** Visitor Pattern : calls the apply method of a NodeVisitor with this node's type.*/
        virtual void accept(NodeVisitor& nv);
        /** Traverse upwards : calls parents' accept method with NodeVisitor.*/
        virtual void ascend(NodeVisitor& nv);
        /** Traverse downwards : calls children's accept method with NodeVisitor.*/
        virtual void traverse(NodeVisitor& /*nv*/) {}


        /** Set the name of node using C++ style string.*/
        void setName( const std::string& name ) { _name = name; }
        /** Set the name of node using a C style string.*/
        void setName( const char* name ) { _name = name; }
        /** Get the name of node.*/
        const std::string& getName( void ) { return _name; }
        

        /** A vector of osg::Group pointers which is used to store the parent(s) of node.*/
        typedef std::vector<Group*> ParentList;

        /** Get the parent list of node. */
        const ParentList& getParents() const { return _parents; }
        /**
         * Get a single parent of node.
         * @param i index of the parent to get.
         * @return the parent i.
         */
        Group* getParent(int i) const  { return _parents[i]; }
        /**
         * Get the number of parents of node.
         * @return the number of parents of this node.
         */
        int getNumParents() const { return _parents.size(); }


        /**
         * Set user data. See MemoryAdapter documention for details
         * of how to specify memory managament of _userData.
         */
        void setUserData(void* data,MemoryAdapter* ma=0L)
        {
            if (_userData && _memoryAdapter.valid()) _memoryAdapter->decrementReference(_userData);
            _userData = data;
            _memoryAdapter = ma;
            if (_userData && _memoryAdapter.valid()) _memoryAdapter->incrementReference(_userData);
        }
        /** Get user data.*/
        void* getUserData() const { return _userData; }
        
        /** Get the memory adapter associated with _userData.*/
        MemoryAdapter* getMemoryAdapter() const { return _memoryAdapter.get(); }
        

        typedef unsigned int NodeMask;
        /** Set the node mask. Note, node mask is will be replaced by TraversalMask.*/
        void setNodeMask(NodeMask nm) { _nodeMask = nm; }
        /** Get the node Mask. Note, node mask is will be replaced by TraversalMask.*/
        NodeMask getNodeMask()        { return _nodeMask; }



        /** A vector of std::string's which are used to describe the object.*/
        typedef std::vector<std::string> DescriptionList;

        /** Get the description list of the const node.*/        
        const DescriptionList& getDescriptions() const { return _descriptions; }
        /** Get the description list of the const node.*/        
        DescriptionList& getDescriptions() { return _descriptions; }
        /** Get a single const description of the const node.*/
        const std::string& getDescription(int i) const { return _descriptions[i]; }
        /** Get a single description of the node.*/
        std::string& getDescription(int i) { return _descriptions[i]; }
        /** Get the number of descriptions of the node.*/
        int getNumDescriptions() const { return _descriptions.size(); }
        /** Add a description string to the node.*/
        void addDescription(const std::string& desc) { _descriptions.push_back(desc); }

        /** get the bounding sphere of node.
           Using lazy evaluation computes the bounding sphere if it is 'dirty'.*/
        const BoundingSphere& getBound();

        /** Mark this node's bounding sphere dirty.
            Forcing it to be computed on the next call to getBound().*/
        void dirtyBound();


    protected:

        /** Node destructor. Note, is protected so that Nodes cannot
            be deleted other than by being dereferenced and the reference
            count being zero (see osg::Referenced), preventing the deletion
            of nodes which are still in use. This also means that
            Node's cannot be created on stack i.e Node node will not compile,
            forcing all nodes to be created on the heap i.e Node* node
            = new Node().*/
        virtual ~Node();

        /**
         * Template Method Pattern : read local data from .osg file.
         * Note should be implemented in derived classes, which
         * call their parent class's readLocalData.
         * @return true if the input iterator has been advanced, otherwise false.
         */
        virtual bool readLocalData(Input& fr);

        /**
         * Template Method Pattern : read local data from .osg file.
         * Note should be implemented in derivied classes, which
         * call their parent class's writeLocalData.
         * @return true if data has been written out, otherwise false.
         */
        virtual bool writeLocalData(Output& fw);

        /** Compute the bounding sphere around Node's geometry or children.
            This method is automatically called by getBound() when the bounding
            sphere has been marked dirty via dirtyBound().*/
        virtual bool computeBound( void ) ;

        BoundingSphere _bsphere;
        bool _bsphere_computed;

        std::string _name;

        ParentList _parents;
        friend Group;

        void*                   _userData;
        ref_ptr<MemoryAdapter>  _memoryAdapter;

        NodeMask _nodeMask;
        
        DescriptionList _descriptions;

};

/** A vector of Nodes pointers which is used to describe the path from a root node to a descendant.*/
typedef std::vector<Node*> NodePath;

};

#endif
