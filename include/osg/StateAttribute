#ifndef OSG_STATEATTRIBUTE
#define OSG_STATEATTRIBUTE 1

#include <osg/Object>
#include <osg/GL>

#include <typeinfo>

namespace osg {

// forward declare State & StateSet
class State;
class StateSet;

/** META_StateAttribute macro define the standard clone, isSameKindAs,
  * className and getType methods.
  * Use when subclassing from Object to make it more convinient to define 
  * the standard pure virtual methods which are required for all Object 
  * subclasses.*/
#define META_StateAttribute(name,type) \
        virtual Object* clone() const { return new name (); } \
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const name *>(obj)!=NULL; } \
        virtual const char* className() const { return #name; } \
        virtual const Type getType() const { return type; }

/** COMPARE_StateAttribute_Types macro is a helper for implementing the StatateAtribute::compare(..) method.*/
#define COMPARE_StateAttribute_Types(TYPE,rhs_attribute) \
            if (this==&rhs_attribute) return 0;\
            const std::type_info* type_lhs = &typeid(*this);\
            const std::type_info* type_rhs = &typeid(rhs_attribute);\
            if (type_lhs->before(*type_rhs)) return -1;\
            if (*type_lhs != *type_rhs) return 1;\
            const TYPE& rhs = static_cast<const TYPE&>(rhs_attribute);


/** COMPARE_StateAttribute_Parameter macro is a helper for implementing the StatateAtribute::compare(..) method.
  * Macro assumes that variable rhs has been corrected defined by code preceesing
  * macro.*/
#define COMPARE_StateAttribute_Parameter(parameter) \
        if (parameter<rhs.parameter) return -1; \
        if (rhs.parameter<parameter) return 1;

/** Base class for state attribues.
*/     
class SG_EXPORT StateAttribute : public Object
{
    public :
    
        /** GLMode is the value used in glEnable/glDisable(mode) */
        typedef GLenum          GLMode;
        /** GLModeValue is used to specified whether an mode is enabled (ON) or disabled (OFF).
          * GLMoveValue is also used to speficy the override behavior of modes from parent to children. 
          * See enum Value description for more details.*/
        typedef unsigned int    GLModeValue;
        /** Override is used to specified the override behavior of StateAttributes
          * from from parent to children. 
          * See enum Value description for more details.*/
        typedef unsigned int	OverrideValue;

        /** list values which can be used in to set either GLModeValues
          * or OverrideValues. When using in conjection with GLModeValues
          * all Values have meaning.  When using in conjection with 
          * StateAttribute OverrideValue only OFF,OVERRIDE and INHERIT
          * are meaningful. However, they are useful when using GLModeValue 
          * and OverrideValue in conjunction with each other as when using
          * StateSet::setAttributeAndModes(..).*/
        enum Values
        {
            /** means that associated GLMode and Override is disabled.*/
            OFF          = 0x0,
            /** means that associated GLMode is enabled and Override is disabled.*/
            ON           = 0x1,
            /** Overriding of GLMode's or StateAttributes is enabled.*/
            OVERRIDE     = 0x2,
            /** means that associated GLMode is disabled and Override is enabled.*/
            OVERRIDE_OFF = 0x2,
            /** means that associated GLMode and Override is enabled.*/
            OVERRIDE_ON  = 0x3,
            /** means that GLMode or StateAttribute should in inherited from above.*/
            INHERIT      = 0x4
        };

        /** Type identifier to differentiate between different state types. */
        typedef unsigned int Type;

        /** Values of StateAttribute::Type used to aid identification
          * of diffenent StateAttribute subclasses. Each subclass defines
          * it own value in the virtual Type getType() method.  When 
          * extending the osg's StateAttribute's simply define your
          * own Type value which is unique, using the StateAttribute::Type
          * enum as a guide of what values to use.  If your new subclass
          * needs to override a standard StateAttriubte then simple use 
          * that types value. */
        enum Types
        {
            ALPHAFUNC       =1,
            ANTIALIAS       =2,
            COLORTABLE      =3,
            CULLFACE        =4,
            FOG             =5,
            FRONTFACE       =6,
            LIGHT           =7,
            LIGHT_0         =LIGHT+0,
            LIGHT_1         =LIGHT+1,
            LIGHT_2         =LIGHT+2,
            LIGHT_3         =LIGHT+3,
            LIGHT_4         =LIGHT+4,
            LIGHT_5         =LIGHT+5,
            LIGHT_6         =LIGHT+6,
            LIGHT_7         =LIGHT+7,
            MATERIAL        =15,
            POINT           =16,
            POLYGONMODE     =17,
            POLYGONOFFSET   =18,
            TEXENV          =19,
            TEXGEN          =20,
            TEXMAT          =21,
            TEXTURE         =22,
            TEXTURE_0       =TEXTURE+0,
            TEXTURE_1       =TEXTURE+1,
            TEXTURE_2       =TEXTURE+2,
            TEXTURE_3       =TEXTURE+3,
            TRANSPARENCY    =26,
            STENCIL         =27,
            COLORMASK       =28,
            CLIPPLANE       =29,
            CLIPPLANE_0     =CLIPPLANE+0,
            CLIPPLANE_1     =CLIPPLANE+1,
            CLIPPLANE_2     =CLIPPLANE+2,
            CLIPPLANE_3     =CLIPPLANE+3,
            CLIPPLANE_4     =CLIPPLANE+4,
            CLIPPLANE_5     =CLIPPLANE+5,
            DEPTH           =35,
            VIEWPORT        =36
        };

        StateAttribute() {}

        /** return a shallow copy of a node, with Object* return type.*/
        virtual Object* clone() const = 0;

        /** return true if this and obj are of the same kind of object.*/
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const StateAttribute*>(obj)!=NULL; }

        /** return the name of the attribute's class type.*/
        virtual const char* className() const { return "StateAttribute"; }
        
        /** return the Type idenitifer of the attribute's class type.*/
        virtual const Type getType() const = 0;

        /** return -1 if *this < *rhs, 0 if *this==*rhs, 1 if *this>*rhs.*/
        virtual int compare(const StateAttribute& sa) const = 0;
        
        bool operator <  (const StateAttribute& rhs) const { return compare(rhs)<0; }
        bool operator == (const StateAttribute& rhs) const { return compare(rhs)==0; }
        bool operator != (const StateAttribute& rhs) const { return compare(rhs)!=0; }

        
        virtual void setStateSetModes(StateSet&,const GLModeValue) const 
        {
            // default to no GLMode's assocated with use of the StateAttribute.
        }
    
        /** apply the OpenGL state attributes. 
          * The global state for the current OpenGL context is passed
          * in to allow the StateAttribute to obtain details on the
          * the current context and state.
          */
        virtual void apply(State&) const = 0 ;
        
        /** default to nothing to compile - all state is applied immediately. */
        virtual void compile(State&) const {};

    protected:
    
        virtual ~StateAttribute() {}

};

};

#endif
