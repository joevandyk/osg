/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2003 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_SHAPEDRAWABLE
#define OSG_SHAPEDRAWABLE 1

#include <osg/Drawable>
#include <osg/Vec2>
#include <osg/Vec3>
#include <osg/Vec4>
#include <osg/Array>
#include <osg/PrimitiveSet>

namespace osg {

class TessellationHints : public Object
{
    public:

	TessellationHints():
	    _TessellationMode(USE_SHAPE_DEFAULTS),
	    _targetNumFaces(100),
	    _createFrontFace(true),
	    _createBackFace(false),
	    _createNormals(true),
	    _createTextureCoords(false),
	    _createTop(true),
	    _createBody(true),
	    _createBottom(true) {}
	    

	TessellationHints(const TessellationHints& tess, const CopyOp& copyop=CopyOp::SHALLOW_COPY): 
    	    Object(tess,copyop),
	    _TessellationMode(tess._TessellationMode),
	    _targetNumFaces(tess._targetNumFaces),
	    _createFrontFace(tess._createFrontFace),
	    _createBackFace(tess._createBackFace),
	    _createNormals(tess._createNormals),
	    _createTextureCoords(tess._createTextureCoords),
	    _createTop(tess._createTop),
	    _createBody(tess._createBody),
	    _createBottom(tess._createBottom) {}

	META_Object(osg,TessellationHints)
	
	
	enum TessellationMode
	{
	    USE_SHAPE_DEFAULTS,
    	    USE_TARGET_NUM_FACES
	};

    	inline void setTessellationMode(TessellationMode mode) { _TessellationMode=mode; }
    	inline TessellationMode getTessellationMode() const { return _TessellationMode; }

	inline void setTargetNumFaces(unsigned int target) { _targetNumFaces=target; }
	inline unsigned int getTargetNumFaces() const { return _targetNumFaces; }

    	inline void setCreateFrontFace(bool on) { _createFrontFace=on; }
    	inline bool getCreateFrontFace() const { return _createFrontFace; }

    	inline void setCreateBackFace(bool on) { _createFrontFace=on; }
    	inline bool getCreateBackFace() const { return _createFrontFace; }

    	inline void setCreateNormals(bool on) { _createNormals=on; }
    	inline bool getCreateNormals() const { return _createNormals; }

    	inline void setCreateTextureCoords(bool on) { _createTextureCoords=on; }
    	inline bool getCreateTextureCoords() const { return _createTextureCoords; }

    	inline void setCreateTop(bool on) { _createTop=on; }
    	inline bool getCreateTop() const { return _createTop; }

    	inline void setCreateBody(bool on) { _createBody=on; }
    	inline bool getCreateBody() const { return _createBody; }

    	inline void setCreateBottom(bool on) { _createBottom=on; }
    	inline bool getCreateBottom() const { return _createBottom; }

    protected:
    
    	~TessellationHints() {}

    	
    	TessellationMode _TessellationMode;
    	unsigned int 	_targetNumFaces;

	bool 	    	_createFrontFace;
	bool 	    	_createBackFace;
	bool 	    	_createNormals;
	bool 	    	_createTextureCoords;

	bool 	    	_createTop;
	bool 	    	_createBody;
	bool 	    	_createBottom;

};

class SG_EXPORT ShapeDrawable : public Drawable
{
    public:

        ShapeDrawable();

        ShapeDrawable(Shape* shape);

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        ShapeDrawable(const ShapeDrawable& pg,const CopyOp& copyop=CopyOp::SHALLOW_COPY);
            
        virtual Object* cloneType() const { return new ShapeDrawable(); }
        virtual Object* clone(const CopyOp& copyop) const { return new ShapeDrawable(*this,copyop); }        
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const ShapeDrawable*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "ShapeDrawable"; }


    	void setTessellationHints(TessellationHints* hints) { _tessellationHints = hints; }
    	TessellationHints* getTessellationHints() { return _tessellationHints.get(); }
    	const TessellationHints* getTessellationHints() const { return _tessellationHints.get(); }


        /** draw ShapeDrawable directly ignoring an OpenGL display list which could be attached.
          * This is the internal draw method which does the drawing itself,
          * and is the method to override when deriving from ShapeDrawable for user-drawn objects.
          */
        virtual void drawImplementation(State& state) const;

        /** return false, osg::ShapeDrawable does not support accept(AttributeFunctor&).*/
        virtual bool supports(AttributeFunctor&) const { return false; }

        /** return true, osg::ShapeDrawable does support accept(ConstAttributeFunctor&).*/
        virtual bool supports(ConstAttributeFunctor&) const { return true; }

        /** accept an ConstAttributeFunctor and call its methods to tell it about the interal attributes that this Drawable has.*/
        virtual void accept(ConstAttributeFunctor& af) const;

        /** return true, osg::ShapeDrawable does support accept(PrimitiveFunctor&) .*/
        virtual bool supports(PrimitiveFunctor&) const { return true; }

        /** accept a PrimtiveFunctor and call its methods to tell it about the interal primtives that this Drawable has.*/
        virtual void accept(PrimitiveFunctor& pf) const;

    protected:

        ShapeDrawable& operator = (const ShapeDrawable&) { return *this;}

        virtual ~ShapeDrawable();
       
        virtual bool computeBound() const;
	
	ref_ptr<TessellationHints> _tessellationHints;

};


}

#endif
