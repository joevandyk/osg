#ifndef OSG_OUTPUT
#define OSG_OUTPUT 1

#include <osg/Export>

#include <string>
#include <map>

#ifdef OSG_USE_IO_DOT_H
#include <fstream.h>
#else
#include <fstream>
using namespace std;
#endif

namespace osg {

class Object;

/** ofstream wrapper class for adding support for indenting.
    Used in output of .osg ASCII files to improve their readability.*/
class SG_EXPORT Output : public ofstream
{
    public:

        Output();
        virtual ~Output();

        Output& indent();

        int getIndentStep() const { return _indentStep; }
        void setIndentStep(int step) { _indentStep = step; }

        int getIndent() const { return _indent; }
        void setIndent(int indent)  { _indent = indent; }

        int getNumIndicesPerLine() const { return _numIndicesPerLine; }
        void setNumIndicesPerLine(int num) { _numIndicesPerLine = num; }

        void moveIn();
        void moveOut();
        
        bool getUniqueIDForObject(Object* obj,std::string& uniqueID);
        bool createUniqueIDForObject(Object* obj,std::string& uniqueID);
        bool registerUniqueIDForObject(Object* obj,std::string& uniqueID);


    protected:

        // prevent copy construction and assignment.
        Output(const Output&) : ofstream() {}
        Output& operator = (const Output&) { return *this; }

        virtual void _init();
        virtual void _free();

        int _indent;
        int _indentStep;
        
        int _numIndicesPerLine;

        typedef std::map<Object*,std::string> UniqueIDToLabelMapping;
        UniqueIDToLabelMapping _objectToUniqueIDMap;

};

template<class T>
bool writeArrayBlock(Output& fw,T* start,T* finish)
{
    fw.indent() << "{" << endl;
    fw.moveIn();
    int numIndicesThisLine = 0;
    for(T* itr=start;itr!=finish;++itr)
    {
        if (numIndicesThisLine>=fw.getNumIndicesPerLine()) 
        {
            fw << endl;
            numIndicesThisLine = 0;
        }

        if (numIndicesThisLine==0) fw.indent();
        else fw << " ";

        fw << *itr;

        ++numIndicesThisLine;

    }
    fw << endl;
    fw.moveOut();
    fw.indent() << "}" << endl;
    return true;
}


};

#endif                                            // __SG_OUTPUT_H
