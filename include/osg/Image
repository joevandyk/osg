#ifndef OSG_IMAGE
#define OSG_IMAGE 1

#include <osg/Object>
#include <osg/OSG>

namespace osg {

class Output;
class Input;

/** Image class for encapsulating the storage texture image data.*/
class SG_EXPORT Image : public Object
{

    public :

        Image();

        virtual Object* clone() const { return new Image(); }
        virtual bool isSameKindAs(Object* obj) { return dynamic_cast<Image*>(obj)!=NULL; }
        virtual const char* className() const { return "Image"; }


        const char* getFileName() { return _fileName; }
        void setFileName(const char* fileName);
        
        /** set the image data and format.
          * note, when no packing value is negative (the default is -1) this method assumes
          * a _packing width of 1 if the width is not a multiple of 4,
          * otherwise automatically sets to _packing to 4. If a postive
          * value of packing is supplied than _packing is simply set to that value.
          */
        void setImage(int s,int t,int r,
            int internalFormat,
            unsigned int pixelFormat,
            unsigned int dataType,
            unsigned char *data,
            int packing=-1);

        /** Width of image.*/
        int s() { return _s; }
        /** Height of image.*/
        int t() { return _t; }
        /** Depth of image.*/
        int r() { return _r; }
        
        int internalFormat() { return _internalFormat; }
        unsigned int pixelFormat() { return _pixelFormat; }
        unsigned int dataType() { return _dataType; }
        unsigned int packing() { return _packing; }
        
        /** raw image data.*/
        unsigned char *data() { return _data; }
        
        /** Scale image to specified size. */
        void scaleImage(int s,int t,int r);

        /** Ensure image dimensions are a power of two.
          * Mip Mapped texture require the image dimensions to be
          * power of two.
          */
        void ensureDimensionsArePowerOfTwo();
        
    protected :

        virtual ~Image();

//	Image(const Image&) {}
//        Image& operator = (const Image& image) {}

        virtual bool readLocalData(Input& fr);
        virtual bool writeLocalData(Output& fw);

        char* _fileName;
        int _s, _t, _r;
        int _internalFormat;
        unsigned int _pixelFormat;
        unsigned int _dataType;
        unsigned int _packing;
        unsigned char *_data;

};

class Geode;

/** Convinience function to be used by images loaders to generate a valid geode  to return for readNode().  
  * Use the images s and t values scale the dimensions of the image.
  */
SG_EXPORT extern Geode* createGeodeForImage(Image* image);
/** Convinience function to be used by images loaders to generate a valid geode  to return for readNode().  
  * Use the specified s and t values scale the dimensions of the image.
  */
SG_EXPORT extern Geode* createGeodeForImage(Image* image,float s,float t);

};

#endif                                            // __SG_IMAGE_H
