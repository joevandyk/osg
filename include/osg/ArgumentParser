/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2003 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_ARGUMENTPARSER
#define OSG_ARGUMENTPARSER 1

#include <osg/Export>

#include <map>
#include <string>
#include <ostream>

namespace osg {

// forward declare
class ApplicationUsage;

class SG_EXPORT ArgumentParser
{
    public:

        class Parameter
        {
        public:
            enum ParameterType
            {
                FLOAT_PARAMETER,
                DOUBLE_PARAMETER,
                INT_PARAMETER,
                UNSIGNED_INT_PARAMETER,
                STRING_PARAMETER,
            };
        
            union ValueUnion
            {
                float*          _float;
                double*         _double;
                int*            _int;
                unsigned int*   _uint;
                std::string*    _string;
            };

            Parameter(float& value) { _type = FLOAT_PARAMETER; _value._float = &value; }
                
            Parameter(double& value) { _type = DOUBLE_PARAMETER; _value._double = &value; }

            Parameter(int& value) { _type = INT_PARAMETER; _value._int = &value; }

            Parameter(unsigned int& value)  { _type = UNSIGNED_INT_PARAMETER; _value._uint = &value; }
            
            Parameter(std::string& value) { _type = STRING_PARAMETER; _value._string = &value; }

            bool valid(const char* str) const;
            bool assign(const char* str);

        protected:
        
            ParameterType   _type;
            ValueUnion      _value;
        };

        /** return return true if specified string is an option in the form of -option or --option .*/
        static bool isOption(const char* str);
        
        /** return return true if string is any other string apart from an option.*/
        static bool isString(const char* str);
        
        /** return return true if specified parameter is an number.*/
        static bool isNumber(const char* str);

    public:

        ArgumentParser(int* argc,char **argv);

        void setApplicationUsage(ApplicationUsage* usage) { _usage = usage; }
        ApplicationUsage* getApplicationUsage() { return _usage; }
        const ApplicationUsage* getApplicationUsage() const { return _usage; }

        /** return the argument count.*/
        int& argc() { return *_argc; }

        /** return the argument array.*/
        char** argv() { return _argv; }

        /** return char* argument at specificed position.*/
        char* operator [] (int pos) { return _argv[pos]; }

        /** return const char* argument at specificed position.*/
        const char* operator [] (int pos) const { return _argv[pos]; }

        /** return the application name, as specified by argv[0] */
        std::string getApplicationName() const;

        /** return the position of an occurance of a string in the argument list.
          * return -1 when no string is found.*/      
        int find(const std::string& str) const;

        /** return return true if specified parameter is an option in the form of -option or --option .*/
        bool isOption(int pos) const;
        
        /** return return true if specified parameter is an string, which can be any other string apart from an option.*/
        bool isString(int pos) const;
        
        /** return return true if specified parameter is an number.*/
        bool isNumber(int pos) const;
        
        bool containsOptions() const;

        /** remove one or more arguments from the argv argument list, and decrement the argc respectively.*/
        void remove(int pos,int num=1);
        
        /** return true if specified argument matches string.*/        
        bool match(int pos, const std::string& str) const;

        /** search for an occurance of a string in the argument list, on sucess
          * remove that occurance from the list and return true, otherwise return false.*/
        bool read(const std::string& str);
        bool read(const std::string& str, Parameter value1);
        bool read(const std::string& str, Parameter value1, Parameter value2);
        bool read(const std::string& str, Parameter value1, Parameter value2, Parameter value3);
        bool read(const std::string& str, Parameter value1, Parameter value2, Parameter value3, Parameter value4);


        /** if the argument value at the position pos matches specified string, and subsequent
          * paramters are also matched then set the paramter values and remove the from the list of arguments.*/
        bool read(int pos, const std::string& str);
        bool read(int pos, const std::string& str, Parameter value1);
        bool read(int pos, const std::string& str, Parameter value1, Parameter value2);
        bool read(int pos, const std::string& str, Parameter value1, Parameter value2, Parameter value3);
        bool read(int pos, const std::string& str, Parameter value1, Parameter value2, Parameter value3, Parameter value4);


        enum ErrorSeverity
        {
            BENIGN = 0,
            CRITICAL = 1
        };

        typedef std::map<std::string,ErrorSeverity> ErrorMessageMap;

        /** return the error flag, true if an error has occured when reading arguments.*/
        bool errors(ErrorSeverity severity=BENIGN) const;

        /** report an error message by adding to the ErrorMessageMap.*/
        void reportError(const std::string& message,ErrorSeverity severity=CRITICAL);

        /** for each remaining option report it as an unrecongnized.*/
        void reportRemainingOptionsAsUnrecognized(ErrorSeverity severity=BENIGN);
        
        /** return the error message, if any has occured.*/
        ErrorMessageMap& getErrorMessageMap() { return _errorMessageMap; }
      
        /** return the error message, if any has occured.*/
        const ErrorMessageMap& getErrorMessageMap() const { return _errorMessageMap; }

        /** write out error messages at an above specified .*/
        void writeErrorMessages(std::ostream& output,ErrorSeverity sevrity=BENIGN);

  
  protected:
        
        int*                _argc;
        char**              _argv;
        ErrorMessageMap     _errorMessageMap;
        ApplicationUsage*   _usage;
        
};

}

#endif
