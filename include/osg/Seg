#ifndef OSG_SEG
#define OSG_SEG 1

#include <osg/Vec3>
#include <osg/Types>
#include <osg/Matrix>
#include <osg/Referenced>
#include <osg/BoundingBox>
#include <osg/BoundingSphere>

namespace osg {

/** Segment class for representing a line segment.*/
class SG_EXPORT Seg : public Referenced
{
    public:

        Seg() {};
        Seg(const Seg& seg) : Referenced(),_s(seg._s),_e(seg._e) {}
        Seg(const Vec3& s,const Vec3& e) : _s(s),_e(e) {}
        virtual ~Seg() {}

        Seg& operator = (const Seg& seg) { _s = seg._s;  _e = seg._e; return *this; }

        void set(const Vec3& s,const Vec3& e) { _s=s; _e=e; }
        
        const Vec3& start() const { return _s; }
        Vec3& start() { return _s; }

        const Vec3& end() const { return _e; }
        Vec3& end() { return _e; }

        /** return true if segment intersects BoundingBox.*/
        bool intersect(const BoundingBox& bb) const;

        /** return true if segment intersects BoundingSphere and return the intersection ratio's.*/
        bool intersect(const BoundingBox& bb,float& r1,float& r2) const;

        /** return true if segment intersects BoundingSphere.*/
        bool intersect(const BoundingSphere& bs) const;

        /** return true if segment intersects BoundingSphere and return the intersection ratio's.*/
        bool intersect(const BoundingSphere& bs,float& r1,float& r2) const;
        
        /** return true if segment intersects triangle and set ratio long segment. */
        bool intersect(const Vec3& v1,const Vec3& v2,const Vec3& v3,float& r);

        /** post multiply a segment by matrix.*/
        void mult(const Seg& seg,const Matrix& m) { _s = seg._s*m; _e = seg._e*m; }
        /** pre multiply a segment by matrix.*/
        void mult(const Matrix& m,const Seg& seg) { _s = m*seg._s; _e = m*seg._e; }

    protected:

        static bool intersectAndClip(Vec3& s,Vec3& e,const BoundingBox& bb);

        Vec3 _s;
        Vec3 _e;
};

};

#endif
