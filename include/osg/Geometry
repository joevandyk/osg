//C++ header - Open Scene Graph - Copyright (C) 1998-2002 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSG_GEOMETRY
#define OSG_GEOMETRY 1

#include <osg/Drawable>
#include <osg/Vec2>
#include <osg/Vec3>
#include <osg/Vec4>
#include <osg/Array>
#include <osg/Primitive>

namespace osg {


class SG_EXPORT Geometry : public Drawable
{
    public:

        Geometry();

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        Geometry(const Geometry& Geometry,const CopyOp& copyop=CopyOp::SHALLOW_COPY);
            
        virtual Object* cloneType() const { return osgNew Geometry(); }
        virtual Object* clone(const CopyOp& copyop) const { return osgNew Geometry(*this,copyop); }        
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const Geometry*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "Geometry"; }

        enum AttributeBinding
        {
            BIND_OFF=0,
            BIND_OVERALL,
            BIND_PER_PRIMITIVE,
            BIND_PER_VERTEX
        };
               
        void setVertexArray(Vec3Array* array) { _vertexArray = array; dirtyDisplayList(); }
        Vec3Array* getVertexArray() { return _vertexArray.get(); }
        const Vec3Array* getVertexArray() const  { return _vertexArray.get(); }


        void setNormalBinding(AttributeBinding ab) { _normalBinding = ab; dirtyDisplayList(); }
        AttributeBinding getNormalBinding() const { return _normalBinding; }

        void setNormalArray(Vec3Array* array) { _normalArray = array; if (!_normalArray.valid()) _normalBinding=BIND_OFF; dirtyDisplayList(); }
        Vec3Array* getNormalArray() { return _normalArray.get(); }
        const Vec3Array* getNormalArray() const { return _normalArray.get(); }


        void setColorBinding(AttributeBinding ab) { _colorBinding = ab; }
        AttributeBinding getColorBinding() const { return _colorBinding; }

        void setColorArray(Array* array) { _colorArray = array;  if (!_colorArray.valid()) _colorBinding=BIND_OFF; dirtyDisplayList(); }
        Array* getColorArray() { return _colorArray.get(); }
        const Array* getColorArray() const { return _colorArray.get(); }


        typedef std::vector< ref_ptr<Array> >  TexCoordArrayList;


        void setTexCoordArray(unsigned int unit,Array*);
        Array* getTexCoordArray(unsigned int unit);
        const Array* getTexCoordArray(unsigned int unit) const;
        
        unsigned int getNumTexCoordArrays() const {  return _texCoordList.size(); }
        TexCoordArrayList& getTexCoordArrayList() { return _texCoordList; }
        const TexCoordArrayList& getTexCoordArrayList() const { return _texCoordList; }


        typedef std::vector< ref_ptr<Primitive> > PrimitiveList;

        void setPrimitiveList(const PrimitiveList& primitives) { _primitives = primitives; dirtyDisplayList(); }
        PrimitiveList& getPrimitiveList() { return _primitives; }
        const PrimitiveList& getPrimitiveList() const { return _primitives; }

        unsigned int getNumPrimitives() const { return _primitives.size(); }
        Primitive* getPrimitive(unsigned int pos) { return _primitives[pos].get(); }
        const Primitive* getPrimitive(unsigned int pos) const { return _primitives[pos].get(); }
        
        void addPrimitive(Primitive* primitive) { if (primitive) _primitives.push_back(primitive); dirtyDisplayList(); }


        bool verifyBindings() const;

        void computeCorrectBindingsAndArraySizes();


        /** draw Geometry directly ignoring an OpenGL display list which could be attached.
          * This is the internal draw method which does the drawing itself,
          * and is the method to override when deriving from Geometry for user-drawn objects.
          */
        virtual void drawImmediateMode(State& state);

        /** accept an AttributeFunctor and call its methods to tell it about the interal attributes that this Drawable has.*/
        virtual void accept(AttributeFunctor& af);

        /** accept a PrimtiveFunctor and call its methods to tell it about the interal primtives that this Drawable has.*/
        virtual void accept(PrimitiveFunctor& pf);

    protected:

        Geometry& operator = (const Geometry&) { return *this;}

        virtual ~Geometry();

        //virtual const bool computeBound() const;
        
        
        
        PrimitiveList               _primitives;
        
        ref_ptr<Vec3Array>          _vertexArray;

        AttributeBinding            _normalBinding;
        ref_ptr<Vec3Array>          _normalArray;
        
        AttributeBinding            _colorBinding;
        ref_ptr<Array>              _colorArray;
        
        TexCoordArrayList           _texCoordList;

};


}

#endif
