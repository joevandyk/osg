/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2003 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_GEOMETRY
#define OSG_GEOMETRY 1

#include <osg/Drawable>
#include <osg/Vec2>
#include <osg/Vec3>
#include <osg/Vec4>
#include <osg/Array>
#include <osg/PrimitiveSet>

namespace osg {


class SG_EXPORT Geometry : public Drawable
{
    public:

        Geometry();

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        Geometry(const Geometry& geometry,const CopyOp& copyop=CopyOp::SHALLOW_COPY);
            
        virtual Object* cloneType() const { return new Geometry(); }
        virtual Object* clone(const CopyOp& copyop) const { return new Geometry(*this,copyop); }        
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const Geometry*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "Geometry"; }

        virtual Geometry* asGeometry() { return this; }
        virtual const Geometry* asGeometry() const { return this; }

        enum AttributeBinding
        {
            BIND_OFF=0,
            BIND_OVERALL,
            BIND_PER_PRIMITIVE_SET,
            BIND_PER_PRIMITIVE,
            BIND_PER_VERTEX
        };
               
        void setVertexArray(Vec3Array* array) { _vertexArray = array; dirtyDisplayList(); dirtyBound(); }
        Vec3Array* getVertexArray() { return _vertexArray.get(); }
        const Vec3Array* getVertexArray() const  { return _vertexArray.get(); }

        void setVertexIndices(IndexArray* array) { _vertexIndices = array; _fastPathComputed=false; dirtyDisplayList(); dirtyBound(); }
        IndexArray* getVertexIndices() { return _vertexIndices.get(); }
        const IndexArray* getVertexIndices() const  { return _vertexIndices.get(); }


        void setNormalBinding(AttributeBinding ab) { _normalBinding = ab; dirtyDisplayList(); _fastPathComputed=false; }
        AttributeBinding getNormalBinding() const { return _normalBinding; }

        void setNormalArray(Vec3Array* array) { _normalArray = array; if (!_normalArray.valid()) _normalBinding=BIND_OFF; _fastPathComputed=false; dirtyDisplayList(); }
        Vec3Array* getNormalArray() { return _normalArray.get(); }
        const Vec3Array* getNormalArray() const { return _normalArray.get(); }

        void setNormalIndices(IndexArray* array) { _normalIndices = array; _fastPathComputed=false; dirtyDisplayList(); }
        IndexArray* getNormalIndices() { return _normalIndices.get(); }
        const IndexArray* getNormalIndices() const { return _normalIndices.get(); }


        void setColorBinding(AttributeBinding ab) { _colorBinding = ab; _fastPathComputed=false;}
        AttributeBinding getColorBinding() const { return _colorBinding; }

        void setColorArray(Array* array) { _colorArray = array;  if (!_colorArray.valid()) _colorBinding=BIND_OFF; _fastPathComputed=false; dirtyDisplayList(); }
        Array* getColorArray() { return _colorArray.get(); }
        const Array* getColorArray() const { return _colorArray.get(); }

        void setColorIndices(IndexArray* array) { _colorIndices = array;  _fastPathComputed=false; dirtyDisplayList(); }
        IndexArray* getColorIndices() { return _colorIndices.get(); }
        const IndexArray* getColorIndices() const { return _colorIndices.get(); }


        void setSecondaryColorBinding(AttributeBinding ab) { _secondaryColorBinding = ab; _fastPathComputed=false;}
        AttributeBinding getSecondaryColorBinding() const { return _secondaryColorBinding; }

        void setSecondaryColorArray(Array* array) { _secondaryColorArray = array;  if (!_secondaryColorArray.valid()) _secondaryColorBinding=BIND_OFF; _fastPathComputed=false; dirtyDisplayList(); }
        Array* getSecondaryColorArray() { return _secondaryColorArray.get(); }
        const Array* getSecondaryColorArray() const { return _secondaryColorArray.get(); }

        void setSecondaryColorIndices(IndexArray* array) { _secondaryColorIndices = array;  _fastPathComputed=false; dirtyDisplayList(); }
        IndexArray* getSecondaryColorIndices() { return _secondaryColorIndices.get(); }
        const IndexArray* getSecondaryColorIndices() const { return _secondaryColorIndices.get(); }


        void setFogCoordBinding(AttributeBinding ab) { _fogCoordBinding = ab; _fastPathComputed=false;}
        AttributeBinding getFogCoordBinding() const { return _fogCoordBinding; }

        void setFogCoordArray(Array* array) { _fogCoordArray = array; if (!_fogCoordArray.valid()) _fogCoordBinding=BIND_OFF; dirtyDisplayList(); }
        Array* getFogCoordArray() { return _fogCoordArray.get(); }
        const Array* getFogCoordArray() const { return _fogCoordArray.get(); }


        void setFogCoordIndices(IndexArray* array) { _fogCoordIndices = array; dirtyDisplayList(); }
        IndexArray* getFogCoordIndices() { return _fogCoordIndices.get(); }
        const IndexArray* getFogCoordIndices() const { return _fogCoordIndices.get(); }



        typedef std::pair< ref_ptr<Array>, ref_ptr<IndexArray> >  TexCoordArrayPair;
        typedef std::vector< TexCoordArrayPair >  TexCoordArrayList;


        void setTexCoordArray(unsigned int unit,Array*);
        Array* getTexCoordArray(unsigned int unit);
        const Array* getTexCoordArray(unsigned int unit) const;
        
        void setTexCoordIndices(unsigned int unit,IndexArray*);
        IndexArray* getTexCoordIndices(unsigned int unit);
        const IndexArray* getTexCoordIndices(unsigned int unit) const;

        unsigned int getNumTexCoordArrays() const {  return _texCoordList.size(); }
        TexCoordArrayList& getTexCoordArrayList() { return _texCoordList; }
        const TexCoordArrayList& getTexCoordArrayList() const { return _texCoordList; }


        typedef std::vector< ref_ptr<PrimitiveSet> > PrimitiveSetList;

        void setPrimitiveSetList(const PrimitiveSetList& primitives) { _primitives = primitives; dirtyDisplayList(); dirtyBound(); }
        PrimitiveSetList& getPrimitiveSetList() { return _primitives; }
        const PrimitiveSetList& getPrimitiveSetList() const { return _primitives; }

        unsigned int getNumPrimitiveSets() const { return _primitives.size(); }
        PrimitiveSet* getPrimitiveSet(unsigned int pos) { return _primitives[pos].get(); }
        const PrimitiveSet* getPrimitiveSet(unsigned int pos) const { return _primitives[pos].get(); }
        
        /** Add a primitive set to the geometry.*/
        bool addPrimitiveSet(PrimitiveSet* primitiveset);
        
        /** Set a primitive set to the specified position in geometry's primitive set list.*/
        bool setPrimitiveSet(unsigned int i,PrimitiveSet* primitiveset);
        
        /** Insert a primitive set to the specified position in geometry's primitive set list.*/
        bool insertPrimitiveSet(unsigned int i,PrimitiveSet* primitiveset);
        
        /** Remove primitive set(s) from the specified position in geometry's primitive set list.*/
        bool removePrimitiveSet(unsigned int i,unsigned int numElementsToRemove=1);

        /** Get the index number of a primitive set, return a value between
          * 0 and getNumPrimitiveSet()-1 if found, if not found then return getNumPrimitiveSet().
          * When checking for a valid find value use if ((value=geoemtry->getPrimitiveSetIndex(primitive))!=geometry.getNumPrimitiveSet()) as*/
        unsigned int getPrimitiveSetIndex(const PrimitiveSet* primitiveset) const;


        /** return true if OpenGL fast paths will be used with drawing this Geometry.
          * Fast paths use vertex arrays, and glDrawArrays/glDrawElements.  Slow paths
          * use glBegin()/glVertex.../glEnd(). Use of per primitive bindings or per vertex indexed
          * arrays will drop the rendering path off the fast path.*/
        bool areFastPathsUsed() const;


        bool verifyBindings() const;
        void computeCorrectBindingsAndArraySizes();


        /** draw Geometry directly ignoring an OpenGL display list which could be attached.
          * This is the internal draw method which does the drawing itself,
          * and is the method to override when deriving from Geometry for user-drawn objects.
          */
        virtual void drawImplementation(State& state) const;

        /** return true, osg::Geometry does support accept(AttributeFunctor&).*/
        virtual bool supports(AttributeFunctor&) const { return true; }

        /** accept an AttributeFunctor and call its methods to tell it about the interal attributes that this Drawable has.*/
        virtual void accept(AttributeFunctor& af);

        /** return true, osg::Geometry does support accept(ConstAttributeFunctor&).*/
        virtual bool supports(ConstAttributeFunctor&) const { return true; }

        /** accept an ConstAttributeFunctor and call its methods to tell it about the interal attributes that this Drawable has.*/
        virtual void accept(ConstAttributeFunctor& af) const;

        /** return true, osg::Geometry does support accept(PrimitiveFunctor&) .*/
        virtual bool supports(PrimitiveFunctor&) const { return true; }

        /** accept a PrimitiveFunctor and call its methods to tell it about the interal primitives that this Drawable has.*/
        virtual void accept(PrimitiveFunctor& pf) const;

    protected:

        Geometry& operator = (const Geometry&) { return *this;}

        virtual ~Geometry();
       
        PrimitiveSetList            _primitives;
        
        ref_ptr<Vec3Array>          _vertexArray;
        ref_ptr<IndexArray>         _vertexIndices;

        mutable AttributeBinding    _normalBinding;
        ref_ptr<Vec3Array>          _normalArray;
        ref_ptr<IndexArray>         _normalIndices;
        
        mutable AttributeBinding    _colorBinding;
        ref_ptr<Array>              _colorArray;
        ref_ptr<IndexArray>         _colorIndices;
        
        mutable AttributeBinding    _secondaryColorBinding;
        ref_ptr<Array>              _secondaryColorArray;
        ref_ptr<IndexArray>         _secondaryColorIndices;

        mutable AttributeBinding    _fogCoordBinding;
        ref_ptr<Array>              _fogCoordArray;
        ref_ptr<IndexArray>         _fogCoordIndices;
        
        TexCoordArrayList           _texCoordList;
        
        mutable bool               _fastPathComputed;
        mutable bool               _fastPath;

};


}

#endif
