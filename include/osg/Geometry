//C++ header - Open Scene Graph - Copyright (C) 1998-2002 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSG_GEOMETRY
#define OSG_GEOMETRY 1

#include <osg/Drawable>
#include <osg/Vec2>
#include <osg/Vec3>
#include <osg/Vec4>
#include <osg/Array>
#include <osg/PrimitiveSet>

namespace osg {


class SG_EXPORT Geometry : public Drawable
{
    public:

        Geometry();

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        Geometry(const Geometry& geometry,const CopyOp& copyop=CopyOp::SHALLOW_COPY);
            
        virtual Object* cloneType() const { return osgNew Geometry(); }
        virtual Object* clone(const CopyOp& copyop) const { return osgNew Geometry(*this,copyop); }        
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const Geometry*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "Geometry"; }

        virtual Geometry* asGeometry() { return this; }
        virtual const Geometry* asGeometry() const { return this; }

        enum AttributeBinding
        {
            BIND_OFF=0,
            BIND_OVERALL,
            BIND_PER_PRIMITIVE_SET,
            BIND_PER_PRIMITIVE,
            BIND_PER_VERTEX
        };
               
        void setVertexArray(Vec3Array* array) { _vertexArray = array; dirtyDisplayList(); dirtyBound(); }
        Vec3Array* getVertexArray() { return _vertexArray.get(); }
        const Vec3Array* getVertexArray() const  { return _vertexArray.get(); }

        void setVertexIndices(IndexArray* array) { _vertexIndices = array; _fastPathComputed=false; dirtyDisplayList(); dirtyBound(); }
        IndexArray* getVertexIndices() { return _vertexIndices.get(); }
        const IndexArray* getVertexIndices() const  { return _vertexIndices.get(); }


        void setNormalBinding(AttributeBinding ab) { _normalBinding = ab; dirtyDisplayList(); _fastPathComputed=false; }
        AttributeBinding getNormalBinding() const { return _normalBinding; }

        void setNormalArray(Vec3Array* array) { _normalArray = array; if (!_normalArray.valid()) _normalBinding=BIND_OFF; _fastPathComputed=false; dirtyDisplayList(); }
        Vec3Array* getNormalArray() { return _normalArray.get(); }
        const Vec3Array* getNormalArray() const { return _normalArray.get(); }

        void setNormalIndices(IndexArray* array) { _normalIndices = array; _fastPathComputed=false; dirtyDisplayList(); }
        IndexArray* getNormalIndices() { return _normalIndices.get(); }
        const IndexArray* getNormalIndices() const { return _normalIndices.get(); }


        void setColorBinding(AttributeBinding ab) { _colorBinding = ab; _fastPathComputed=false;}
        AttributeBinding getColorBinding() const { return _colorBinding; }

        void setColorArray(Array* array) { _colorArray = array;  if (!_colorArray.valid()) _colorBinding=BIND_OFF; _fastPathComputed=false; dirtyDisplayList(); }
        Array* getColorArray() { return _colorArray.get(); }
        const Array* getColorArray() const { return _colorArray.get(); }

        void setColorIndices(IndexArray* array) { _colorIndices = array;  _fastPathComputed=false; dirtyDisplayList(); }
        IndexArray* getColorIndices() { return _colorIndices.get(); }
        const IndexArray* getColorIndices() const { return _colorIndices.get(); }


        void setSecondaryColorBinding(AttributeBinding ab) { _secondaryColorBinding = ab; _fastPathComputed=false;}
        AttributeBinding getSecondaryColorBinding() const { return _secondaryColorBinding; }

        void setSecondaryColorArray(Array* array) { _secondaryColorArray = array;  if (!_secondaryColorArray.valid()) _secondaryColorBinding=BIND_OFF; _fastPathComputed=false; dirtyDisplayList(); }
        Array* getSecondaryColorArray() { return _secondaryColorArray.get(); }
        const Array* getSecondaryColorArray() const { return _secondaryColorArray.get(); }

        void setSecondaryColorIndices(IndexArray* array) { _secondaryColorIndices = array;  _fastPathComputed=false; dirtyDisplayList(); }
        IndexArray* getSecondaryColorIndices() { return _secondaryColorIndices.get(); }
        const IndexArray* getSecondaryColorIndices() const { return _secondaryColorIndices.get(); }


        void setFogCoordBinding(AttributeBinding ab) { _fogCoordBinding = ab; _fastPathComputed=false;}
        AttributeBinding getFogCoordBinding() const { return _fogCoordBinding; }

        void setFogCoordArray(FloatArray* array) { _fogCoordArray = array; if (!_fogCoordArray.valid()) _fogCoordBinding=BIND_OFF; dirtyDisplayList(); }
        FloatArray* getFogCoordArray() { return _fogCoordArray.get(); }
        const FloatArray* getFogCoordArray() const { return _fogCoordArray.get(); }


        void setFogCoordIndices(IndexArray* array) { _fogCoordIndices = array; dirtyDisplayList(); }
        IndexArray* getFogCoordIndices() { return _fogCoordIndices.get(); }
        const IndexArray* getFogCoordIndices() const { return _fogCoordIndices.get(); }



        typedef std::pair< ref_ptr<Array>, ref_ptr<IndexArray> >  TexCoordArrayPair;
        typedef std::vector< TexCoordArrayPair >  TexCoordArrayList;


        void setTexCoordArray(unsigned int unit,Array*);
        Array* getTexCoordArray(unsigned int unit);
        const Array* getTexCoordArray(unsigned int unit) const;
        
        void setTexCoordIndices(unsigned int unit,IndexArray*);
        IndexArray* getTexCoordIndices(unsigned int unit);
        const IndexArray* getTexCoordIndices(unsigned int unit) const;

        unsigned int getNumTexCoordArrays() const {  return _texCoordList.size(); }
        TexCoordArrayList& getTexCoordArrayList() { return _texCoordList; }
        const TexCoordArrayList& getTexCoordArrayList() const { return _texCoordList; }


        typedef std::vector< ref_ptr<PrimitiveSet> > PrimitiveSetList;

        void setPrimitiveSetList(const PrimitiveSetList& primitives) { _primitives = primitives; dirtyDisplayList(); dirtyBound(); }
        PrimitiveSetList& getPrimitiveSetList() { return _primitives; }
        const PrimitiveSetList& getPrimitiveSetList() const { return _primitives; }

        unsigned int getNumPrimitiveSets() const { return _primitives.size(); }
        PrimitiveSet* getPrimitiveSet(unsigned int pos) { return _primitives[pos].get(); }
        const PrimitiveSet* getPrimitiveSet(unsigned int pos) const { return _primitives[pos].get(); }
        
        void addPrimitiveSet(PrimitiveSet* primitive) { if (primitive) _primitives.push_back(primitive); dirtyDisplayList(); dirtyBound(); }

#ifdef USE_DEPRECATED_API

        typedef PrimitiveSetList PrimitiveList;

        void setPrimitiveList(const PrimitiveSetList& primitives) { _primitives = primitives; dirtyDisplayList(); dirtyBound(); }
        PrimitiveList& getPrimitiveList() { return _primitives; }
        const PrimitiveList& getPrimitiveList() const { return _primitives; }

        unsigned int getNumPrimitives() const { return _primitives.size(); }
        Primitive* getPrimitive(unsigned int pos) { return _primitives[pos].get(); }
        const Primitive* getPrimitive(unsigned int pos) const { return _primitives[pos].get(); }

        void addPrimitive(PrimitiveSet* primitive) { if (primitive) _primitives.push_back(primitive); dirtyDisplayList(); dirtyBound(); }

#endif

        /** return true if OpenGL fast paths will be used with drawing this Geometry.
          * Fast paths use vertex arrays, and glDrawArrays/glDrawElements.  Slow paths
          * use glBegin()/glVertex.../glEnd(). Use of per primtive bindings or per vertex indexed
          * arrays will drop the rendering path off the fast path.*/
        bool areFastPathsUsed() const;


        bool verifyBindings() const;
        void computeCorrectBindingsAndArraySizes();


        /** draw Geometry directly ignoring an OpenGL display list which could be attached.
          * This is the internal draw method which does the drawing itself,
          * and is the method to override when deriving from Geometry for user-drawn objects.
          */
        virtual void drawImmediateMode(State& state);

        /** accept an AttributeFunctor and call its methods to tell it about the interal attributes that this Drawable has.*/
        virtual void accept(AttributeFunctor& af);

        /** accept a PrimtiveFunctor and call its methods to tell it about the interal primtives that this Drawable has.*/
        virtual void accept(PrimitiveFunctor& pf);

    protected:

        Geometry& operator = (const Geometry&) { return *this;}

        virtual ~Geometry();
       
        PrimitiveSetList            _primitives;
        
        ref_ptr<Vec3Array>          _vertexArray;
        ref_ptr<IndexArray>         _vertexIndices;

        mutable AttributeBinding    _normalBinding;
        ref_ptr<Vec3Array>          _normalArray;
        ref_ptr<IndexArray>         _normalIndices;
        
        mutable AttributeBinding    _colorBinding;
        ref_ptr<Array>              _colorArray;
        ref_ptr<IndexArray>         _colorIndices;
        
        mutable AttributeBinding    _secondaryColorBinding;
        ref_ptr<Array>              _secondaryColorArray;
        ref_ptr<IndexArray>         _secondaryColorIndices;

        mutable AttributeBinding    _fogCoordBinding;
        ref_ptr<FloatArray>         _fogCoordArray;
        ref_ptr<IndexArray>         _fogCoordIndices;
        
        TexCoordArrayList           _texCoordList;
        
        mutable bool               _fastPathComputed;
        mutable bool               _fastPath;

};


}

#endif
