//C++ header - Open Scene Graph - Copyright (C) 1998-2001 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSG_GEOMETRY
#define OSG_GEOMETRY 1

#include <osg/Drawable>
#include <osg/Vec2>
#include <osg/Vec3>
#include <osg/Vec4>

namespace osg {

enum ArrayType
{
    AttributeArrayType = 0,
    ByteArrayType     = 1,
    ShortArrayType    = 2,
    IntArrayType      = 3,
    UByteArrayType    = 4,
    UShortArrayType   = 5,
    UIntArrayType     = 6,
    UByte4ArrayType   = 7,
    FloatArrayType    = 8,
    Vec2ArrayType     = 9,
    Vec3ArrayType     = 10,
    Vec4ArrayType     = 11
};

class SG_EXPORT AttributeArray : public Object
{

    public:
    
        AttributeArray(ArrayType arrayType=AttributeArrayType,GLint dataSize=0,GLenum dataType=0):
            _arrayType(arrayType),
            _dataSize(dataSize),
            _dataType(dataType) {}
    
        AttributeArray(const AttributeArray& array,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            Object(array,copyop),
            _arrayType(array._arrayType),
            _dataSize(array._dataSize),
            _dataType(array._dataType) {}

        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const AttributeArray*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const;


        ArrayType               arrayType() const { return _arrayType; }
        GLint                   dataSize() const { return _dataSize; }
        GLenum                  dataType() const { return _dataType; }
        virtual const GLvoid*   dataPointer() const = 0;

    protected:
    
        virtual ~AttributeArray() {}

        ArrayType   _arrayType;
        GLint       _dataSize;
        GLenum      _dataType;
};



template<typename T, ArrayType ARRAYTYPE, int DataSize, int DataType>
class TemplateArray : public AttributeArray, public std::vector<T>
{
    public:
    
        TemplateArray() : AttributeArray(ARRAYTYPE,DataSize,DataType) {}

        TemplateArray(const TemplateArray& ta,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            AttributeArray(ta,copyop),
            std::vector<T>(ta) {}
        
        TemplateArray(unsigned int no) : 
            AttributeArray(ARRAYTYPE,DataSize,DataType),
            std::vector<T>(no) {}

        TemplateArray(unsigned int no,T* ptr) : 
            AttributeArray(ARRAYTYPE,DataSize,DataType),
            std::vector<T>(ptr,ptr+no) {}


#ifdef __STL_MEMBER_TEMPLATES
        template <class InputIterator>
        TemplateArray(InputIterator first,InputIterator last) : 
            AttributeArray(ARRAYTYPE,DataSize,DataType),
            std::vector<T>(first,last) {}        
#else
        TemplateArray(T* first,T* last) : 
            AttributeArray(ARRAYTYPE,DataSize,DataType),
            std::vector<T>(first,last) {}
#endif

        virtual Object* cloneType() const { return osgNew TemplateArray(); }
        virtual Object* clone(const CopyOp& copyop) const { return osgNew TemplateArray(*this,copyop); }        

        virtual const GLvoid*   dataPointer() const { if (!empty()) return &front(); else return 0; }
};

typedef TemplateArray<char,ByteArrayType,1,GL_BYTE>                       ByteArray;
typedef TemplateArray<short,ShortArrayType,1,GL_SHORT>                    ShortArray;
typedef TemplateArray<int,IntArrayType,1,GL_INT>                          IntArray;
typedef TemplateArray<unsigned char,UByteArrayType,1,GL_UNSIGNED_BYTE>    UByteArray;
typedef TemplateArray<unsigned short,UShortArrayType,1,GL_UNSIGNED_SHORT> UShortArray;
typedef TemplateArray<unsigned int,UIntArrayType,1,GL_UNSIGNED_INT>       UIntArray;
typedef TemplateArray<unsigned int,UByte4ArrayType,4,GL_UNSIGNED_BYTE>    UByte4Array;
typedef TemplateArray<float,FloatArrayType,1,GL_FLOAT>                    FloatArray;
typedef TemplateArray<Vec2,Vec2ArrayType,2,GL_FLOAT>                      Vec2Array;
typedef TemplateArray<Vec3,Vec3ArrayType,3,GL_FLOAT>                      Vec3Array;
typedef TemplateArray<Vec4,Vec4ArrayType,4,GL_FLOAT>                      Vec4Array;

/* ******************************************************************************************************************* */

enum PrimitiveType
{
    PrimitivePrimitiveType              = 0,
    DrawArraysPrimitiveType             = 1,
    UByteDrawElementsPrimitiveType      = 2,
    UShortDrawElementsPrimitiveType     = 3,
    UIntDrawElementsPrimitiveType       = 4,
};

class SG_EXPORT Primitive : public Object
{
    public:
    
        enum Mode
        {
            POINTS = GL_POINTS,
            LINES = GL_LINES,
            LINE_STRIP = GL_LINE_STRIP,
            LINE_LOOP = GL_LINE_LOOP,
            TRIANGLES = GL_TRIANGLES,
            TRIANGLE_STRIP = GL_TRIANGLE_STRIP,
            TRIANGLE_FAN = GL_TRIANGLE_FAN,
            QUADS = GL_QUADS,
            QUAD_STRIP = GL_QUAD_STRIP,
            POLYGON = GL_POLYGON
        };

        Primitive(PrimitiveType primType=PrimitivePrimitiveType,GLenum mode=0):
            _primitiveType(primType),
            _mode(mode) {}
    
        Primitive(const Primitive& prim,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            Object(prim,copyop),
            _primitiveType(prim._primitiveType),
            _mode(prim._mode) {}

        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const Primitive*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const;
        
        PrimitiveType primitiveType() const { return _primitiveType; }
        
        void setMode(GLenum mode) { _mode = mode; }
        GLenum getMode() const { return _mode; }

        virtual void draw() const = 0;
        
        virtual void applyPrimitiveOperation(Drawable::PrimitiveFunctor&) {}

    protected:

        PrimitiveType _primitiveType;
        GLenum  _mode;
};

class DrawArrays : public Primitive
{
    public:

        DrawArrays():
            Primitive(DrawArraysPrimitiveType,0)
            {}
    
        DrawArrays(GLenum mode, GLint first, GLsizei count):
            Primitive(DrawArraysPrimitiveType,mode),
            _first(first),
            _count(count) {}

        DrawArrays(const DrawArrays& da,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            Primitive(da,copyop),
            _first(da._first),
            _count(da._count) {}

        virtual Object* cloneType() const { return osgNew DrawArrays(); }
        virtual Object* clone(const CopyOp& copyop) const { return osgNew DrawArrays(*this,copyop); }        
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const DrawArrays*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "DrawArrays"; }
        

        void set(GLenum mode,GLint first, GLsizei count)
        {
            _mode = mode;
            _first = first;
            _count = count;
        }

        void setFirst(GLint first) { _first = first; }
        GLint getFirst() const { return _first; }
        
        void setCount(GLsizei count) { _count = count; }
        GLsizei getCount() const { return _count; }

        virtual void draw() const 
        {
            glDrawArrays(_mode,_first,_count);
        }
        
        virtual void applyPrimitiveOperation(Drawable::PrimitiveFunctor& functor)
        {
            functor.drawArrays(_mode,_first,_count);
        }

        GLint   _first;
        GLsizei _count;
};

template<typename T, PrimitiveType PRIMTYPE, int DataType>
class DrawElements : public Primitive, public std::vector<T>
{
    public:

        DrawElements(GLenum mode=0):
            Primitive(PRIMTYPE,mode),
            _dataType(DataType) {}
    
        DrawElements(const DrawElements& array,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            Primitive(array,copyop),
            std::vector<T>(array),
            _dataType(array._dataType) {}

        DrawElements(GLenum mode,unsigned int no,T* ptr) : 
            Primitive(PRIMTYPE,mode),
            std::vector<T>(ptr,ptr+no),
            _dataType(DataType) {}

        DrawElements(GLenum mode,unsigned int no) : 
            Primitive(PRIMTYPE,mode),
            std::vector<T>(no),
            _dataType(DataType) {}

#ifdef __STL_MEMBER_TEMPLATES
        template <class InputIterator>
        DrawElements(GLenum mode, InputIterator first,InputIterator last) : 
            Primitive(PRIMTYPE,mode),
            std::vector<T>(first,last),
            _dataType(DataType) {}
#else
        DrawElements(GLenum mode, T* first,T* last) : 
            Primitive(PRIMTYPE,mode),
            std::vector<T>(first,last),
            _dataType(DataType) {}
#endif
        virtual Object* cloneType() const { return osgNew DrawElements(); }
        virtual Object* clone(const CopyOp& copyop) const { return osgNew DrawElements(*this,copyop); }        
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const DrawElements*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }

        virtual void draw() const 
        {
            glDrawElements(_mode,size(),_dataType,&front());
        }
        
        virtual void applyPrimitiveOperation(Drawable::PrimitiveFunctor& functor)
        {
            if (!empty()) functor.drawElements(_mode,size(),&front());
        }

        GLenum  _dataType;
};

typedef DrawElements<unsigned char,UByteDrawElementsPrimitiveType,GL_UNSIGNED_BYTE>     UByteDrawElements;
typedef DrawElements<unsigned short,UShortDrawElementsPrimitiveType,GL_UNSIGNED_SHORT>  UShortDrawElements;
typedef DrawElements<unsigned int,UIntDrawElementsPrimitiveType,GL_UNSIGNED_INT>        UIntDrawElements;


/* ******************************************************************************************************************* */


class SG_EXPORT Geometry : public Drawable
{
    public:

        Geometry();

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        Geometry(const Geometry& Geometry,const CopyOp& copyop=CopyOp::SHALLOW_COPY);
            
        virtual Object* cloneType() const { return osgNew Geometry(); }
        virtual Object* clone(const CopyOp& copyop) const { return osgNew Geometry(*this,copyop); }        
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const Geometry*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "Geometry"; }

        enum AttributeBinding
        {
            BIND_OFF=0,
            BIND_OVERALL,
            BIND_PER_PRIMITIVE,
            BIND_PER_VERTEX,
        };
               
        void setVertexArray(Vec3Array* array) { _vertexArray = array; dirtyDisplayList(); }
        Vec3Array* getVertexArray() { return _vertexArray.get(); }
        const Vec3Array* getVertexArray() const  { return _vertexArray.get(); }


        void setNormalBinding(AttributeBinding ab) { _normalBinding = ab; dirtyDisplayList(); }
        AttributeBinding getNormalBinding() const { return _normalBinding; }

        void setNormalArray(Vec3Array* array) { _normalArray = array; if (!_normalArray.valid()) _normalBinding=BIND_OFF; dirtyDisplayList(); }
        Vec3Array* getNormalArray() { return _normalArray.get(); }
        const Vec3Array* getNormalArray() const { return _normalArray.get(); }


        void setColorBinding(AttributeBinding ab) { _colorBinding = ab; }
        AttributeBinding getColorBinding() const { return _colorBinding; }

        void setColorArray(AttributeArray* array) { _colorArray = array;  if (!_colorArray.valid()) _colorBinding=BIND_OFF; dirtyDisplayList(); }
        AttributeArray* getColorArray() { return _colorArray.get(); }
        const AttributeArray* getColorArray() const { return _colorArray.get(); }


        typedef std::vector< ref_ptr<AttributeArray> >  TexCoordArrayList;


        void setTexCoordArray(unsigned int unit,AttributeArray*);
        AttributeArray* getTexCoordArray(unsigned int unit);
        const AttributeArray* getTexCoordArray(unsigned int unit) const;
        
        unsigned int getNumTexCoordArrays() const {  return _texCoordList.size(); }
        TexCoordArrayList& getTexCoordArrayList() { return _texCoordList; }
        const TexCoordArrayList& getTexCoordArrayList() const { return _texCoordList; }


        typedef std::vector< ref_ptr<Primitive> > PrimitiveList;

        void setPrimitiveList(const PrimitiveList& primitives) { _primitives = primitives; dirtyDisplayList(); }
        PrimitiveList& getPrimitiveList() { return _primitives; }
        const PrimitiveList& getPrimitiveList() const { return _primitives; }

        void addPrimitive(Primitive* primitive) { if (primitive) _primitives.push_back(primitive); dirtyDisplayList(); }



        /** draw Geometry directly ignoring an OpenGL display list which could be attached.
          * This is the internal draw method which does the drawing itself,
          * and is the method to override when deriving from Geometry for user-drawn objects.
          */
        virtual void drawImmediateMode(State& state);

        /** Statistics collection for each drawable- 26.09.01
         */
        bool getStats(Statistics &);


        /** return the attributes supported by applyAttrbuteUpdate() as an AttributeBitMask.*/
        virtual AttributeBitMask suppportsAttributeOperation() const;

        /** return the attributes successully applied in applyAttributeUpdate.*/
        virtual AttributeBitMask applyAttributeOperation(AttributeFunctor& auf);

        virtual void applyPrimitiveOperation(PrimitiveFunctor&);

    protected:

        Geometry& operator = (const Geometry&) { return *this;}

        virtual ~Geometry();

        virtual const bool computeBound() const;
        
        
        
        PrimitiveList               _primitives;
        
        ref_ptr<Vec3Array>          _vertexArray;

        AttributeBinding            _normalBinding;
        ref_ptr<Vec3Array>          _normalArray;
        
        AttributeBinding            _colorBinding;
        ref_ptr<AttributeArray>     _colorArray;
        
        TexCoordArrayList           _texCoordList;

};


}

#endif
