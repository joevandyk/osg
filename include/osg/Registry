#ifndef OSG_REGISTRY
#define OSG_REGISTRY 1

#include <vector>
#include <string>

#include <osg/Referenced>
#include <osg/DynamicLibrary>

namespace osg {

// forward declare referenced classes to help avoid mutiple includes
class Object;
class Image;
class Node;
class Input;

SG_EXPORT extern Object* loadObjectFile(const char *name);
SG_EXPORT extern Image*  loadImageFile(const char *name);
SG_EXPORT extern Node*   loadNodeFile(const char *name);

SG_EXPORT extern bool saveObjectFile(Object& object, const char *name);
SG_EXPORT extern bool saveImageFile(Image& image, const char *name);
SG_EXPORT extern bool saveNodeFile(Node& node, const char *name);

/** pure virtual base class for reading and writing of non native formats. */
class SG_EXPORT ReaderWriter : public Referenced
{
    public:
        virtual ~ReaderWriter() {}
        virtual const char* className() = 0;
        virtual bool acceptsExtension(const std::string& /*extension*/) { return false; }

        virtual Object* readObject(const std::string& /*fileName*/) { return NULL; }
        virtual Image* readImage(const std::string& /*fileName*/) { return NULL; }
        virtual Node* readNode(const std::string& /*fileName*/) { return NULL; }

        virtual bool writeObject(Object& /*obj*/,const std::string& /*fileName*/) {return false; }
        virtual bool writeImage(Image& /*image*/,const std::string& /*fileName*/) {return false; }
        virtual bool writeNode(Node& /*node*/,const std::string& /*fileName*/) { return false; }
};

/**
    Registry is a singleton factory which stores
    the Objects types available at runtime for loading,
    and any Object reader or writers which are linked in
    at runtime for reading non-native file formats.

    The RegisterObjectProxy defined in Object.h can be
    used to automatically register at runtime a Object
    with the Registry.

    The RegisterReaderWriterProxy defined in ReaderWriter.h can
    be used to automatically register at runtime a reader/writer
    with the Registry.
*/
class SG_EXPORT Registry
{
    public:

        ~Registry();

        static Registry* instance();

        void addPrototype(Object* obj);
        void removePrototype(Object* obj);

        void addReaderWriter(ReaderWriter* rw);
        void removeReaderWriter(ReaderWriter* rw);

        /** create the platform specific library name associated with file.*/
        std::string createLibraryNameForFile(const std::string& fileName);

        /** create the platform specific library name associated with file extension.*/
        std::string createLibraryNameForExt(const std::string& ext);

        /** find the library in the SG_LIBRARY_PATH and load it.*/
        bool loadLibrary(const std::string& fileName);
        /** close the attached library with specified name.*/
        bool closeLibrary(const std::string& fileName);

        Object* readObject(Input& fr);
        Object* readObject(const std::string& fileName);
        bool    writeObject(Object& obj, const std::string& fileName);

        Image*  readImage(Input& fr);
        Image*  readImage(const std::string& fileName);
        bool    writeImage(Image& obj, const std::string& fileName);

        Node* readNode(Input& fr);
        Node* readNode(const std::string& fileName);
        bool  writeNode(Node& node, const std::string& fileName);
        

    private:

        typedef std::vector<ref_ptr<Object> >          PrototypeList;
        typedef std::vector<ref_ptr<ReaderWriter> >    ReaderWriterList;
        typedef std::vector<ref_ptr<DynamicLibrary> >  DynamicLibraryList;

        /** constructor is private, as its a singleton, preventing
            construction other than via the instance() method and
            therefore ensuring only one copy is ever constructed*/
        Registry();
        
        /** get the attached library with specified name.*/
        DynamicLibraryList::iterator getLibraryItr(const std::string& fileName);
        DynamicLibrary*              getLibrary(const std::string& fileName);

        PrototypeList       _protoList;
        ReaderWriterList    _rwList;
        DynamicLibraryList  _dlList;

        std::vector<int>                _nodeProtoList;
        std::vector<int>     	        _imageProtoList;

        bool _openingLibrary;

};

/**  Proxy class for automatic registration of reader/writers with the
     Registry.*/
template<class T>
class RegisterObjectProxy
{
    public:
        RegisterObjectProxy()
        {
            _obj = new T;
            _obj->ref();
            Registry::instance()->addPrototype(_obj);
        }
        ~RegisterObjectProxy()
        {
            Registry::instance()->removePrototype(_obj);
            _obj->unref();
        }
        
    protected:
        T* _obj;
};

/** Proxy class for automatic registration of reader/writers with the
    Registry.*/
template<class T>
class RegisterReaderWriterProxy
{
    public:
        RegisterReaderWriterProxy()
        {
            _rw = new T;
            _rw->ref();
            Registry::instance()->addReaderWriter(_rw);
        }

        ~RegisterReaderWriterProxy()
        {
            Registry::instance()->removeReaderWriter(_rw);
            _rw->unref();
        }
        
    protected:
        T* _rw;
};

};

#endif // __SG_OBJECT_FACTORY_H
