//C++ header - Open Scene Graph - Copyright (C) 1998-2001 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSG_OBJECT
#define OSG_OBJECT 1

#include <osg/Referenced>
#include <osg/ShallowCopy>

namespace osg {

/** META_Object macro define the standard clone, isSameKindAs and className methods.
  * Use when subclassing from Object to make it more convinient to define 
  * the standard pure virtual clone, isSameKindAs and className methods 
  * which are required for all Object subclasses.*/
#define META_Object(T) \
        virtual osg::Object* cloneType() const { return new T (); } \
        virtual osg::Object* clone(const osg::Cloner& cloner) const { return new T (*this,cloner); } \
        virtual bool isSameKindAs(const osg::Object* obj) const { return dynamic_cast<const T *>(obj)!=NULL; } \
        virtual const char* className() const { return #T; }


/** Base class/standard interface for objects which require IO support, 
    cloning and reference counting.
    Based on GOF Composite, Prototype and Template Method patterns.
*/
class SG_EXPORT Object : public Referenced
{
    public:


        /** Construct an object. Note Object is a pure virtual base class
            and therefore cannot be constructed on its own, only derived
            classes which override the clone and className methods are
            concrete classes and can be constructed.*/
        Object() {}

        /** Copy constructor, optional Cloner object can be used to control
          * shallow vs deep copying of dynamic data.*/
        Object(const Object&,const Cloner& cloner=ShallowCopy());

        /** Clone the type of an object, with Object* return type.
            Must be defined by derived classes.*/
        virtual Object* cloneType() const = 0;

        /** Clone the an object, with Object* return type.
            Must be defined by derived classes.*/
        virtual Object* clone(const Cloner&) const = 0;

        virtual bool isSameKindAs(const Object*) const { return true; }

        /** return the name of the object's class type. Must be defined
            by derived classes.*/
        virtual const char* className() const = 0;

    protected:

        /** Object destructor. Note, is protected so that Objects cannot
            be deleted other than by being dereferenced and the reference
            count being zero (see osg::Referenced), preventing the deletion
            of nodes which are still in use. This also means that
            Node's cannot be created on stack i.e Node node will not compile,
            forcing all nodes to be created on the heap i.e Node* node
            = new Node().*/
        virtual ~Object() {}

    private:

        /** disallow any copy operator.*/
        Object& operator = (const Object&) { return *this; }
};

};

#endif
