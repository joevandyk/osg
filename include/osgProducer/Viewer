/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2003 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_VIEWER_H
#define OSG_VIEWER_H

#include <osg/Timer>
#include <osg/NodeVisitor>
#include <osg/ArgumentParser>
#include <osg/ApplicationUsage>
#include <osg/AnimationPath>

#include <osgGA/GUIActionAdapter>
#include <osgGA/GUIEventHandler>
#include <osgGA/KeySwitchCameraManipulator>

#include <osgProducer/OsgCameraGroup>
#include <osgProducer/KeyboardMouseCallback>

#include <list>

namespace osgProducer {

class OSGPRODUCER_EXPORT Viewer : public OsgCameraGroup, public osgGA::GUIActionAdapter
{
    public :

        Viewer();

        Viewer(Producer::CameraConfig *cfg);

        Viewer(const std::string& configFile);

        Viewer(osg::ArgumentParser& arguments);

        virtual ~Viewer() {}


        enum ViewerOptions
        {
            NO_EVENT_HANDLERS       = 0,
            TRACKBALL_MANIPULATOR   = 1,
            DRIVE_MANIPULATOR       = 2,
            FLIGHT_MANIPULATOR      = 4,
            STATE_MANIPULATOR       = 8,
            HEAD_LIGHT_SOURCE       = 16,
            SKY_LIGHT_SOURCE        = 32,
            STATS_MANIPULATOR       = 64,
            VIEWER_MANIPULATOR      = 128,
            ESCAPE_SETS_DONE        = 256,
            STANDARD_SETTINGS = TRACKBALL_MANIPULATOR|
                                DRIVE_MANIPULATOR |
                                FLIGHT_MANIPULATOR |
                                STATE_MANIPULATOR |
                                HEAD_LIGHT_SOURCE |
                                STATS_MANIPULATOR |
                                VIEWER_MANIPULATOR |
                                ESCAPE_SETS_DONE
        };
        
        void setUpViewer(unsigned int options=STANDARD_SETTINGS);
        
        /** return true if the application is done and should exit.*/
        virtual bool done() const;

        /** Override the Producer::CameraGroup::setViewByMatrix to catch all changes to view.*/
        virtual void setViewByMatrix( const Producer::Matrix & pm);

        /** Set the threading model and then call realize().*/
        virtual bool realize(ThreadingModel thread_model);

        virtual bool realize();

        virtual void sync();

        virtual void update();

        /** Dispatch the cull and draw for each of the Camera's for this frame.*/
        virtual void frame();

        virtual void requestRedraw() {}
        virtual void requestContinuousUpdate(bool) {}
        virtual void requestWarpPointer(float x,float y);

        Producer::KeyboardMouse* getKeyboardMouse() { return _kbmcb==0?0:_kbmcb->getKeyboardMouse(); }

        const Producer::KeyboardMouse* getKeyboardMouse() const { return _kbmcb==0?0:_kbmcb->getKeyboardMouse(); }
        
        KeyboardMouseCallback* getKeyboardMouseCallback() { return _kbmcb; }

        const KeyboardMouseCallback* getKeyboardMouseCallback() const { return _kbmcb; }


        typedef std::list< osg::ref_ptr<osgGA::GUIEventHandler> > EventHandlerList;
        EventHandlerList& getEventHandlerList() { return _eventHandlerList; }
        const EventHandlerList& getEventHandlerList() const { return _eventHandlerList; }
        
        osgGA::KeySwitchCameraManipulator* getKeySwitchCameraManipulator() { return _keyswitchManipulator.get(); }
        const osgGA::KeySwitchCameraManipulator* getKeySwitchCameraManipulator() const { return _keyswitchManipulator.get(); }

        unsigned int addCameraManipulator(osgGA::CameraManipulator* cm);
        void selectCameraManipulator(unsigned int no);


        void setRecordingAnimationPath(bool on) { _recordingAnimationPath = on; }
        bool getRecordingAnimationPath() const { return _recordingAnimationPath; }

        void setAnimationPath(osg::AnimationPath* path) { _animationPath = path; }
        osg::AnimationPath* getAnimationPath() { return _animationPath.get(); }
        const osg::AnimationPath* getAnimationPath() const { return _animationPath.get(); }


        /** Get the keyboard and mouse usage of this viewer.*/
        virtual void getUsage(osg::ApplicationUsage& usage) const;

    protected :


        bool            _done;

        unsigned int    _frameNumber;
        osg::Timer      _timer;
        osg::Timer_t    _start_tick;
        
        osgProducer::KeyboardMouseCallback* _kbmcb;

        EventHandlerList _eventHandlerList;
        osg::ref_ptr<osgGA::KeySwitchCameraManipulator> _keyswitchManipulator;

        osg::ref_ptr<osg::Camera> _old_style_osg_camera;
        
        osg::ref_ptr<osg::NodeVisitor> _updateVisitor;


        bool                                _recordingAnimationPath;
        osg::ref_ptr<osg::AnimationPath>    _animationPath;

};

}

#endif
