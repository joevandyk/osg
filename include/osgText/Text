//C++ header - Open Scene Graph - Copyright (C) 1998-2001 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

/* --------------------------------------------------------------------------
 *
 *    openscenegraph textLib / FTGL wrapper
 *
 * --------------------------------------------------------------------------
 *    
 *    prog:    max rheiner;mrn@paus.ch
 *    date:    4/25/2001    (m/d/y)
 *
 * --------------------------------------------------------------------------
 *
 * --------------------------------------------------------------------------
 */


#ifndef OSGTEXT_TEXT
#define OSGTEXT_TEXT 1 

#include <string>

#include <osg/GL>
#include <osg/Object>
#include <osg/Drawable>
#include <osg/Vec3>
#include <osg/Vec2>

// http://homepages.paradise.net.nz/henryj/code/

#include <osgText/Export>

class FTFont;

namespace osgText {

///////////////////////////////////////////////////////////////////////////////
// Font    - FontBaseClass
class OSGTEXT_EXPORT Font : public osg::Object
{
public:

    Font();


    virtual bool open(const std::string& font);
    
    virtual bool create(int  pointSize, const unsigned int res = 72 );
    virtual bool create();
    virtual void output(const char* text);

    virtual bool isOk(void) const { return _init; }
    virtual bool isCreated(void) const { return isOk() && _created; }

    virtual float getWidth(const char* text) const;
    virtual int getHeight() const;
    virtual int getDescender() const;
    virtual int getAscender() const;

    int        getPointSize(void) const    { return _pointSize; }
    const std::string& getFontName();

    FTFont*     getFont(void) { return _font; }

protected:

    virtual    ~Font();

    virtual void    clear();

    virtual FTFont* createFontObj(void)=0;

    bool init(const std::string& font);

    bool            _init;
    bool            _created;

    FTFont*            _font;
    std::string        _fontName;
    int                _pointSize;
    int                _res;
};
// Font
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// RasterFont
class OSGTEXT_EXPORT RasterFont:public Font
{
public:
    RasterFont():Font(){;}
    RasterFont(const std::string& font):Font(){;}

protected:

};

// RasterFont
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// VectorFont
class OSGTEXT_EXPORT VectorFont:public Font
{
public:
    VectorFont():Font(){;}
    VectorFont(const std::string& font):Font(){;}

protected:
    double    _precision;
};

// VectorFont
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// BitmapFont
class OSGTEXT_EXPORT BitmapFont:public RasterFont
{
public:


    BitmapFont() {;}
    
    BitmapFont(const std::string&    font, 
               int                    point_size);
    
    META_Object(BitmapFont);

protected:


    virtual FTFont* createFontObj(void);
};

// BitmapFont
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// PixmapFont
class OSGTEXT_EXPORT PixmapFont:public RasterFont
{
public:

    PixmapFont() {;}
    
    PixmapFont(const std::string&    font, 
               int                    point_size);
    
    META_Object(PixmapFont);

protected:

    virtual FTFont* createFontObj(void);

};
// PixmapFont
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// TextureFont

class OSGTEXT_EXPORT TextureFont:public RasterFont
{
public:

    TextureFont() {;}
    
    TextureFont(const std::string&    font, 
               int                    point_size);
    
    META_Object(TextureFont);

protected:

    virtual FTFont* createFontObj(void);

};
// PixmapFont
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// OutlineFont
class OSGTEXT_EXPORT OutlineFont:public VectorFont
{
public:

    OutlineFont() {;}
    
    OutlineFont(const std::string&    font, 
                int                    point_size,
                double                precision);
    
    META_Object(OutlineFont);

protected:

    virtual FTFont* createFontObj(void);


};
// OutlineFont
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// PolygonFont
class OSGTEXT_EXPORT PolygonFont:public VectorFont
{
public:

    PolygonFont() {;}
    
    PolygonFont(const std::string&    font, 
                int                    point_size,
                double                precision);
    
    META_Object(PolygonFont);

protected:

    virtual FTFont* createFontObj(void);

};
// PolygonFont
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Text
class OSGTEXT_EXPORT Text:public osg::Drawable    
{
public:

    enum AlignmentType
    {    // from left to right, top to bottom
        LEFT_TOP,
        LEFT_CENTER,
        LEFT_BOTTOM,

        CENTER_TOP,
        CENTER_CENTER,
        CENTER_BOTTOM,

        RIGHT_TOP,
        RIGHT_CENTER,
        RIGHT_BOTTOM,
    };

    enum BoundingBoxType
    {
        GEOMETRY,
        GLYPH,
    };

    enum DrawModeType
    {    // from left to right, top to bottom
        TEXT            =    1<<0,
        BOUNDINGBOX        =    1<<1,
        ALIGNEMENT        =    1<<2,
        DEFAULT            =    TEXT,
    };

    Text();
    Text(Font* font);

    META_Object(Text);

    void setPosition(const osg::Vec2& pos);
    void setPosition(const osg::Vec3& pos);
    const osg::Vec3& getPosition() const { return _pos; }

    void setDrawMode(int mode) { _drawMode=mode; }
    int getDrawMode() const { return _drawMode; }

    void setBoundingBox(int mode);
    int getBoundingBox() const { return _boundingBoxType; }

    void setAlignement(int alignement);
    int getAlignement() const { return _alignement; }

    void setFont(Font* font);
    Font* getFont() { return _font.get(); }
    const Font* getFont() const { return _font.get(); }

    void setText(const char* text)    { _text=text; }
    void setText(const std::string& text) { _text=text; }
    const std::string& getText() const { return _text; }

    virtual void drawImmediateMode(osg::State& state);
    virtual void drawBoundingBox(void);
    virtual void drawAlignement(void);
    
    const osg::Vec3& getAlignementPos() const { return _alignementPos; };

    
protected:

    enum FontType
    {
        UNDEF,
        BITMAP,
        PIXMAP,
        OUTLINE,
        POLYGON,
        TEXTURE,
    };
   
    virtual    ~Text();

    virtual void        setDefaults(void);
    virtual const bool  computeBound(void) const;
    virtual void        calcBounds(osg::Vec3* min,osg::Vec3* max) const;
    void                initAlignement(osg::Vec3* min,osg::Vec3* max);
    bool                initAlignement(void);

    osg::ref_ptr<Font>  _font;

    bool                _init;
    bool                _initAlignement;
    std::string         _text;
    int                 _fontType;
    int                 _alignement;
    int                 _drawMode;
    int                 _boundingBoxType;
    
    osg::Vec3        _pos;
    osg::Vec3        _alignementPos;
};
// Text
///////////////////////////////////////////////////////////////////////////////

};

#endif // _OSG_TEXT_H
