#ifndef OSGGLUT_VIEWER
#define OSGGLUT_VIEWER 1

#include <osg/OSG>
#include <osg/GeoState>
#include <osg/Scene>
#include <osg/Light>
#include <osg/DCS>
#include <osg/GL>
#include <osg/NodeVisitor>
#include <osg/Geode>
#include <osg/Timer>

#include <osgUtil/GUIEventAdapter>
#include <osgUtil/CameraManipulator>
#include <osgUtil/SceneView>

#include <osgGLUT/Export>

#ifdef SGV_USE_RTFS
#include <rtfs/rtfs.h>
#endif

#include <string>

#ifdef OSG_USE_IO_DOT_H
#include <iostream.h>
#else
#include <iostream>
using namespace std;
#endif

namespace osgGLUT{

/** A basic viewer base class which provides a window, simple keyboard and mouse interaction.
  * Please note, this viewer class has been developed via a rather haphazzard
  * path and *needs* a total rewrite.  It currently surfices for osg demo's
  * but shouldn't be viewed as the be all or end of osg viewer classes.
  * Someone please rewrite it :-)
  */
class OSGGLUT_EXPORT Viewer : public osgUtil::GUIActionAdapter
{
    public:

        Viewer();
        virtual ~Viewer();

        virtual bool init( osg::Node* );

        virtual bool run();

        // called on each frame redraw..
        virtual bool update();
        virtual bool traverse();
        virtual bool draw();

        // initialize the clock.
        long initClock();
        // time since initClock() in seconds.
        float clockSeconds() { return _timer.delta_s(_initialTick,clockTick()); }

        // update the number of ticks since the last frame update.
        osg::Timer_t updateFrameTick();
        
        // time from the current frame update and the previous one in seconds.
        float frameSeconds() { return _timer.delta_s(_lastFrameTick,_frameTick); }
        float frameRate() { return 1.0f/frameSeconds(); }

        void help(ostream& fout);

        // hande multiple camera.
        void registerCameraManipulator(osgUtil::CameraManipulator* cm);
        void selectCameraManipulator(unsigned int pos);

        // derived from osgUtil::GUIActionAdapter
        virtual void needRedraw(bool /*needed*/) {} // redraw always done.
        virtual void needContinuousUpdate(bool /*needed*/) {} // continous update always
        virtual void needWarpPointer(int x,int y);

    protected:

        static void displayCB();
        static void reshapeCB(GLint w, GLint h);
        static void visibilityCB(int state);
        static void mouseMotionCB(int x, int y);
        static void mousePassiveMotionCB(int x, int y);
        static void mouseCB(int button, int state, int x, int y);
        static void keyboardCB(unsigned char key, int x, int y );

        virtual void display();
        virtual void reshape(GLint w, GLint h);
        virtual void visibility(int state);
        virtual void mouseMotion(int x, int y);
        virtual void mousePassiveMotion(int x, int y);
        virtual void mouse(int button, int state, int x, int y);
        virtual void keyboard(unsigned char key, int x, int y);
        

        static Viewer*    s_theViewer;

        osg::ref_ptr<osgUtil::SceneView> _sceneView;
                
        typedef std::vector<osg::ref_ptr<osgUtil::CameraManipulator> > CameraManipList;

        osg::ref_ptr<osgUtil::CameraManipulator>    _cameraManipulator;
        CameraManipList                             _cameraManipList;

        std::string                                 _saveFileName;

        int ww, wh;

        #ifdef SGV_USE_RTFS
	unsigned int frame_rate;
	RTfs *fs;
	#endif
        
        bool _viewFrustumCullingActive;
        bool _smallFeatureCullingActive;

        int mx, my, mbutton;
        int polymode;
        int texture;
        int backface;
        int lighting;
        int flat_shade;
        int _two_sided_lighting;
        bool fullscreen;
        int _saved_ww,_saved_wh;
        bool _printStats;
        bool _useDisplayLists;
        
        osg::Timer   _timer;
        osg::Timer_t _tickRatePerSecond;
        osg::Timer_t _initialTick;
        osg::Timer_t _lastFrameTick;
        osg::Timer_t _frameTick;

        // system tick.
        osg::Timer_t clockTick();
        osg::Timer_t frameTick();


};

}

#endif                           // SG_VIEWIER_H
