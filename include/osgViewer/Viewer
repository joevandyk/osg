/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGVIEWER_Viewer
#define OSGVIEWER_Viewer 1

#include <osg/ArgumentParser>
#include <osgGA/EventVisitor>
#include <osgUtil/UpdateVisitor>
#include <osgViewer/GraphicsWindow>
#include <osgViewer/View>


namespace osgViewer {

/** Viewer holds a single view on to a single scene.*/
class OSGVIEWER_EXPORT Viewer : public ViewerBase, public osgViewer::View
{
    public:

        Viewer();

        Viewer(osg::ArgumentParser& arguments);

        Viewer(const osgViewer::Viewer& viewer, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);

        virtual ~Viewer();
        
        META_Object(osgViewer,Viewer);

        /** Take all the settings, Camera and Slaves from the passed in view(er), leaving it empty. */
        virtual void take(View& rhs);

        /** read the viewer configuration from a configuration file.*/
        virtual bool readConfiguration(const std::string& filename);
        
        /** Get whether at least of one of this viewers windows are realized.*/
        virtual bool isRealized() const;

        /** set up windows and associated threads.*/
        virtual void realize();

        virtual void setStartTick(osg::Timer_t tick);
        void setReferenceTime(double time=0.0);

        /** Set the sene graph data that viewer with view.*/
        virtual void setSceneData(osg::Node* node);


        /** Convenience method for setting up the viewer so it can be used embedded in an external managed window.
          * Returns the GraphicsWindowEmbedded that can be used by applications to pass in events to the viewer. */
        virtual GraphicsWindowEmbedded* setUpViewerAsEmbeddedInWindow(int x, int y, int width, int height);

        /** Set the threading model the rendering traversals will use.*/
        virtual void setThreadingModel(ThreadingModel threadingModel);
        

        /** Let the viewer suggest the best threading model for the viewers camera/window setup and the hardware available.*/
        ThreadingModel suggestBestThreadingModel();

        enum BarrierPosition
        {
            BeforeSwapBuffers,
            AfterSwapBuffers
        };
        
        /** Set the position of the end barrier.
          * AfterSwapBuffers will may result is slightly higher framerates, by may
          * lead to inconcistent swapping between different windows.
          * BeforeSwapBuffers may lead to slightly lower framerate, but improve consistency in timing of swap buffers,
          * especially important if you are likely to consistently break frame.*/
        void setEndBarrierPosition(BarrierPosition bp);

        /** Get the end barrier position.*/
        BarrierPosition getEndBarrierPosition() const { return _endBarrierPosition; }


        /** Execute a main frame loop.
          * Equivialant to while (!viewer.done()) viewer.frame();
          * Also calls realize() if the viewer is not already realized,
          * and installs trackball manipulator if one is not already assigned.
          */
        virtual int run();

        /** Render a complete new frame.
          * Calls advance(), eventTraversal(), updateTraversal(), renderingTraversals(). */
        virtual void frame(double simulationTime=USE_REFERENCE_TIME);

        virtual void advance(double simulationTime=USE_REFERENCE_TIME);

        virtual void eventTraversal();

        virtual void updateTraversal();
        
        virtual void renderingTraversals();
        
        void setCameraWithFocus(osg::Camera* camera) { _cameraWithFocus = camera; }
        osg::Camera* getCameraWithFocus() { return _cameraWithFocus.get(); }
        const osg::Camera* getCameraWithFocus() const { return _cameraWithFocus.get(); }
        
        virtual void getCameras(Cameras& cameras, bool onlyActive=true);
        
        virtual void getContexts(Contexts& contexts, bool onlyValid=true);

        virtual void getWindows(Windows& windows, bool onlyValid=true);

        virtual void getAllThreads(Threads& threads, bool onlyActive=true);

        virtual void getOperationThreads(OperationThreads& threads, bool onlyActive=true);

        virtual void getScenes(Scenes& scenes, bool onlyValid=true);

        virtual void getViews(Views& views, bool onlyValid=true);


        /** Set up the threading and processor affinity as per the viewers threading model.*/
        virtual void setUpThreading();      

        /** Stop any threads begin run by viewer.*/
        virtual void stopThreading();

        /** Start any threads required by the viewer.*/
        virtual void startThreading();        

        /** Get the keyboard and mouse usage of this viewer.*/
        virtual void getUsage(osg::ApplicationUsage& usage) const;



    protected:
    
        void constructorInit();
    
        void checkWindowStatus();
        
        inline void makeCurrent(osg::GraphicsContext* gc)
        {
            if (_currentContext==gc) return;
            
            releaseContext();
            
            if (gc && gc->valid() && gc->makeCurrent()) _currentContext = gc;
        }
        
        inline void releaseContext()
        {
            if (_currentContext.valid() && _currentContext->valid())
            {
                _currentContext->releaseContext();
            }
            _currentContext = 0;
        }
        
        
        bool            _firstFrame;
        
        BarrierPosition _endBarrierPosition;

        osg::ref_ptr<osg::BarrierOperation>         _startRenderingBarrier;
        osg::ref_ptr<osg::BarrierOperation>         _endRenderingDispatchBarrier;
        osg::ref_ptr<osg::EndOfDynamicDrawBlock>    _endDynamicDrawBlock;

        unsigned int                                _numWindowsOpenAtLastSetUpThreading;
        
        osg::observer_ptr<osg::Camera>              _cameraWithFocus;
        

        osg::observer_ptr<osg::GraphicsContext>     _currentContext;
};


}

#endif
