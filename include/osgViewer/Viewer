/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGVIEWER_Viewer
#define OSGVIEWER_Viewer 1

#include <osgViewer/GraphicsWindow>
#include <osgViewer/View>

namespace osgViewer {

// WARNING ** Under development do not use, yet :-) 

/** Viewer holds a single view on to a single scene..*/
class OSGVIEWER_EXPORT Viewer : public osgViewer::View
{
    public:

        Viewer();
        virtual ~Viewer();
        
        /** set up windows and associated threads.*/
        void realize();

        void setDone(bool done) { _done = done; }
        
        bool done() { return _done; }
        
        enum ThreadingModel
        {
            SingleThreaded,
            ThreadPerContext,
            ThreadPerCamera
        };
        
        /** Set the threading model the rendering traversals will use.*/
        void setThreadingModel(ThreadingModel threadingModel);
        
        /** Get the threading model the rendering traversals will use.*/
        ThreadingModel getThreadingModel() const { return _threadingModel; }

        /** Set the key value that the viewer checks on each frame to see if the viewer's done flag should be set to
          * signal end of viewers main loop.
          * Default value is Escape (osgGA::GUIEVentAdapter::KEY_Escape).
          * Setting to 0 switches off the feature.*/
        void setKeySetsDone(int key) { _keySetsDone = key; }

        /** Set the key value that the viewer checks on each frame to see if the viewer's done flag.*/
        int getKeySetsDone() const { return _keySetsDone; }

        /** Render a complete new frame.
          * Calls frameAdvance(), frameEventTraversal(), frameUpateTraversal(), frameRenderingTraversals(). */
        virtual void frame();

        virtual void frameAdvance();

        virtual void frameEventTraversal();

        virtual void frameUpdateTraversal();
        
        virtual void frameRenderingTraversals();

        /** Release all OpenGL objects associated with this viewer's scenegraph. Note, does not deleted the actual OpenGL objects, it just releases them to the pending GL object delete lists which will need flushing once a valid graphics context is obtained.*/ 
        virtual void releaseAllGLObjects();

        /** Clean up all OpenGL objects associated with this viewer's scenegraph.*/ 
        virtual void cleanup();
        
        void setCameraWithFocus(osg::Camera* camera) { _cameraWithFocus = camera; }
        osg::Camera* getCameraWithFocus() { return _cameraWithFocus.get(); }
        const osg::Camera* getCameraWithFocus() const { return _cameraWithFocus.get(); }
        
        typedef std::vector<osg::GraphicsContext*> Contexts;
        void getContexts(Contexts& contexts, bool onlyValid=true);
        
        typedef std::vector<osgViewer::GraphicsWindow*> Windows;
        void getWindows(Windows& windows, bool onlyValid=true);

    protected:
    
        void init();
        
        void stopThreading();
        void startThreading();        
        void checkWindowStatus();
        
        bool _firstFrame;
        
        bool _done;
        int _keySetsDone;
        
        ThreadingModel _threadingModel;
       
        osg::ref_ptr<osg::BarrierOperation> _startRenderingBarrier;
        osg::ref_ptr<osg::BarrierOperation> _endRenderingDispatchBarrier;

        unsigned int computeNumberOfThreadsIncludingMainRequired();

        unsigned int _numThreadsOnBarrier;
        
        osg::observer_ptr<osg::Camera> _cameraWithFocus;

};


}

#endif
