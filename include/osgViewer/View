/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGVIEWER_VIEW
#define OSGVIEWER_VIEW 1

#include <osg/View>

#include <osgUtil/PolytopeIntersector>
#include <osgUtil/LineSegmentIntersector>
#include <osgUtil/UpdateVisitor>
#include <osgUtil/SceneView>

#include <osgGA/MatrixManipulator>
#include <osgGA/EventVisitor>
#include <osgGA/EventQueue>

#include <osgViewer/Scene>
#include <osgViewer/GraphicsWindow>

namespace osgViewer {

#define USE_REFERENCE_TIME DBL_MAX

/** ViewerBase is the view base class that is inhertied by both Viewer and CompositeViewer.*/
class OSGVIEWER_EXPORT ViewerBase : public virtual osg::Object
{
    public:
    
        ViewerBase();
        ViewerBase(const ViewerBase& vb);
            
            
         /** read the viewer configuration from a configuration file.*/
        virtual bool readConfiguration(const std::string& filename) = 0;
        
        /** Get whether at least of one of this viewers windows are realized.*/
        virtual bool isRealized() const = 0;

        /** set up windows and associated threads.*/
        virtual void realize() = 0;

        enum ThreadingModel
        {
            SingleThreaded,
            CullDrawThreadPerContext,
            ThreadPerContext = CullDrawThreadPerContext,
            DrawThreadPerContext,
            CullThreadPerCameraDrawThreadPerContext,
            ThreadPerCamera = CullThreadPerCameraDrawThreadPerContext,
            AutomaticSelection
        };

        /** Set the threading model the rendering traversals will use.*/
        virtual void setThreadingModel(ThreadingModel threadingModel) = 0;
        
        /** Get the threading model the rendering traversals will use.*/
        ThreadingModel getThreadingModel() const { return _threadingModel; }
        
 
        /** Set the done flag to singnal the viewer's work is done and should exit the frame loop.*/
        void setDone(bool done) { _done = done; }

        /** Reurn true if  viewer's work is done and should exit the frame loop.*/
        bool done() const { return _done; }

        /** Set the EventVisitor. */
        void setEventVisitor(osgGA::EventVisitor* eventVisitor) { _eventVisitor = eventVisitor; }

        /** Get the EventVisitor. */
        osgGA::EventVisitor* getEventVisitor() { return _eventVisitor.get(); }

        /** Get the const EventVisitor. */
        const osgGA::EventVisitor* getEventVisitor() const { return _eventVisitor.get(); }

        /** Set the key event that the viewer checks on each frame to see if the viewer's done flag should be set to
          * signal end of viewers main loop.
          * Default value is Escape (osgGA::GUIEVentAdapter::KEY_Escape).
          * Setting to 0 switches off the feature.*/
        void setKeyEventSetsDone(int key) { _keyEventSetsDone = key; }

        /** get the key event that the viewer checks on each frame to see if the viewer's done flag.*/
        int getKeyEventSetsDone() const { return _keyEventSetsDone; }
        
        /** if the flag is true, the viewer set its done flag when a QUIT_APPLICATION is received, false disables this feature */
        void setQuitEventSetsDone(bool flag) { _quitEventSetsDone = flag; }
        
        /** @return true if the viewer respond to the QUIT_APPLICATION-event */
        bool getQuitEventSetsDone() const { return _quitEventSetsDone; }



        /** Set the UpdateVisitor. */
        void setUpdateVisitor(osgUtil::UpdateVisitor* updateVisitor) { _updateVisitor = updateVisitor; }

        /** Get the UpdateVisitor. */
        osgUtil::UpdateVisitor* getUpdateVisitor() { return _updateVisitor.get(); }

        /** Get the const UpdateVisitor. */
        const osgUtil::UpdateVisitor* getUpdateVisitor() const { return _updateVisitor.get(); }


        /** Set the Update OperationQueue. */
        void setUpdateOperations(osg::OperationQueue* operations) { _updateOperations = operations; }

        /** Get the Update OperationQueue. */
        osg::OperationQueue* getUpdateOperations() { return _updateOperations.get(); }
        
        /** Get the const Update OperationQueue. */
        const osg::OperationQueue* getUpdateOperations() const { return _updateOperations.get(); }
        
        /** Add an update operation.*/
        void addUpdateOperation(osg::Operation* operation);

        /** Remove an update operation.*/
        void removeUpdateOperation(osg::Operation* operation);


        /** Execute a main frame loop.
          * Equivialant to while (!viewer.done()) viewer.frame();
          * Also calls realize() if the viewer is not already realized,
          * and installs trackball manipulator if one is not already assigned.
          */
        virtual int run() = 0;

        /** Render a complete new frame.
          * Calls advance(), eventTraversal(), updateTraversal(), renderingTraversals(). */
        virtual void frame(double simulationTime=USE_REFERENCE_TIME) = 0;

        virtual void advance(double simulationTime=USE_REFERENCE_TIME) = 0;

        virtual void eventTraversal() = 0;

        virtual void updateTraversal() = 0;
        
        virtual void renderingTraversals() = 0;

        typedef std::vector<osg::Camera*> Cameras;
        virtual void getCameras(Cameras& cameras, bool onlyActive=true) = 0;

        typedef std::vector<osg::GraphicsContext*> Contexts;
        virtual void getContexts(Contexts& contexts, bool onlyValid=true) = 0;

        typedef std::vector<osgViewer::GraphicsWindow*> Windows;
        virtual void getWindows(Windows& windows, bool onlyValid=true) = 0;

        typedef std::vector<OpenThreads::Thread*> Threads;
        virtual void getAllThreads(Threads& threads, bool onlyActive=true) = 0;

        typedef std::vector<osg::OperationThread*> OperationThreads;
        virtual void getOperationThreads(OperationThreads& threads, bool onlyActive=true) = 0;

        typedef std::vector<osgViewer::Scene*> Scenes;
        virtual void getScenes(Scenes& scenes, bool onlyValid=true) = 0;

        /** Set the graphics operation to call on realization of the viewers graphics windows.*/
        void setRealizeOperation(osg::Operation* op) { _realizeOperation = op; }

        /** Get the graphics operation to call on realization of the viewers graphics windows.*/
        osg::Operation* getRealizeOperation() { return _realizeOperation.get(); }

        /** Set up the threading and processor affinity as per the viewers threading model.*/
        virtual void setUpThreading() = 0;

        /** Return true if viewer threads are running. */
        bool areThreadsRunning() const { return _threadsRunning; }

        /** Stop any threads begin run by viewer.*/
        virtual void stopThreading() = 0;

        /** Start any threads required by the viewer.*/
        virtual void startThreading() = 0;        

        /** Get the keyboard and mouse usage of this viewer.*/
        virtual void getUsage(osg::ApplicationUsage& usage) const = 0;

    protected:
    
        bool                                        _done;
        int                                         _keyEventSetsDone;
        bool                                        _quitEventSetsDone;
        
        ThreadingModel                              _threadingModel;
        bool                                        _threadsRunning;
        
        osg::ref_ptr<osgGA::EventVisitor>           _eventVisitor;
        
        osg::ref_ptr<osg::OperationQueue>           _updateOperations;
        osg::ref_ptr<osgUtil::UpdateVisitor>        _updateVisitor;
        
        osg::ref_ptr<osg::Operation>                _realizeOperation;

};

/** View holds a single view on a scene, this view may be composed of one or more slave cameras.*/
class OSGVIEWER_EXPORT View : public osg::View, public osgGA::GUIActionAdapter
{
    public:

        View();

        View(const osgViewer::View& view, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);

        META_Object(osgViewer,View);
        
        ViewerBase* getViewerBase() { return _viewerBase.get(); }

        /** Take all the settings, Camera and Slaves from the passed in view, leaving it empty. */
        virtual void take(osg::View& rhs);

        virtual void setStartTick(osg::Timer_t tick);
        osg::Timer_t getStartTick() const { return _startTick; }

        void setFrameStamp(osg::FrameStamp* fs) { _frameStamp = fs; }
        osg::FrameStamp* getFrameStamp() { return _frameStamp.get(); }
        const osg::FrameStamp* getFrameStamp() const { return _frameStamp.get(); }

        Scene* getScene() { return _scene.get(); }
        const Scene* getScene() const { return _scene.get(); }

        /** Set the scene graph that the View will use.*/
        virtual void setSceneData(osg::Node* node);

        /** Get the View's scene graph.*/
        osg::Node* getSceneData() { return _scene.valid() ? _scene->getSceneData() : 0; }

        /** Get the const View's scene graph.*/
        const osg::Node* getSceneData() const { return _scene.valid() ? _scene->getSceneData() : 0; }

        /** Set the View's database pager.*/
        void setDatabasePager(osgDB::DatabasePager* dp);

        /** Get the View's database pager.*/
        osgDB::DatabasePager* getDatabasePager();

        /** Get the const View's database pager.*/
        const osgDB::DatabasePager* getDatabasePager() const;

        /* Set the EventQueue that View uses to intregrate external non window related events.*/
        void setEventQueue(osgGA::EventQueue* eventQueue) { _eventQueue = eventQueue; }

        /* Get the View's EventQueue.*/
        osgGA::EventQueue* getEventQueue() { return _eventQueue.get(); }

        /* Get the const View's EventQueue.*/
        const osgGA::EventQueue* getEventQueue() const { return _eventQueue.get(); }

        /** Set the CameraManipulator that moves the View's master Camera position in response to events.*/
        void setCameraManipulator(osgGA::MatrixManipulator* manipulator);

        /** Get the View's CameraManipulator.*/
        osgGA::MatrixManipulator* getCameraManipulator() { return _cameraManipulator.get(); }

        /** Get the const View's CameraManipulator.*/
        const osgGA::MatrixManipulator* getCameraManipulator() const { return _cameraManipulator.get(); }

        /** Set the view to the CameraManipulator's home position, if non is attached home() is does nothing.
          * Note, to set the home position use getCamaraManipulator()->setHomePosition(...). */
        void home();
        

        typedef std::list< osg::ref_ptr<osgGA::GUIEventHandler> > EventHandlers;
        
        /** Add an EventHandler that adds handling of events to the View.*/
        void addEventHandler(osgGA::GUIEventHandler* eventHandler);

        /** Get the View's list of EventHandlers.*/
        EventHandlers& getEventHandlers() { return _eventHandlers; }

        /** Get the const View's list of EventHandlers.*/
        const EventHandlers& getEventHandlers() const { return _eventHandlers; }
        

        /** Set the NodePath to any active CoordinateSystemNode present in the Scene.
          * The CoordinateSystemNode path is used to help applications and CamaraManipualtors handle geocentric coordinates systems,
          * such as known which way is the local up at any position on the a whole earth. */
        void setCoordinateSystemNodePath(const osg::NodePath& nodePath);

        /** Get the NodePath to any active CoordinateSystemNode present in the Scene.*/
        osg::NodePath getCoordinateSystemNodePath() const;

        /** Compute the NodePath to any active CoordinateSystemNode present in the Scene.*/
        void computeActiveCoordinateSystemNodePath();

        
        /** Set the DisplaySettings object associated with this view.*/
        void setDisplaySettings(osg::DisplaySettings* ds) { _displaySettings = ds; }
        
        /** Set the DisplaySettings object associated with this view.*/
        osg::DisplaySettings* getDisplaySettings() { return _displaySettings.get(); }
        
        /** Set the DisplaySettings object associated with this view.*/
        const osg::DisplaySettings* getDisplaySettings() const { return _displaySettings.get(); }

        /** Set the FusionDistanceMode and Value. Note, is used only when working in stereo.*/
        void setFusionDistance(osgUtil::SceneView::FusionDistanceMode mode,float value=1.0f)
        {
            _fusionDistanceMode = mode;
            _fusionDistanceValue = value;
        }

        /** Get the FusionDistanceMode.*/
        osgUtil::SceneView::FusionDistanceMode getFusionDistanceMode() const { return _fusionDistanceMode; }

        /** Get the FusionDistanceValue. Note, only used for USE_FUSION_DISTANCE_VALUE & PROPORTIONAL_TO_SCREEN_DISTANCE modes.*/
        float getFusionDistanceValue() const { return _fusionDistanceValue; }

        
        /** Convinience method for creating slave Cameras and associated GraphicsWindows across all screens.*/
        void setUpViewAcrossAllScreens();

        /** Convinience method for a single Camara on a single window.*/
        void setUpViewInWindow(int x, int y, int width, int height, unsigned int screenNum=0);

        /** Convinience method for a single Camara associated with a single full screen GraphicsWindow.*/
        void setUpViewOnSingleScreen(unsigned int screenNum=0);
        

        /** Convinience method for spherical display using 6 slave cameras rendering the 6 sides of a cube map, and 7th camera doing distortion correction to present on a spherical display.*/
        void setUpViewFor3DSphericalDisplay(double radius=1.0, double collar=0.45, unsigned int screenNum=0, osg::Image* intensityMap=0);

        /** Convinience method for spherical display by rendering main scene to as panoramic 2:1 texture and then doing distortion correction to present onto a spherical display.*/
        void setUpViewForPanoramicSphericalDisplay(double radius=1.0, double collar=0.45, unsigned int screenNum=0, osg::Image* intensityMap=0);

        
        /** Return true if this view contains a specified camera.*/
        bool containsCamera(const osg::Camera* camera) const;
        
        /** Get the camera which contains the pointer position x,y specified master cameras window/eye coords.
          * Also passes back the local window coords for the graphics context associated with the camera passed back. */
        const osg::Camera* getCameraContainingPosition(float x, float y, float& local_x, float& local_y) const;
        
        /** Compute intersections between a ray through the specified master cameras window/eye coords and a specified node.
          * Note, when a master cameras has slaves and no viewport itself its coordinate frame will be in clip space i.e. -1,-1 to 1,1,
          * while if its has a viewport the coordintates will be relative to its viewport dimensions. 
          * Mouse events handled by the view will automatically be attached into the master camera window/clip coords so can be passed
          * directly on to the computeIntersections method. */
        bool computeIntersections(float x,float y, osgUtil::LineSegmentIntersector::Intersections& intersections,osg::Node::NodeMask traversalMask = 0xffffffff);
        
        /** Compute intersections between a ray through the specified master cameras window/eye coords and a specified nodePath's subgraph. */
        bool computeIntersections(float x,float y, osg::NodePath& nodePath, osgUtil::LineSegmentIntersector::Intersections& intersections,osg::Node::NodeMask traversalMask = 0xffffffff);
        
        
        virtual void requestRedraw();
        virtual void requestContinuousUpdate(bool needed=true);
        virtual void requestWarpPointer(float x,float y);
        
    public:
        
        void assignSceneDataToCameras();
        void init();

    protected:
    
        friend class CompositeViewer;
    
        virtual ~View();

        virtual osg::GraphicsOperation* createRenderer(osg::Camera* camera);

        osg::observer_ptr<ViewerBase>          _viewerBase;


        osg::Timer_t                            _startTick;
        osg::ref_ptr<osg::FrameStamp>           _frameStamp;

        osg::ref_ptr<osgViewer::Scene>          _scene;
        osg::ref_ptr<osgGA::EventQueue>         _eventQueue;
        osg::ref_ptr<osgGA::MatrixManipulator>  _cameraManipulator;
        EventHandlers                           _eventHandlers;
    
        typedef std::vector< osg::observer_ptr<osg::Node> >   ObserverNodePath;
        ObserverNodePath                        _coordinateSystemNodePath;

        osg::ref_ptr<osg::DisplaySettings>      _displaySettings;
        osgUtil::SceneView::FusionDistanceMode  _fusionDistanceMode;
        float                                   _fusionDistanceValue;
};

}

#endif
