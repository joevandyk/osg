/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGVIEWER_RENDERER
#define OSGVIEWER_RENDERER 1

#include <osg/Timer>
#include <osgUtil/SceneView>
#include <osgViewer/Export>

namespace osgViewer {

class OSGVIEWER_EXPORT OpenGLQuerySupport
{
    public:
        OpenGLQuerySupport();

        typedef std::pair<GLuint, int> QueryFrameNumberPair;
        typedef std::list<QueryFrameNumberPair> QueryFrameNumberList;
        typedef std::vector<GLuint> QueryList;

        void setStartTick(osg::Timer_t startTick) { _startTick = startTick; }
        osg::Timer_t getStartTick() const { return _startTick; }

        void checkQuery(osg::Stats* stats);
        
        GLuint createQueryObject();
        void beginQuery(int frameNumber);
        void endQuery();
        void initialize(osg::State* state);

    protected:

        osg::Timer_t                                _startTick;
        bool                                        _initialized;
        bool                                        _timerQuerySupported;
        const osg::Drawable::Extensions*            _extensions;
        QueryFrameNumberList                        _queryFrameNumberList;
        QueryList                                   _availableQueryObjects;
        double                                      _previousQueryTime;

};

class OSGVIEWER_EXPORT Renderer : public osg::GraphicsOperation, public OpenGLQuerySupport
{
    public:

        Renderer(osg::Camera* camera);

        osgUtil::SceneView* getSceneView(unsigned int i) { return _sceneView[i].get(); }

        void setDone(bool done) { _done = done; }
        bool getDone() { return _done; }

        void setGraphicsThreadDoesCull(bool flag);
        bool getGraphicsThreadDoesCull() const { return _graphicsThreadDoesCull; }

        void cull();
        void draw();
        void cull_draw();

        virtual void operator () (osg::Object* object);
        
        virtual void operator () (osg::GraphicsContext* context);

        virtual void release();

    protected:
    
        void updateSceneView(osgUtil::SceneView* sceneView);
    
        virtual ~Renderer();

        osg::observer_ptr<osg::Camera>                      _camera;
        
        bool                                                _done;
        bool                                                _graphicsThreadDoesCull;
        
        osg::ref_ptr<osgUtil::SceneView>                    _sceneView[2];
        
        osg::ref_ptr<osg::FlushDeletedGLObjectsOperation>   _flushOperation;
    

        struct OSGVIEWER_EXPORT TheadSafeQueue
        {
            OpenThreads::Mutex _mutex;
            OpenThreads::Block _block;
            typedef std::list<osgUtil::SceneView*> SceneViewList;
            SceneViewList _queue;
            
            TheadSafeQueue();
            ~TheadSafeQueue();
            
            void release()
            {
                _block.release();
            }
            
            osgUtil::SceneView* takeFront();
            
            void add(osgUtil::SceneView* sv);
        };


        TheadSafeQueue _availableQueue;
        TheadSafeQueue _drawQueue;

};

}

#endif
