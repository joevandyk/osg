/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGVIEWER_GRAPHICWINDOW
#define OSGVIEWER_GRAPHICWINDOW 1

#include <osg/GraphicsContext>
#include <osg/Notify>

#include <osgGA/EventQueue>

#include <osgViewer/Export>

namespace osgViewer {

/** GraphicsWindowProxy acts as an adpater GraphicsWindow which allows the implementation of the GraphicsWindow to be decoupled */
class OSGVIEWER_EXPORT GraphicsWindowProxy : public osgViewer::GraphicsWindow
{
    public:
    
        GraphicsWindowProxy();
    
        void setGraphicsWindowImplentation(osgViewer::GraphicsWindow* gw) { _gw = gw; }

        osgViewer::GraphicsWindow* getGraphicsWindowImplentation() { return _gw.get(); }
        
        const osgViewer::GraphicsWindow* getGraphicsWindowImplentation() const { return _gw.get(); }

        /** Realise the GraphicsContext implementation, 
          * Pure virtual - must be implemented by concrate implementations of GraphicsContext. */
        virtual bool realizeImplementation() { if (_gw.valid()) return _gw->realizeImplementation(); else osg::notify(osg::NOTICE)<<"GraphicsWindow::realizeImplementation() not implemented."<<std::endl; return false; }

        /** Return true if the graphics context has been realised, and is ready to use, implementation.
          * Pure virtual - must be implemented by concrate implementations of GraphicsContext. */
        virtual bool isRealizedImplementation() const  { if (_gw.valid()) return gw->isRealizedImplementation(); else osg::notify(osg::NOTICE)<<"GraphicsWindow::isRealizedImplementation() not implemented."<<std::endl; return false; }

        /** Close the graphics context implementation.
          * Pure virtual - must be implemented by concrate implementations of GraphicsContext. */
        virtual void closeImplementation()  { if (_gw.valid()) _gw->closeImplementation(); else osg::notify(osg::NOTICE)<<"GraphicsWindow::closeImplementation() not implemented."<<std::endl; }

        /** Make this graphics context current implementation.
          * Pure virtual - must be implemented by concrate implementations of GraphicsContext. */
        virtual void makeCurrentImplementation()  { if (_gw.valid()) _gw->makeCurrentImplementation(); else osg::notify(osg::NOTICE)<<"GraphicsWindow::makeCurrentImplementation() not implemented."<<std::endl; }
        
        /** Make this graphics context current with specified read context implementation.
          * Pure virtual - must be implemented by concrate implementations of GraphicsContext. */
        virtual void makeContextCurrentImplementation(GraphicsContext* readContext)  { if (_gw.valid()) _gw->makeContextCurrentImplementation(readContext); else osg::notify(osg::NOTICE)<<"GraphicsWindow::makeContextCurrentImplementation(..) not implemented."<<std::endl; }

        /** Pure virtual, Bind the graphics context to associated texture implementation.
          * Pure virtual - must be implemented by concrate implementations of GraphicsContext. */
        virtual void bindPBufferToTextureImplementation(GLenum buffer)  { if (_gw.valid()) _gw->bindPBufferToTextureImplementation(buffer) else osg::notify(osg::NOTICE)<<"GraphicsWindow::void bindPBufferToTextureImplementation(..) not implemented."<<std::endl; }

        /** Swap the front and back buffers implementation.
          * Pure virtual - must be implemented by Concrate implementations of GraphicsContext. */
        virtual void swapBuffersImplementation()  { if (_gw.valid()) _gw->swapBuffersImplementation() else osg::notify(osg::NOTICE)<<"GraphicsWindow:: swapBuffersImplementation() not implemented."<<std::endl; }

    public:

        // Override from GUIActionAdapter
        virtual void requestRedraw() { if (_gw.valid()) _gw->requestRedraw(); }

        // Override from GUIActionAdapter
        virtual void requestContinuousUpdate(bool needed=true) { if (_gw.valid()) _gw->tequestContinuousUpdate(needed); }

        // Override from GUIActionAdapter
        virtual void requestWarpPointer(float x,float y) { if (_gw.valid()) _gw->requestWarpPointer(x,y); }


    protected:
    
        osg::ref_ptr<osgViewer::GraphicsWindow> _gw;
        
};


}

#endif
