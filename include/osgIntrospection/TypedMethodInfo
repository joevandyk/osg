#ifndef OSGINTROSPECTION_TYPEDMETHODINFO_
#define OSGINTROSPECTION_TYPEDMETHODINFO_

#include <osgIntrospection/MethodInfo>
#include <osgIntrospection/Reflection>

namespace osgIntrospection
{

	/// Class templates TypedMethodInfoN (where 0 <= N <= 16) are concrete 
	/// implementations of MethodInfo. They are used to keep information
	/// about class methods and to provide the means for calling them
	/// dynamically. Each class template can handle methods with N arguments 
	/// and is parametrized by the class that declares the method and by the 
	/// return type. Both const and non-const methods are supported.
	/// The invoke() methods allow to call the reflected method dynamically,
	/// passing it the arguments as a list of Value objects. The instance
	/// on which the reflected method will be called is passed to invoke()
	/// as a Value object, which can contain either a value of type C or a
	/// pointer to C. If the constness doesn't match (i.e., you try to call
	/// a non-const reflected method on a const instance) an exception is
	/// thrown.
	///
	/// NOTE: currently, variant_cast<> does not check pointer conversions,
	/// it simply converts one pointer into another even if they point to
	/// types that are completely unrelated.
	/// This means you won't probably get any exceptions if you try to call
	/// a class' method on another class' instance, but of course that's a
	/// bad, bad idea...
	///
	template<typename C, typename R> 
	class TypedMethodInfo0: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)() const;
		typedef R (C::*FunctionType)();

		TypedMethodInfo0(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo0(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)();
			if (f_) return (variant_cast<C *>(instance)->*f_)();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)();
			if (f_) return (variant_cast<C *>(instance)->*f_)();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)();
		if (f_) return (variant_cast<C &>(instance).*f_)();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0> 
	class TypedMethodInfo1: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0) const;
		typedef R (C::*FunctionType)(P0);

		TypedMethodInfo1(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo1(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1> 
	class TypedMethodInfo2: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1) const;
		typedef R (C::*FunctionType)(P0, P1);

		TypedMethodInfo2(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo2(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2> 
	class TypedMethodInfo3: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2) const;
		typedef R (C::*FunctionType)(P0, P1, P2);

		TypedMethodInfo3(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo3(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3> 
	class TypedMethodInfo4: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3);

		TypedMethodInfo4(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo4(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4> 
	class TypedMethodInfo5: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4);

		TypedMethodInfo5(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo5(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5> 
	class TypedMethodInfo6: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5);

		TypedMethodInfo6(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo6(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6> 
	class TypedMethodInfo7: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6);

		TypedMethodInfo7(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo7(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7> 
	class TypedMethodInfo8: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7);

		TypedMethodInfo8(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo8(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8> 
	class TypedMethodInfo9: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8);

		TypedMethodInfo9(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo9(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9> 
	class TypedMethodInfo10: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9);

		TypedMethodInfo10(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo10(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10> 
	class TypedMethodInfo11: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);

		TypedMethodInfo11(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo11(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11> 
	class TypedMethodInfo12: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11);

		TypedMethodInfo12(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo12(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12> 
	class TypedMethodInfo13: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12);

		TypedMethodInfo13(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo13(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13> 
	class TypedMethodInfo14: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13);

		TypedMethodInfo14(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo14(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14> 
	class TypedMethodInfo15: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14);

		TypedMethodInfo15(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo15(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		Value a14(args[14].convertTo(typeof(P14)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		Value a14(args[14].convertTo(typeof(P14)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15> 
	class TypedMethodInfo16: public MethodInfo
	{
	public:
		typedef R (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) const;
		typedef R (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15);

		TypedMethodInfo16(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo16(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(R), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		Value a14(args[14].convertTo(typeof(P14)));
		Value a15(args[15].convertTo(typeof(P15)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15));
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		Value a14(args[14].convertTo(typeof(P14)));
		Value a15(args[15].convertTo(typeof(P15)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15));
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15));
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15));
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15));
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15));
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C> 
	class TypedMethodInfo0<C, void>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)() const;
		typedef void (C::*FunctionType)();

		TypedMethodInfo0(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo0(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0> 
	class TypedMethodInfo1<C, void, P0>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0) const;
		typedef void (C::*FunctionType)(P0);

		TypedMethodInfo1(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo1(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1> 
	class TypedMethodInfo2<C, void, P0, P1>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1) const;
		typedef void (C::*FunctionType)(P0, P1);

		TypedMethodInfo2(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo2(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2> 
	class TypedMethodInfo3<C, void, P0, P1, P2>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2) const;
		typedef void (C::*FunctionType)(P0, P1, P2);

		TypedMethodInfo3(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo3(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3> 
	class TypedMethodInfo4<C, void, P0, P1, P2, P3>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3);

		TypedMethodInfo4(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo4(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4> 
	class TypedMethodInfo5<C, void, P0, P1, P2, P3, P4>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4);

		TypedMethodInfo5(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo5(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5> 
	class TypedMethodInfo6<C, void, P0, P1, P2, P3, P4, P5>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5);

		TypedMethodInfo6(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo6(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6> 
	class TypedMethodInfo7<C, void, P0, P1, P2, P3, P4, P5, P6>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6);

		TypedMethodInfo7(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo7(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7> 
	class TypedMethodInfo8<C, void, P0, P1, P2, P3, P4, P5, P6, P7>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7);

		TypedMethodInfo8(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo8(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8> 
	class TypedMethodInfo9<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8);

		TypedMethodInfo9(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo9(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9> 
	class TypedMethodInfo10<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9);

		TypedMethodInfo10(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo10(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10> 
	class TypedMethodInfo11<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);

		TypedMethodInfo11(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo11(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11> 
	class TypedMethodInfo12<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11);

		TypedMethodInfo12(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo12(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12> 
	class TypedMethodInfo13<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12);

		TypedMethodInfo13(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo13(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13> 
	class TypedMethodInfo14<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13);

		TypedMethodInfo14(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo14(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14> 
	class TypedMethodInfo15<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14);

		TypedMethodInfo15(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo15(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		Value a14(args[14].convertTo(typeof(P14)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		Value a14(args[14].convertTo(typeof(P14)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


	template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15> 
	class TypedMethodInfo16<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>: public MethodInfo
	{
	public:
		typedef void (C::*ConstFunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) const;
		typedef void (C::*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15);

		TypedMethodInfo16(const std::string &qname, ConstFunctionType cf, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(cf), f_(0)
		{
		}

		TypedMethodInfo16(const std::string &qname, FunctionType f, const ParameterInfoList &plist)
		:	MethodInfo(qname, typeof(C), typeof(void), plist), cf_(0), f_(f)
		{
		}

		bool isConst() const { return cf_; }

	Value invoke(const Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		Value a14(args[14].convertTo(typeof(P14)));
		Value a15(args[15].convertTo(typeof(P15)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<const C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15)), Value();
		if (f_) throw ConstIsConstException();
		throw InvalidFunctionPointerException();
	}

	Value invoke(Value &instance, ValueList &args) const
	{
		Value a0(args[0].convertTo(typeof(P0)));
		Value a1(args[1].convertTo(typeof(P1)));
		Value a2(args[2].convertTo(typeof(P2)));
		Value a3(args[3].convertTo(typeof(P3)));
		Value a4(args[4].convertTo(typeof(P4)));
		Value a5(args[5].convertTo(typeof(P5)));
		Value a6(args[6].convertTo(typeof(P6)));
		Value a7(args[7].convertTo(typeof(P7)));
		Value a8(args[8].convertTo(typeof(P8)));
		Value a9(args[9].convertTo(typeof(P9)));
		Value a10(args[10].convertTo(typeof(P10)));
		Value a11(args[11].convertTo(typeof(P11)));
		Value a12(args[12].convertTo(typeof(P12)));
		Value a13(args[13].convertTo(typeof(P13)));
		Value a14(args[14].convertTo(typeof(P14)));
		Value a15(args[15].convertTo(typeof(P15)));
		const Type &type = instance.getType();
		if (type.isPointer())
		{
			if (type.isConstPointer())
			{
				if (cf_) return (variant_cast<const C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15)), Value();
				if (f_) throw ConstIsConstException();
				throw InvalidFunctionPointerException();
			}
			if (cf_) return (variant_cast<C *>(instance)->*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15)), Value();
			if (f_) return (variant_cast<C *>(instance)->*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15)), Value();
			throw InvalidFunctionPointerException();
		}
		if (cf_) return (variant_cast<C &>(instance).*cf_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15)), Value();
		if (f_) return (variant_cast<C &>(instance).*f_)(variant_cast<P0>(a0), variant_cast<P1>(a1), variant_cast<P2>(a2), variant_cast<P3>(a3), variant_cast<P4>(a4), variant_cast<P5>(a5), variant_cast<P6>(a6), variant_cast<P7>(a7), variant_cast<P8>(a8), variant_cast<P9>(a9), variant_cast<P10>(a10), variant_cast<P11>(a11), variant_cast<P12>(a12), variant_cast<P13>(a13), variant_cast<P14>(a14), variant_cast<P15>(a15)), Value();
		throw InvalidFunctionPointerException();
	}

	private:
		ConstFunctionType cf_;
		FunctionType f_;
	};


}

#endif

