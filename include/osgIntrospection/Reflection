#ifndef OSGINTROSPECTION_REFLECTION_
#define OSGINTROSPECTION_REFLECTION_

#include <osgIntrospection/Export>

#include <typeinfo>
#include <map>
#include <vector>

/// This macro emulates the behavior of the standard typeid operator,
/// returning the Type object associated to the type of the given
/// expression.
#define typeof(expr)  osgIntrospection::Reflection::getType(typeid(expr))

namespace osgIntrospection
{

    class Type;
    struct Converter;
    
    typedef std::vector<const Converter *> ConverterList;

    /// This predicate compares two instances of std::type_info for equality.
    /// Note that we can't rely on default pointer comparison because it is
    /// not guaranteed that &typeid(T) always returns the same pointer for a
    /// given T (thanks Andrew Koenig).
    struct TypeInfoCmp
    {
        bool operator()(const std::type_info *t1, const std::type_info *t2) const
        {
            return t1->before(*t2) != 0;
        }
    };

    /// A map of types, indexed by their associated type_info structure.
    typedef std::map<const std::type_info *, Type *, TypeInfoCmp> TypeMap;


    /// This class provides basic reflection services such as registration
    /// of new types and queries on the global type map.
    class OSGINTROSPECTION_EXPORT Reflection
    {
    public:
        /// Returns the Type object associated to the given type_info
        /// structure. If the type hasn't been created yet it is 
        /// automatically created and added to the global type map. 
        /// Please note that such type will have the status of
        /// "declared", you still need to give details about it through
        /// a Reflector class before you can query it.
        static const Type &getType(const std::type_info &ti);

        /// Finds a Type object given its qualified name, which must
        /// be identical to the qualified name returned by that Type's
        /// getQualifiedName() method. If the type hasn't been created
        /// yet, an exception is thrown.
        static const Type &getType(const std::string &qname);

        /// Returns the global map of types.
        static const TypeMap &getTypes();

        /// Return the Type object associated to the C++ type 'void'.
        /// This is a shortcut for typeof(void), which may be slow if
        /// the type map is large.
        static const Type &type_void();

        static const Converter *getConverter(const Type &source, const Type &dest);
        static bool getConversionPath(const Type &source, const Type &dest, ConverterList &conv);
        
    private:
        template<typename C> friend class Reflector;
        template<typename C> friend struct TypeNameAliasProxy;
        friend struct ConverterProxy;

        struct StaticData
        {
            TypeMap typemap;
            const Type *type_void;
            
            typedef std::map<const Type *, const Converter *> ConverterMap;
            typedef std::map<const Type *, ConverterMap> ConverterMapMap;
            ConverterMapMap convmap;
            
            ~StaticData();
        };

        static StaticData &getOrCreateStaticData();
        static Type *registerType(const std::type_info &ti);
        static Type *getOrRegisterType(const std::type_info &ti, bool replace_if_defined = false);
        static void registerConverter(const Type &source, const Type &dest, const Converter *cvt);

    private:
		static bool accum_conv_path(const Type &source, const Type &dest, ConverterList &conv, std::vector<const Type *> &chain);
        static StaticData *staticdata__;
    };

}

#endif
