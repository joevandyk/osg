/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2003 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGDB_ARCHIVE
#define OSGDB_ARCHIVE 1

#include <osgDB/ReaderWriter>

#include <fstream>
#include <list>

namespace osgDB {


/** Base class for implementing database Archives. */


class OSGDB_EXPORT Archive : public ReaderWriter
{
    public:
        Archive();
        virtual ~Archive(); 

        virtual const char* libraryName() const { return "osgDB"; }

        virtual const char* className() const { return "Archive"; }

        virtual bool acceptsExtension(const std::string& /*extension*/) { return true; }
        
        enum Status
        {
            READ,
            WRITE
        };

        /** open the archive.*/
        virtual bool create(const std::string& filename, unsigned int indexBlockSize=4096);

        /** open the archive.*/
        virtual bool open(const std::string& filename, Status status);

        /** close the archive.*/
        virtual void close();

        /** return true if file exists in archive.*/        
        virtual bool fileExists(const std::string& filename) const;
        
        typedef std::istream::pos_type pos_type;
        typedef std::istream::off_type size_type;
        typedef std::pair<pos_type, size_type> PositionSizePair;
        typedef std::map<std::string, PositionSizePair> FileNamePositionMap;

        const FileNamePositionMap& getFileNamePositionMap() const { return _indexMap; }

        virtual ReadResult readObject(const std::string& fileName,const Options* options=NULL);
        virtual ReadResult readImage(const std::string& fileName,const Options* options=NULL);
        virtual ReadResult readHeightField(const std::string& fileName,const Options* options=NULL);
        virtual ReadResult readNode(const std::string& fileName,const Options* options=NULL);

        virtual WriteResult writeObject(const osg::Object& obj,const std::string& fileName,const Options* options=NULL);
        virtual WriteResult writeImage(const osg::Image& image,const std::string& fileName,const Options* options=NULL);
        virtual WriteResult writeHeightField(const osg::HeightField& heightField,const std::string& fileName,const Options* options=NULL);
        virtual WriteResult writeNode(const osg::Node& node,const std::string& fileName,const Options* options=NULL);
        
    protected:
    
        

        class IndexBlock : public osg::Referenced
        {
        public:
            IndexBlock(unsigned int blockSize=0);
            
            inline pos_type getPosition() const { return _filePosition; }

            inline unsigned int getBlockSize() const { return _blockSize; }


            void setPositionNextIndexBlock(pos_type position);
            
            inline pos_type getPositionNextIndexBlock() const { return _filePositionNextIndexBlock; }


            static IndexBlock* read(std::istream& in);
            
            bool getFileReferences(FileNamePositionMap& indexMap);
            

            inline bool requiresWrite() const { return _requiresWrite; }
            
            void write(std::ostream& out);
            
            inline bool spaceAvailable(pos_type position, size_type size, const std::string& filename) const
            {
                unsigned requiredSize = sizeof(position)+sizeof(unsigned int)+filename.size();
                return (_offsetOfNextAvailableSpace + requiredSize)<_blockSize;
            }
            
            bool addFileReference(pos_type position, size_type size, const std::string& filename);
            


        protected:
            
            void allocateData(unsigned int blockSize);
        
            virtual ~IndexBlock();
            bool            _requiresWrite;
            pos_type        _filePosition;

            unsigned int    _blockSize;
            pos_type        _filePositionNextIndexBlock;
            unsigned int    _offsetOfNextAvailableSpace;
            unsigned char*  _data;
        };
    
    
    
        typedef std::list< osg::ref_ptr<IndexBlock> >   IndexBlockList;
        
        void writeIndexBlocks();
        
        bool addFileReference(pos_type position, size_type size, const std::string& fileName);
        
        static float        s_currentSupportedVersion;
        float               _version;
        Status              _status;
        std::ifstream       _input;
        std::ofstream       _output;
        
        IndexBlockList      _indexBlockList;
        FileNamePositionMap _indexMap;


};

}

#endif // OSGDB_ARCHIVE
