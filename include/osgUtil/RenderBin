/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2003 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGUTIL_RENDERBIN
#define OSGUTIL_RENDERBIN 1

#include <osgUtil/RenderGraph>

#include <map>
#include <vector>
#include <string>

// forward declare Statistics to remove link dependancy.
namespace osg { class Statistics; }

namespace osgUtil {

class RenderStage;

/**
 * RenderBin base class.
 */
class OSGUTIL_EXPORT RenderBin : public osg::Object
{
    public:
    
        typedef std::vector<RenderLeaf*>                    RenderLeafList; 
        typedef std::vector<RenderGraph*>                   RenderGraphList;
        typedef std::map< int, osg::ref_ptr<RenderBin> >    RenderBinList; 

        // static methods.
        static RenderBin* createRenderBin(const std::string& binName);
        static RenderBin* getRenderBinPrototype(const std::string& binName);
        static void addRenderBinPrototype(const std::string& binName,RenderBin* proto);
        static void removeRenderBinPrototype(RenderBin* proto);

        enum SortMode
        {
            SORT_BY_STATE,
            SORT_FRONT_TO_BACK,
            SORT_BACK_TO_FRONT
        };


        RenderBin(SortMode mode=SORT_BY_STATE);

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        RenderBin(const RenderBin& rhs,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);

        virtual osg::Object* cloneType() const { return new RenderBin(); }
        virtual osg::Object* clone(const osg::CopyOp& copyop) const { return new RenderBin(*this,copyop); } // note only implements a clone of type.
        virtual bool isSameKindAs(const osg::Object* obj) const { return dynamic_cast<const RenderBin*>(obj)!=0L; }
        virtual const char* libraryName() const { return "osgUtil"; }
        virtual const char* className() const { return "RenderBin"; }

        virtual void reset();
        
        RenderBin* find_or_insert(int binNum,const std::string& binName);

        void addRenderGraph(RenderGraph* rg)
        {
            _renderGraphList.push_back(rg);
        }

        void sort();

        virtual void sortImplementation();
	
        void setSortMode(SortMode mode);
        SortMode getSortMode() const { return _sortMode; }

        virtual void sortByState();
        virtual void sortFrontToBack();
        virtual void sortBackToFront();
        
        struct SortCallback : public osg::Referenced    
        {
            virtual void sortImplementation(RenderBin*) = 0;
        };

        void setSortCallback(SortCallback* sortCallback) { _sortCallback = sortCallback; }
        SortCallback* getSortCallback() { return _sortCallback.get(); }
        const SortCallback* getSortCallback() const { return _sortCallback.get(); }



        virtual void draw(osg::State& state,RenderLeaf*& previous);

        virtual void drawImplementation(osg::State& state,RenderLeaf*& previous);

        struct DrawCallback : public osg::Referenced    
        {
            virtual void drawImplementation(RenderBin* bin,osg::State& state,RenderLeaf*& previous) = 0;
        };

        void setDrawCallback(DrawCallback* drawCallback) { _drawCallback = drawCallback; }
        DrawCallback* getDrawCallback() { return _drawCallback.get(); }
        const DrawCallback* getDrawCallback() const { return _drawCallback.get(); }



        /** extract stats for current draw list. */
        bool getStats(osg::Statistics* primStats);
        void getPrims(osg::Statistics* primStats);
        bool getPrims(osg::Statistics* primStats, int nbin);


    public:


        void copyLeavesFromRenderGraphListToRenderLeafList();
   
        int                             _binNum;
        RenderBin*                      _parent;
        RenderStage*                    _stage;
        RenderBinList                   _bins;
        RenderGraphList                 _renderGraphList;
        RenderLeafList                  _renderLeafList;
           

        SortMode                        _sortMode;
        osg::ref_ptr<SortCallback>      _sortCallback;

        osg::ref_ptr<DrawCallback>      _drawCallback;

    protected:
    
        virtual ~RenderBin();

};

/** Proxy class for automatic registration of renderbins with the RenderBin prototypelist.*/
class RegisterRenderBinProxy
{
    public:
        RegisterRenderBinProxy(const std::string& binName,RenderBin* proto)
        {
            _rb = proto;
            RenderBin::addRenderBinPrototype(binName,_rb.get());
        }

        ~RegisterRenderBinProxy()
        {
            RenderBin::removeRenderBinPrototype(_rb.get());
        }
        
    protected:
        osg::ref_ptr<RenderBin> _rb;
};


}

#endif

    
