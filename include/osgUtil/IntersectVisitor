#ifndef OSGUTIL_INTERSECTVISITOR
#define OSGUTIL_INTERSECTVISITOR 1

#include <osg/NodeVisitor>
#include <osg/Seg>
#include <osg/Geode>
#include <osg/Matrix>

#include <osgUtil/Export>

#include <map>
#include <set>
#include <vector>

namespace osgUtil {

class OSGUTIL_EXPORT IntersectState : public osg::Referenced
{
    public:

        IntersectState();

        osg::Matrix* _matrix;
        osg::Matrix* _inverse;

        typedef std::vector< std::pair<osg::Seg*,osg::Seg*> > SegList;
        SegList _segList;

        typedef unsigned int SegmentMask;
        typedef std::vector<SegmentMask> SegmentMaskStack;
        SegmentMaskStack _segmentMaskStack;

        bool isCulled(const osg::BoundingSphere& bs,SegmentMask& segMaskOut);
        bool isCulled(const osg::BoundingBox& bb,SegmentMask& segMaskOut);

    protected:

        ~IntersectState();
    
};

class OSGUTIL_EXPORT Hit : public osg::Referenced
{
    public:
        Hit();
        Hit(const Hit& hit);
        ~Hit();
        
        Hit& operator = (const Hit& hit);
        
        typedef std::vector<int> VecIndexList;

        bool operator < (const Hit& hit) const
        {
            if (_originalSeg<hit._originalSeg) return true;
            if (_originalSeg>hit._originalSeg) return false;
            return _ratio<hit._ratio;
        }

        float                _ratio;
        osg::Seg*            _originalSeg;
        osg::Seg*            _localSeg;
        osg::NodePath        _nodePath;
        osg::Geode*          _geode;
        osg::GeoSet*         _geoset;
        osg::Matrix*         _matrix;
        
        VecIndexList         _vecIndexList;
        int                  _primitiveIndex;
        osg::Vec3            _intersectPoint;
        osg::Vec3            _intersectNormal;
};


/** Basic visitor for ray based collisions of a scene.
    Note, still in development, current version has not
    pratical functionality!*/
class OSGUTIL_EXPORT IntersectVisitor : public osg::NodeVisitor
{
    public:

        IntersectVisitor();
        virtual ~IntersectVisitor();

        void reset();
        
        /** Add a line segment to use for intersection testing during scene traversal.*/
        void addSeg(osg::Seg* seg);

        /** Modes to control how IntersectVisitor reports hits. */
        enum HitReportingMode {
            ONLY_NEAREST_HIT,
            ALL_HITS
        };

        /** Set the mode of how hits should reported back from a traversal.*/
        void setHitReportingMode(HitReportingMode hrm) { _hitReportingMode = hrm; }
        /** Get the mode of how hits should reported back from a traversal.*/
        HitReportingMode getHitReportingMode() { return _hitReportingMode; }

        //typedef std::multiset<Hit> HitList;
        typedef std::vector<Hit> HitList;
        typedef std::map<osg::Seg*,HitList > SegHitListMap;
        HitList& getHitList(osg::Seg* seg) { return _segHitList[seg]; }
        int getNumHits(osg::Seg* seg) { return _segHitList[seg].size(); }

        bool hits();

        virtual void apply(osg::Node&);
        virtual void apply(osg::Geode& node);
        virtual void apply(osg::Billboard& node);

        virtual void apply(osg::Group& node);
        virtual void apply(osg::DCS& node);
        virtual void apply(osg::Switch& node);
        virtual void apply(osg::LOD& node);
        virtual void apply(osg::Scene& node);

    protected:


        bool intersect(osg::GeoSet& gset);

        void pushMatrix(const osg::Matrix& matrix);
        void popMatrix();

        bool enterNode(osg::Node& node);
        void leaveNode();

        typedef std::vector<IntersectState*> IntersectStateStack;
        IntersectStateStack                  _intersectStateStack;

        osg::NodePath                    _nodePath;

        HitReportingMode            _hitReportingMode;
        SegHitListMap               _segHitList;
};

};

#endif

