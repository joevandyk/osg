#ifndef OSGUTIL_RENDERVISITOR
#define OSGUTIL_RENDERVISITOR 1

#include <osg/NodeVisitor>
#include <osg/BoundingSphere>
#include <osg/BoundingBox>
#include <osg/Matrix>
#include <osg/GeoSet>
#include <osg/GeoState>
#include <osg/Camera>

#include <osgUtil/Export>

#include <map>
#include <vector>

namespace osgUtil {

/** Container class for encapsulating the viewing state in local
    coordinates, during the cull traversal.
*/
class OSGUTIL_EXPORT ViewState : public osg::Referenced
{
    public:

        ViewState();

        osg::Matrix* _matrix;
        osg::Matrix* _inverse;
        osg::Vec3    _eyePoint;
        osg::Vec3    _centerPoint;
        osg::Vec3    _lookVector;
        osg::Vec3    _upVector;
        osg::Vec3    _frustumTopNormal;
        osg::Vec3    _frustumBottomNormal;
        osg::Vec3    _frustumLeftNormal;
        osg::Vec3    _frustumRightNormal;
        float   _ratio;

        bool _viewFrustumCullingActive;
        bool _smallFeatureCullingActive;

        bool isCulled(const osg::BoundingSphere& sp);
        bool isCulled(const osg::BoundingBox& bb);

    protected:

        ~ViewState();

};


/**
 * Basic NodeVisitor implementation for rendering a scene.
 * This visitor traverses the scene graph, collecting transparent and
 * opaque osg::GeoSets into a depth sorted transparent bin and a state
 * sorted opaque bin.  The opaque bin is rendered first, and then the
 * transparent bin in rendered in order from the furthest osg::GeoSet
 * from the eye to the one nearest the eye. 
 */
class OSGUTIL_EXPORT RenderVisitor : public osg::NodeVisitor
{
    public:

        RenderVisitor();
        virtual ~RenderVisitor();

        void reset();

        virtual void apply(osg::Node&);
        virtual void apply(osg::Geode& node);
        virtual void apply(osg::Billboard& node);
        virtual void apply(osg::LightSource& node);

        virtual void apply(osg::Group& node);
        virtual void apply(osg::DCS& node);
        virtual void apply(osg::Switch& node);
        virtual void apply(osg::LOD& node);
        virtual void apply(osg::Scene& node);

        void setGlobalState(osg::GeoState* global);

        void setPerspective(const osg::Camera& camera);
        void setPerspective(float fovy,float aspect,float znear,float zfar);

        void setLookAt(const osg::Camera& camera);
        void setLookAt(const osg::Vec3& eye,const osg::Vec3& center,const osg::Vec3& upVector);
        void setLookAt(double eyeX,double eyeY,double eyeZ,
                       double centerX,double centerY,double centerZ,
                       double upX,double upY,double upZ);


        void setLODBias(float bias) { _LODBias = bias; }
        float getLODBias()          { return _LODBias; }
        
        enum TransparencySortMode {
            LOOK_VECTOR_DISTANCE,
            OBJECT_EYE_POINT_DISTANCE
        };

        void setTransparencySortMode(TransparencySortMode tsm) { _tsm = tsm; }
        
        enum CullingType {
            VIEW_FRUSTUM_CULLING,
            SMALL_FEATURE_CULLING
        };

	/**
	 * Enables/disables the specified culling type.
	 * @param ct The culling type to enable/disable.
	 * @param active true enables the culling type, false disables.
	 */
        void setCullingActive(CullingType ct, bool active);

	/**
	 * Returns the state of the specified culling type.
	 * @result true, if culling type is enabled, false otherwise.
	 */
        bool getCullingActive(CullingType ct);

	/**
	 * Calculates the near_plane and the far_plane for the current
	 * camera view depending on the objects currently stored in the
         * opaque and transparent bins.
	 * @param near_plane reference to a variable that can store the
	 * near plane result.
	 * @param far_plane reference to a variable that can store the
	 * far plane result.
	 * @result true, if near_plane and far_plane contain valid values,
	 * false otherwise.
	 */
        bool calcNearFar(double& near_plane, double& far_plane);

        /**
	 * Renders the osg::GeoSets that were collected in the opaque and
	 * transparent bins before.
	 */
	void render();

    protected:

        void pushMatrix(const osg::Matrix& matrix);
        void popMatrix();

        osg::Matrix* getCurrentMatrix();
        osg::Matrix* getInverseCurrentMatrix();
        const osg::Vec3& getEyeLocal();
        const osg::Vec3& getCenterLocal();
        const osg::Vec3& getLookVectorLocal();
        

        bool _viewFrustumCullingActive;
        bool _smallFeatureCullingActive;

        bool isCulled(const osg::BoundingSphere& sp);
        bool isCulled(const osg::BoundingBox& bb);

        typedef std::pair<osg::Matrix*,osg::GeoSet*>      MatrixGeoSet;

        typedef std::vector<ViewState*> ViewStateStack;
        ViewStateStack                  _viewStateStack;
        ViewState*                      _tvs;
        ViewState*                      _cvs;


        typedef std::multimap<osg::GeoState*,MatrixGeoSet> OpaqueList;
        typedef std::multimap<float,MatrixGeoSet>     TransparentList;
        typedef std::map<osg::Matrix*,osg::Light*> LightList;

        OpaqueList      _opaqueGeoSets;
        TransparentList _transparentGeoSets;
        LightList       _lights;

        osg::GeoState* _globalState;
        float   _LODBias;

        float   _fovy;
        float   _aspect;
        float   _znear;
        float   _zfar;

        void calculateClippingPlanes();

        // frustum clipping normals.
        osg::Vec3    _frustumTop;
        osg::Vec3    _frustumBottom;
        osg::Vec3    _frustumLeft;
        osg::Vec3    _frustumRight;
        
        TransparencySortMode _tsm;
};

};

#endif

