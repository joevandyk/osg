//C++ header - Open Scene Graph - Copyright (C) 1998-2002 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSGUTIL_CULLVISITOR
#define OSGUTIL_CULLVISITOR 1

#include <osg/NodeVisitor>
#include <osg/BoundingSphere>
#include <osg/BoundingBox>
#include <osg/Matrix>
#include <osg/Drawable>
#include <osg/StateSet>
#include <osg/State>
#include <osg/Impostor>
#include <osg/EarthSky>
#include <osg/Notify>
#include <osg/Notify>

#include <osg/CullStack>

#include <osgUtil/RenderGraph>
#include <osgUtil/RenderStage>

#include <map>
#include <vector>

#include <osg/Vec3>

namespace osgUtil {

/**
 * Basic NodeVisitor implementation for rendering a scene.
 * This visitor traverses the scene graph, collecting transparent and
 * opaque osg::Drawables into a depth sorted transparent bin and a state
 * sorted opaque bin.  The opaque bin is rendered first, and then the
 * transparent bin in rendered in order from the furthest osg::Drawable
 * from the eye to the one nearest the eye. 
 */
class OSGUTIL_EXPORT CullVisitor : public osg::NodeVisitor, public osg::CullStack
{
    public:

        CullVisitor();
        virtual ~CullVisitor();

        virtual CullVisitor* cloneType() const { return osgNew CullVisitor(); }

        virtual void reset();

        virtual void apply(osg::Node&);
        virtual void apply(osg::Geode& node);
        virtual void apply(osg::Billboard& node);
        virtual void apply(osg::LightSource& node);
        virtual void apply(osg::ClipNode& node);

        virtual void apply(osg::Group& node);
        virtual void apply(osg::Transform& node);
        virtual void apply(osg::Projection& node);
        virtual void apply(osg::Switch& node);
        virtual void apply(osg::LOD& node);
        virtual void apply(osg::EarthSky& node);
        virtual void apply(osg::OccluderNode& node);
        virtual void apply(osg::Impostor& node);

        void setEarthSky(const osg::EarthSky* earthSky) { _earthSky = earthSky; }
        const osg::EarthSky* getEarthSky() const { return _earthSky.get(); }


        /** Switch the creation of Impostors on or off.
          * Setting active to false forces the CullVisitor to use the Impostor
          * LOD children for rendering. Setting active to true forces the
          * CullVisitor to create the appropriate pre-rendering stages which
          * render to the ImpostorSprite's texture.*/
        void setImpostorsActive(const bool active) { _impostorActive = active; }
        
        /** Get whether impostors are active or not. */
        const bool getImpostorsActive() const { return _impostorActive; }

        /** Set the impostor error threshold.
          * Used in calculation of whether impostors remain valid.*/
        void setImpostorPixelErrorThreshold(const float numPixels) { _impostorPixelErrorThreshold=numPixels; }

        /** Get the impostor error threshold.*/
        const float getImpostorPixelErrorThreshold() const { return _impostorPixelErrorThreshold; }

        /** Set whether ImpsotorSprite's should be placed in a depth sorted bin for rendering.*/
        void setDepthSortImpostorSprites(const bool doDepthSort) { _depthSortImpostorSprites = doDepthSort; }

        /** Get whether ImpsotorSprite's are depth sorted bin for rendering.*/
        const bool setDepthSortImpostorSprites() const { return _depthSortImpostorSprites; }

        /** Set the number of frames that an ImpsotorSprite's is kept whilst not being beyond,
          * before being recycled.*/
        void setNumberOfFrameToKeepImpostorSprites(const int numFrames) { _numFramesToKeepImpostorSprites = numFrames; }

        /** Get the number of frames that an ImpsotorSprite's is kept whilst not being beyond,
          * before being recycled.*/
        const int getNumberOfFrameToKeepImpostorSprites() const { return _numFramesToKeepImpostorSprites; }

        enum ComputeNearFarMode
        {
            DO_NOT_COMPUTE_NEAR_FAR = 0,
            COMPUTE_NEAR_FAR_USING_BOUNDING_VOLUMES,
            COMPUTE_NEAR_FAR_USING_PRIMITIVES
        };

        void setComputeNearFarMode(ComputeNearFarMode cnfm) { _computeNearFar=cnfm; } 
        ComputeNearFarMode getComputeNearFarMode() const { return _computeNearFar;} 
        
        
        enum TransparencySortMode {
            LOOK_VECTOR_DISTANCE,
            OBJECT_EYE_POINT_DISTANCE
        };

        void setTransparencySortMode(TransparencySortMode tsm) { _tsm = tsm; }
        /** Push state set on the current state group.
          * If the state exists in a child state group of the current
          * state group then move the current state group to that child.
          * Otherwise, create a new state group for the state set, add
          * it to the current state group then move the current state
          * group pointer to the new state group.
          */
        inline void pushStateSet(const osg::StateSet* ss)
        {
            _currentRenderGraph = _currentRenderGraph->find_or_insert(ss);
            if (ss->useRenderBinDetails())
            {
                _currentRenderBin = _currentRenderBin->find_or_insert(ss->getBinNumber(),ss->getBinName());
            }
        }
        
        /** Pop the top state set and hence associated state group.
          * Move the current state group to the parent of the popped
          * state group.
          */
        inline void popStateSet()
        {
            if (_currentRenderGraph->_stateset->useRenderBinDetails())
            {
                _currentRenderBin = _currentRenderBin->_parent;
            }
            _currentRenderGraph = _currentRenderGraph->_parent;
        }
        
        inline void setRenderGraph(RenderGraph* rg)
        {
            _rootRenderGraph = rg;
            _currentRenderGraph = rg;
        }

        inline RenderGraph* getRootRenderGraph()
        {
            return _rootRenderGraph.get();
        }

        inline RenderGraph* getCurrentRenderGraph()
        {
            return _currentRenderGraph;
        }

        inline void setRenderStage(RenderStage* rg)
        {
            _rootRenderStage = rg;
            _currentRenderBin = rg;
        }

        inline RenderStage* getRenderStage()
        {
            return _rootRenderStage.get();
        }

        inline RenderBin* getCurrentRenderBin()
        {
            return _currentRenderBin;
        }

        inline void setCurrentRenderBin(RenderBin* rb)
        {
            _currentRenderBin = rb;
        }

        inline const float getCalculatedNearPlane() const { return _computed_znear; }
        
        inline const float getCalculatedFarPlane() const { return _computed_zfar; }

	void updateCalculatedNearFar(const osg::Matrix& matrix,const osg::Drawable& drawable) { updateCalculatedNearFar(matrix,drawable.getBound()); }
	void updateCalculatedNearFar(const osg::Matrix& matrix,const osg::BoundingBox& bb);
    	void updateCalculatedNearFar(const osg::Vec3& pos);
		
        /** Add a drawable to current render graph.*/
        inline void addDrawable(osg::Drawable* drawable,osg::Matrix* matrix);

        /** Add a drawable and depth to current render graph.*/
        inline void addDrawableAndDepth(osg::Drawable* drawable,osg::Matrix* matrix,const float depth);

        /** Add an attribute which is positioned related to the modelview matrix.*/
        inline void addPositionedAttribute(osg::Matrix* matrix,const osg::StateAttribute* attr);

        /** reimplement CullStack's popProjectionMatrix() adding clamping of the projection matrix to the computed near and far.*/
        void popProjectionMatrix();

        void setState(osg::State* state) { _state = state; }
        osg::State* getState() { return _state.get(); }
        const osg::State* getState() const { return _state.get(); }

    protected:

        /** prevent unwanted copy construction.*/
        CullVisitor(const CullVisitor&):osg::NodeVisitor(),osg::CullStack() {}

        /** prevent unwanted copy operator.*/
        CullVisitor& operator = (const CullVisitor&) { return *this; }
        
        inline void handle_cull_callbacks_and_traverse(osg::Node& node)
        {
            osg::NodeCallback* callback = node.getCullCallback();
            if (callback) (*callback)(&node,this);
            else traverse(node);
        }

        inline void handle_cull_callbacks_and_accept(osg::Node& node,osg::Node* acceptNode)
        {
            osg::NodeCallback* callback = node.getCullCallback();
            if (callback) (*callback)(&node,this);
            else acceptNode->accept(*this);
        }


        /** create an impostor sprite by setting up a pre-rendering stage
          * to generate the impostor texture. */
        osg::ImpostorSprite* createImpostorSprite(osg::Impostor& node);

        osg::ref_ptr<RenderGraph>                                   _rootRenderGraph;
        RenderGraph*                                                _currentRenderGraph;

        osg::ref_ptr<RenderStage>                                   _rootRenderStage;        
        RenderBin*                                                  _currentRenderBin;


        ComputeNearFarMode  _computeNearFar;
        float               _computed_znear;
        float               _computed_zfar;
        
        osg::ref_ptr<const osg::EarthSky> _earthSky;

        TransparencySortMode _tsm;
	
        bool _impostorActive;
        bool _depthSortImpostorSprites;
        float _impostorPixelErrorThreshold;
        int _numFramesToKeepImpostorSprites;
	
        
	typedef std::vector< osg::ref_ptr<RenderLeaf> > RenderLeafList;
	RenderLeafList _reuseRenderLeafList;
	unsigned int _currentReuseRenderLeafIndex;
	
	inline RenderLeaf* createOrReuseRenderLeaf(osg::Drawable* drawable,osg::Matrix* projection,osg::Matrix* matrix, float depth=0.0f);
        
        osg::ref_ptr<osg::ImpostorSpriteManager> _impostorSpriteManager;

        osg::ref_ptr<osg::State>                    _state;
	
};

inline void CullVisitor::addDrawable(osg::Drawable* drawable,osg::Matrix* matrix)
{
    if (_currentRenderGraph->leaves_empty())
    {
        // this is first leaf to be added to RenderGraph
        // and therefore should not already know to current render bin,
        // so need to add it.
        _currentRenderBin->addRenderGraph(_currentRenderGraph);
    }
    //_currentRenderGraph->addLeaf(new RenderLeaf(drawable,matrix));
    _currentRenderGraph->addLeaf(createOrReuseRenderLeaf(drawable,_projectionStack.back().get(),matrix));
}

/** Add a drawable and depth to current render graph.*/
inline void CullVisitor::addDrawableAndDepth(osg::Drawable* drawable,osg::Matrix* matrix,const float depth)
{
    if (_currentRenderGraph->leaves_empty())
    {
        // this is first leaf to be added to RenderGraph
        // and therefore should not already know to current render bin,
        // so need to add it.
        _currentRenderBin->addRenderGraph(_currentRenderGraph);
    }
    //_currentRenderGraph->addLeaf(new RenderLeaf(drawable,matrix,depth));
    _currentRenderGraph->addLeaf(createOrReuseRenderLeaf(drawable,_projectionStack.back().get(),matrix,depth));
}

/** Add an attribute which is positioned related to the modelview matrix.*/
inline void CullVisitor::addPositionedAttribute(osg::Matrix* matrix,const osg::StateAttribute* attr)
{
    _currentRenderBin->_stage->addPositionedAttribute(matrix,attr);
}

inline RenderLeaf* CullVisitor::createOrReuseRenderLeaf(osg::Drawable* drawable,osg::Matrix* projection,osg::Matrix* matrix, float depth)
{
    // skip of any already reused renderleaf.
    while (_currentReuseRenderLeafIndex<_reuseRenderLeafList.size() && 
           _reuseRenderLeafList[_currentReuseRenderLeafIndex]->referenceCount()>1)
    {
        osg::notify(osg::NOTICE)<<"Warning:createOrReuseRenderLeaf() skipping multiply refrenced entry."<< std::endl;
        ++_currentReuseRenderLeafIndex;
    }

    // if still within list, element must be singularly referenced
    // there return it to be reused.
    if (_currentReuseRenderLeafIndex<_reuseRenderLeafList.size())
    {
        RenderLeaf* renderleaf = _reuseRenderLeafList[_currentReuseRenderLeafIndex++].get();
        renderleaf->set(drawable,projection,matrix,depth);
        return renderleaf;
    }

    // otherwise need to create new renderleaf.
    RenderLeaf* renderleaf = osgNew RenderLeaf(drawable,projection,matrix,depth);
    _reuseRenderLeafList.push_back(renderleaf);
    ++_currentReuseRenderLeafIndex;
    return renderleaf;
}


}

#endif

