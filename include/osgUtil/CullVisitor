//C++ header - Open Scene Graph - Copyright (C) 1998-2001 Robert Osfield
//Distributed under the terms of the GNU Library General Public License (LGPL)
//as published by the Free Software Foundation.

#ifndef OSGUTIL_CULLVISITOR
#define OSGUTIL_CULLVISITOR 1

#include <osg/NodeVisitor>
#include <osg/BoundingSphere>
#include <osg/BoundingBox>
#include <osg/Matrix>
#include <osg/Drawable>
#include <osg/StateSet>
#include <osg/State>
#include <osg/Impostor>
#include <osg/EarthSky>
#include <osg/Notify>

#include <osgUtil/RenderGraph>
#include <osgUtil/RenderStage>
#include <osgUtil/CullViewState>

#include <map>
#include <vector>

#include <osg/Vec3>

namespace osgUtil {

/**
 * Basic NodeVisitor implementation for rendering a scene.
 * This visitor traverses the scene graph, collecting transparent and
 * opaque osg::Drawables into a depth sorted transparent bin and a state
 * sorted opaque bin.  The opaque bin is rendered first, and then the
 * transparent bin in rendered in order from the furthest osg::Drawable
 * from the eye to the one nearest the eye. 
 */
class OSGUTIL_EXPORT CullVisitor : public osg::NodeVisitor
{
    public:

        CullVisitor();
        virtual ~CullVisitor();

        virtual CullVisitor* cloneType() const { return new CullVisitor(); }

        virtual void reset();

        virtual void apply(osg::Node&);
        virtual void apply(osg::Geode& node);
        virtual void apply(osg::Billboard& node);
        virtual void apply(osg::LightSource& node);

        virtual void apply(osg::Group& node);
        virtual void apply(osg::Transform& node);
        virtual void apply(osg::Projection& node);
        virtual void apply(osg::Switch& node);
        virtual void apply(osg::LOD& node);
        virtual void apply(osg::EarthSky& node);
        virtual void apply(osg::Impostor& node);

        void setEarthSky(const osg::EarthSky* earthSky) { _earthSky = earthSky; }
        const osg::EarthSky* getEarthSky() const { return _earthSky.get(); }


        void setLODBias(const float bias) { _LODBias = bias; }
        const float getLODBias() const    { return _LODBias; }
        
        /** Switch the creation of Impostors on or off.
          * Setting active to false forces the CullVisitor to use the Impostor
          * LOD children for rendering. Setting active to true forces the
          * CullVisitor to create the appropriate pre-rendering stages which
          * render to the ImpostorSprite's texture.*/
        void setImpostorsActive(const bool active) { _impostorActive = active; }
        
        /** Get whether impostors are active or not. */
        const bool getImpostorsActive() const { return _impostorActive; }

        /** Set the impostor error threshold.
          * Used in calculation of whether impostors remain valid.*/
        void setImpostorPixelErrorThreshold(const float numPixels) { _impostorPixelErrorThreshold=numPixels; }

        /** Get the impostor error threshold.*/
        const float getImpostorPixelErrorThreshold() const { return _impostorPixelErrorThreshold; }

        /** Set whether ImpsotorSprite's should be placed in a depth sorted bin for rendering.*/
        void setDepthSortImpostorSprites(const bool doDepthSort) { _depthSortImpostorSprites = doDepthSort; }

        /** Get whether ImpsotorSprite's are depth sorted bin for rendering.*/
        const bool setDepthSortImpostorSprites() const { return _depthSortImpostorSprites; }

        /** Set the number of frames that an ImpsotorSprite's is kept whilst not being beyond,
          * before being recycled.*/
        void setNumberOfFrameToKeepImpostorSprites(const int numFrames) { _numFramesToKeepImpostorSprites = numFrames; }

        /** Get the number of frames that an ImpsotorSprite's is kept whilst not being beyond,
          * before being recycled.*/
        const int getNumberOfFrameToKeepImpostorSprites() const { return _numFramesToKeepImpostorSprites; }

        enum TransparencySortMode {
            LOOK_VECTOR_DISTANCE,
            OBJECT_EYE_POINT_DISTANCE
        };

        void setTransparencySortMode(TransparencySortMode tsm) { _tsm = tsm; }
        
        /** Sets the current CullingMode.*/
        void setCullingMode(CullViewState::CullingMode mode);

        /** Returns the current CullingMode.*/
        CullViewState::CullingMode getCullingMode() const;
        

        void pushViewport(osg::Viewport* viewport);
        void popViewport();

        void pushProjectionMatrix(osg::Matrix* matrix);
        void popProjectionMatrix();

        void pushModelViewMatrix(osg::Matrix* matrix);
        void popModelViewMatrix();

        /** Push state set on the current state group.
          * If the state exists in a child state group of the current
          * state group then move the current state group to that child.
          * Otherwise, create a new state group for the state set, add
          * it to the current state group then move the current state
          * group pointer to the new state group.
          */
        inline void pushStateSet(const osg::StateSet* ss)
        {
            _currentRenderGraph = _currentRenderGraph->find_or_insert(ss);
            if (ss->useRenderBinDetails())
            {
                _currentRenderBin = _currentRenderBin->find_or_insert(ss->getBinNumber(),ss->getBinName());
            }
        }
        
        /** Pop the top state set and hence associated state group.
          * Move the current state group to the parent of the popped
          * state group.
          */
        inline void popStateSet()
        {
            if (_currentRenderGraph->_stateset->useRenderBinDetails())
            {
                _currentRenderBin = _currentRenderBin->_parent;
            }
            _currentRenderGraph = _currentRenderGraph->_parent;
        }
        
        void setRenderGraph(RenderGraph* rg)
        {
            _rootRenderGraph = rg;
            _currentRenderGraph = rg;
        }

        RenderGraph* getRenderGraph()
        {
            return _rootRenderGraph.get();
        }

        void setRenderStage(RenderStage* rg)
        {
            _rootRenderStage = rg;
            _currentRenderBin = rg;
        }

        RenderStage* getRenderStage()
        {
            return _rootRenderStage.get();
        }

        const float getCalculatedNearPlane() const { return _calculated_znear; }
        
        const float getCalculatedFarPlane() const { return _calculated_zfar; }

    protected:

        /** prevent unwanted copy construction.*/
        CullVisitor(const CullVisitor&):osg::NodeVisitor() {}

        /** prevent unwanted copy operator.*/
        CullVisitor& operator = (const CullVisitor&) { return *this; }
        
        inline osg::Matrix* getCurrentMatrix()
        {
            return _modelviewStack.back().get();
        }

        inline const osg::Vec3& getEyeLocal() const
        {
            return _eyePointStack.back();
        }
        
        inline const osg::Vec3 getUpLocal() const
        {
            const osg::Matrix& matrix = *_modelviewStack.back();
            return osg::Vec3(matrix(0,1),matrix(1,1),matrix(2,1));
        }

        inline const osg::Vec3 getLookVectorLocal() const
        {
            const osg::Matrix& matrix = *_modelviewStack.back();
            return osg::Vec3(-matrix(0,2),-matrix(1,2),-matrix(2,2));
        }


        inline bool isCulled(const osg::BoundingSphere& sp,CullViewState::CullingMode& mode) const
        {
            if (!sp.isValid()) return true;

            if (!(_modelviewClippingVolumeStack.back().contains(sp,mode))) return true;

            if (mode&CullViewState::SMALL_FEATURE_CULLING)
            {
                const float _ratio2 = 0.002f*0.002f;
                osg::Vec3 delta(sp._center-getEyeLocal());
                if (sp.radius2()<delta.length2()*_ratio2)
                {
                    return true;
                }
            }
            return false;
        }

        inline const bool isCulled(const osg::BoundingBox& bb,CullViewState::CullingMode mode) const
        {
            if (!bb.isValid()) return true;

            return !_modelviewClippingVolumeStack.back().contains(bb,mode);
        }
	
	void updateCalculatedNearFar(const osg::BoundingBox& bb);

    	void updateCalculatedNearFar(const osg::Vec3& pos);
		
        /** Add a drawable to current render graph.*/
        inline void addDrawable(osg::Drawable* drawable,osg::Matrix* matrix)
        {
            if (_currentRenderGraph->leaves_empty())
            {
                // this is first leaf to be added to RenderGraph
                // and therefore should not already know to current render bin,
                // so need to add it.
                _currentRenderBin->addRenderGraph(_currentRenderGraph);
            }
            //_currentRenderGraph->addLeaf(new RenderLeaf(drawable,matrix));
    	    _currentRenderGraph->addLeaf(createOrReuseRenderLeaf(drawable,_projectionStack.back().get(),matrix));
        }

        /** Add a drawable and depth to current render graph.*/
        inline void addDrawableAndDepth(osg::Drawable* drawable,osg::Matrix* matrix,const float depth)
        {
            if (_currentRenderGraph->leaves_empty())
            {
                // this is first leaf to be added to RenderGraph
                // and therefore should not already know to current render bin,
                // so need to add it.
                _currentRenderBin->addRenderGraph(_currentRenderGraph);
            }
            //_currentRenderGraph->addLeaf(new RenderLeaf(drawable,matrix,depth));
    	    _currentRenderGraph->addLeaf(createOrReuseRenderLeaf(drawable,_projectionStack.back().get(),matrix,depth));
        }

        /** Add a light to current render graph.*/
        inline void addLight(osg::Light* light,osg::Matrix* matrix)
        {
            _currentRenderBin->_stage->addLight(light,matrix);
        }

        /** create an impostor sprite by setting up a pre-rendering stage
          * to generate the impostor texture. */
        osg::ImpostorSprite* createImpostorSprite(osg::Impostor& node);


        osg::Viewport* getViewport()
        {
            if (!_viewportStack.empty())
            {
                return _viewportStack.back().get();
            }
            else
            {
                return 0L;
            }
        }

        osg::Matrix& getModelViewMatrix()
        {
            if (!_modelviewStack.empty())
            {
                return *_modelviewStack.back();
            }
            else
            {
                 // default construction to identity.
                static osg::Matrix identity;
                return identity;
            }
        }

        osg::Matrix& getProjectionMatrix()
        {
            if (!_projectionStack.empty())
            {
                return *_projectionStack.back();
            }
            else
            {
                 // default construction to identity.
                static osg::Matrix identity;
                return identity;
            }
        }

        const osg::Matrix getWindowMatrix()
        {
            if (!_viewportStack.empty())
            {
                osg::Viewport* viewport = _viewportStack.back().get();
                return osg::Matrix::scale(0.5f*viewport->width(),viewport->height(),0.5f)*osg::Matrix::translate(0.5f,0.5f,0.5f);
            }
            else
            {
                 // default construction to identity.
                static osg::Matrix identity;
                return identity;
            }
        }

        const osg::Matrix& getMVPW()
        {
            if (!_MVPW_Stack.empty())
            {
                if (!_MVPW_Stack.back())
                {
                    _MVPW_Stack.back() = new osg::Matrix(getModelViewMatrix()*getProjectionMatrix()*getWindowMatrix());
                }
                return *_MVPW_Stack.back();
            }
            else
            {
                 // default construction to identity.
                static osg::Matrix identity;
                return identity;
            }
        }


        void pushClippingVolume();
        void popClippingVolume();

        
        typedef std::vector<osg::ClippingVolume>            ClippingVolumeStack;
        typedef std::vector<osg::ref_ptr<osg::Matrix> >     MatrixStack;

        MatrixStack                                         _projectionStack;
        MatrixStack                                         _PW_Stack;
        ClippingVolumeStack                                 _projectionClippingVolumeStack;

        MatrixStack                                         _modelviewStack;
        MatrixStack                                         _MVPW_Stack;
        ClippingVolumeStack                                 _modelviewClippingVolumeStack;

        typedef std::vector<osg::ref_ptr<osg::Viewport> >   ViewportStack;
        ViewportStack                                       _viewportStack;
        
        typedef std::vector<osg::Vec3>                      EyePointStack;
        EyePointStack                                       _eyePointStack;
        
        typedef std::vector<CullViewState::CullingMode>     CullingModeStack;
        CullingModeStack                                    _cullingModeStack;
        
        unsigned int                                       _bbCornerNear;
        unsigned int                                       _bbCornerFar;


        osg::ref_ptr<RenderGraph>   _rootRenderGraph;
        RenderGraph*                _currentRenderGraph;

        osg::ref_ptr<RenderStage>   _rootRenderStage;        
        RenderBin*                  _currentRenderBin;


        float   _LODBias;

        float _calculated_znear;
        float _calculated_zfar;
        
        osg::ref_ptr<const osg::EarthSky> _earthSky;

        TransparencySortMode _tsm;
	
        bool _impostorActive;
        bool _depthSortImpostorSprites;
        float _impostorPixelErrorThreshold;
        int _numFramesToKeepImpostorSprites;
	
	typedef std::vector< osg::ref_ptr<osg::Matrix> > MatrixList;
	MatrixList _reuseMatrixList;
	unsigned int _currentReuseMatrixIndex;
	
	inline osg::Matrix* createOrReuseMatrix()
	{
            // skip of any already reused matrix.
            while (_currentReuseMatrixIndex<_reuseMatrixList.size() && 
                   _reuseMatrixList[_currentReuseMatrixIndex]->referenceCount()>1)
            {
                osg::notify(osg::NOTICE)<<"Warning:createOrReuseMatrix() skipping multiply refrenced entry."<< std::endl;
                ++_currentReuseMatrixIndex;
            }

            // if still within list, element must be singularly referenced
            // there return it to be reused.
            if (_currentReuseMatrixIndex<_reuseMatrixList.size())
            {
                osg::Matrix* matrix = _reuseMatrixList[_currentReuseMatrixIndex++].get();
                matrix->makeIdentity();
                return matrix;
            }

            // otherwise need to create new matrix.
            osg::Matrix* matrix = new osg::Matrix();
            _reuseMatrixList.push_back(matrix);
            ++_currentReuseMatrixIndex;
            return matrix;
	}
	
	typedef std::vector< osg::ref_ptr<RenderLeaf> > RenderLeafList;
	RenderLeafList _reuseRenderLeafList;
	unsigned int _currentReuseRenderLeafIndex;
	
	inline RenderLeaf* createOrReuseRenderLeaf(osg::Drawable* drawable,osg::Matrix* projection,osg::Matrix* matrix, float depth=0.0f)
	{
            // skip of any already reused renderleaf.
            while (_currentReuseRenderLeafIndex<_reuseRenderLeafList.size() && 
                   _reuseRenderLeafList[_currentReuseRenderLeafIndex]->referenceCount()>1)
            {
                osg::notify(osg::NOTICE)<<"Warning:createOrReuseRenderLeaf() skipping multiply refrenced entry."<< std::endl;
                ++_currentReuseRenderLeafIndex;
            }

            // if still within list, element must be singularly referenced
            // there return it to be reused.
            if (_currentReuseRenderLeafIndex<_reuseRenderLeafList.size())
            {
                RenderLeaf* renderleaf = _reuseRenderLeafList[_currentReuseRenderLeafIndex++].get();
                renderleaf->set(drawable,projection,matrix,depth);
                return renderleaf;
            }

            // otherwise need to create new renderleaf.
            RenderLeaf* renderleaf = new RenderLeaf(drawable,projection,matrix,depth);
            _reuseRenderLeafList.push_back(renderleaf);
            ++_currentReuseRenderLeafIndex;
            return renderleaf;
	}

        osg::ref_ptr<osg::ImpostorSpriteManager> _impostorSpriteManager;
	
};

}

#endif

